/// <reference types="node" />
import { AbortSignalLike } from '@azure/abort-controller';
import { AccessToken } from '@azure/core-auth';
import { AmqpError } from 'rhea-promise';
import { Message as AmqpMessage } from 'rhea-promise';
import { MessageHeader as AmqpMessageHeader } from 'rhea-promise';
import { MessageProperties as AmqpMessageProperties } from 'rhea-promise';
import AsyncLock from 'async-lock';
import { Connection } from 'rhea-promise';
import { Dictionary } from 'rhea-promise';
import { isAmqpError } from 'rhea-promise';
import { isTokenCredential } from '@azure/core-auth';
import { Receiver } from 'rhea-promise';
import { ReceiverOptions } from 'rhea-promise';
import { ReqResLink } from 'rhea-promise';
import { Sender } from 'rhea-promise';
import { SenderOptions } from 'rhea-promise';
import { Session } from 'rhea-promise';
import { TokenCredential } from '@azure/core-auth';
import { WebSocketImpl } from 'rhea-promise';
export { AccessToken }
export { AmqpMessage }
export { AmqpMessageHeader }
export { AmqpMessageProperties }
export { AsyncLock }

/**
 * Describes the options that can be provided to create an async lock.
 */
export declare interface AsyncLockOptions {
    /**
     * @property {number} [timeout] The max timeout. Default is: 0 (never timeout).
     */
    timeout?: number;
    /**
     * @property {number} [maxPending] Maximum pending tasks. Default is: 1000.
     */
    maxPending?: number;
    /**
     * @property {boolean} [domainReentrant] Whether lock can reenter in the same domain.
     * Default is: false.
     */
    domainReentrant?: boolean;
    /**
     * @property {any} [Promise] Your implementation of the promise. Default is: global promise.
     */
    Promise?: any;
}

/**
 * @class CbsClient
 * Describes the EventHub/ServiceBus Cbs client that talks to the $cbs endopint over AMQP connection.
 */
export declare class CbsClient {
    /**
     * @property {string} endpoint CBS endpoint - "$cbs"
     */
    readonly endpoint: string;
    /**
     * @property {string} replyTo CBS replyTo - The reciever link name that the service should reply to.
     */
    readonly replyTo: string;
    /**
     * @property {string} cbsLock The unqiue lock name per $cbs session per connection that is used to
     * acquire the lock for establishing a cbs session if one does not exist for an aqmp connection.
     */
    readonly cbsLock: string;
    /**
     * @property {string} connectionLock The unqiue lock name per connection that is used to
     * acquire the lock for establishing an amqp connection if one does not exist.
     */
    readonly connectionLock: string;
    /**
     * @property {Connection} connection The AMQP connection.
     */
    connection: Connection;
    /**
     * CBS sender, receiver on the same session.
     */
    private _cbsSenderReceiverLink?;
    /**
     * @constructor
     * @param {Connection} connection The AMQP conection.
     * @param {string} connectionLock A unique string (usually a guid) per connection.
     */
    constructor(connection: Connection, connectionLock: string);
    /**
     * Creates a singleton instance of the CBS session if it hasn't been initialized previously on
     * the given connection.
     * @returns {Promise<void>} Promise<void>.
     */
    init(): Promise<void>;
    /**
     * Negotiates the CBS claim with the EventHub/ServiceBus Service.
     * @param {string} audience The entity token audience for which the token is requested in one
     * of the following forms:
     *
     * - **ServiceBus**
     *    - **Sender**
     *        - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
     *        - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
     *
     *    - **Receiver**
     *         - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
     *         - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
     *
     *    - **ManagementClient**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management"`.
     *         - `"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management"`.
     *
     * - **EventHubs**
     *     - **Sender**
     *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>"`
     *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>"`.
     *
     *     - **Receiver**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`.
     *
     *     - **ManagementClient**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management"`.
     * @param {TokenInfo} tokenObject The token object that needs to be sent in the put-token request.
     * @return {Promise<any>} Returns a Promise that resolves when $cbs authentication is successful
     * and rejects when an error occurs during $cbs authentication.
     */
    negotiateClaim(audience: string, tokenObject: AccessToken, tokenType: TokenType): Promise<CbsResponse>;
    /**
     * Closes the AMQP cbs session to the EventHub/ServiceBus for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @return {Promise<void>}
     */
    close(): Promise<void>;
    /**
     * Removes the AMQP cbs session to the EventHub/ServiceBus for this client,
     * @returns {void} void
     */
    remove(): void;
    /**
     * Indicates whether the cbs sender receiver link is open or closed.
     * @return {boolean} `true` open, `false` closed.
     */
    private _isCbsSenderReceiverLinkOpen;
    private _fromAmqpMessageResponse;
}

/**
 * Describes the CBS Response.
 */
export declare interface CbsResponse {
    correlationId: string;
    statusCode: string;
    satusDescription: string;
}

/**
 * Maps the amqp error conditions to the Error names.
 * @enum {ConditionErrorNameMapper}
 */
export declare enum ConditionErrorNameMapper {
    /**
     * Error is thrown when the address is already in use.
     */
    "com.microsoft:address-already-in-use" = "AddressAlreadyInUseError",
    /**
     * Error is thrown when the store lock is lost.
     */
    "com.microsoft:store-lock-lost" = "StoreLockLostError",
    /**
     * Error is thrown when a matching subscription is not found.
     */
    "com.microsoft:no-matching-subscription" = "NoMatchingSubscriptionError",
    /**
     * Error is thrown when an attempt is made to access a parition that is not owned by the
     * requesting entity.
     */
    "com.microsoft:partition-not-owned" = "PartitionNotOwnedError",
    /**
     * Error is thrown when access to publisher has been revoked.
     */
    "com.microsoft:publisher-revoked" = "PublisherRevokedError",
    /**
     * Error is thrown when an attempt is made to create an entity that already exists.
     */
    "com.microsoft:entity-already-exists" = "MessagingEntityAlreadyExistsError",
    /**
     * Error is thrown when trying to access/connect to a disabled messaging entity.
     */
    "com.microsoft:entity-disabled" = "MessagingEntityDisabledError",
    /**
     * Error is thrown when the lock on the message is lost.
     */
    "com.microsoft:message-lock-lost" = "MessageLockLostError",
    /**
     * Error is thrown when the lock on the Azure ServiceBus session is lost.
     */
    "com.microsoft:session-lock-lost" = "SessionLockLostError",
    /**
     * Error is thrown when the Azure ServiceBus session cannot be locked.
     */
    "com.microsoft:session-cannot-be-locked" = "SessionCannotBeLockedError",
    /**
     * Error is thrown when an internal server error occured. You may have found a bug?
     */
    "amqp:internal-error" = "InternalServerError",
    /**
     * Error for signaling general communication errors related to messaging operations.
     */
    "amqp:not-found" = "ServiceCommunicationError",
    /**
     * Error is thrown when the message is not found.
     */
    "com.microsoft:message-not-found" = "MessageNotFoundError",
    /**
     * Error is thrown when relay is not found.
     */
    "com.microsoft:relay-not-found" = "RelayNotFoundError",
    /**
     * Error is thrown when a feature is not implemented yet but the placeholder is present.
     */
    "amqp:not-implemented" = "NotImplementedError",
    /**
     * Error is thrown when an operation is attempted but is not allowed.
     */
    "amqp:not-allowed" = "InvalidOperationError",
    /**
     * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
     * Quotas are reset periodically, this operation will have to wait until then.
     * The messaging entity has reached its maximum allowable size.
     * This can happen if the maximum number of receivers (which is 5) has already
     * been opened on a per-consumer group level.
     */
    "amqp:resource-limit-exceeded" = "QuotaExceededError",
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    "amqp:unauthorized-access" = "UnauthorizedError",
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    "com.microsoft:auth-failed" = "UnauthorizedError",
    /**
     * Error is thrown when the service is unavailable. The operation should be retried.
     */
    "com.microsoft:timeout" = "ServiceUnavailableError",
    /**
     * Error is thrown when no new messages are received for the specified time.
     */
    "com.microsoft:message-wait-timeout" = "MessageWaitTimeout",
    /**
     * Error is thrown when an argument has a value that is out of the admissible range.
     */
    "com.microsoft:argument-out-of-range" = "ArgumentOutOfRangeError",
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    "amqp:precondition-failed" = "PreconditionFailedError",
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    "com.microsoft:precondition-failed" = "PreconditionFailedError",
    /**
     * Error is thrown when data could not be decoded.
     */
    "amqp:decode-error" = "DecodeError",
    /**
     * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
     */
    "amqp:invalid-field" = "InvalidFieldError",
    /**
     * Error is thrown when the client attempted to work with a server entity to which it
     * has no access because another client is working with it.
     */
    "amqp:resource-locked" = "ResourceLockedError",
    /**
     * Error is thrown when a server entity the client is working with has been deleted.
     */
    "amqp:resource-deleted" = "ResourceDeletedError",
    /**
     * Error is thrown when the peer sent a frame that is not permitted in the current state.
     */
    "amqp:illegal-state" = "IllegalStateError",
    /**
     * Error is thrown when the peer cannot send a frame because the smallest encoding of
     * the performative with the currently valid values would be too large to fit within
     * a frame of the agreed maximum frame size.
     */
    "amqp:frame-size-too-small" = "FrameSizeTooSmallError",
    /**
     * Error is thrown when an operator intervened to detach for some reason.
     */
    "amqp:link:detach-forced" = "DetachForcedError",
    /**
     * Error is thrown when the peer sent more message transfers than currently allowed on the link.
     */
    "amqp:link:transfer-limit-exceeded" = "TransferLimitExceededError",
    /**
     * Error is thrown when the message sent is too large: the maximum size is 256Kb.
     */
    "amqp:link:message-size-exceeded" = "MessageTooLargeError",
    /**
     * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
     */
    "amqp:link:redirect" = "LinkRedirectError",
    /**
     * Error is thrown when two or more instances connect to the same partition
     * with different epoch values.
     */
    "amqp:link:stolen" = "ReceiverDisconnectedError",
    /**
     * Error is thrown when the peer violated incoming window for the session.
     */
    "amqp:session:window-violation" = "SessionWindowViolationError",
    /**
     * Error is thrown when input was received for a link that was detached with an error.
     */
    "amqp:session:errant-link" = "ErrantLinkError",
    /**
     * Error is thrown when an attach was received using a handle that is already in use for an attached link.
     */
    "amqp:session:handle-in-use" = "HandleInUseError",
    /**
     * Error is thrown when a frame (other than attach) was received referencing a handle which is not
     * currently in use of an attached link.
     */
    "amqp:session:unattached-handle" = "UnattachedHandleError",
    /**
     * Error is thrown when an operator intervened to close the connection for some reason.
     */
    "amqp:connection:forced" = "ConnectionForcedError",
    /**
     * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
     */
    "amqp:connection:framing-error" = "FramingError",
    /**
     * Error is thrown when the container is no longer available on the current connection.
     */
    "amqp:connection:redirect" = "ConnectionRedirectError",
    /**
     * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
     */
    "com.microsoft:server-busy" = "ServerBusyError",
    /**
     * Error is thrown when an incorrect argument was received.
     */
    "com.microsoft:argument-error" = "ArgumentError",
    /**
     * Error is thrown when server cancels the operation due to an internal issue.
     */
    "com.microsoft:operation-cancelled" = "OperationCancelledError",
    /**
     * Error is thrown when the client sender does not have enough link credits to send the message.
     */
    "client.sender:not-enough-link-credit" = "SenderBusyError",
    /**
     * Error is thrown when a low level system error is thrown by node.js.
     * {@link https://nodejs.org/dist/latest-v8.x/docs/api/all.html#errors_class_system_error}
     */
    "system:error" = "SystemError"
}

/**
 * Maps the conditions to the numeric AMQP Response status codes.
 * @enum {ConditionStatusMapper}
 */
export declare enum ConditionStatusMapper {
    "com.microsoft:timeout" = 408,
    "amqp:not-found" = 404,
    "amqp:not-implemented" = 501,
    "com.microsoft:entity-already-exists" = 409,
    "com.microsoft:message-lock-lost" = 410,
    "com.microsoft:session-lock-lost" = 410,
    "com.microsoft:no-matching-subscription" = 500,
    "amqp:link:message-size-exceeded" = 403,
    "com.microsoft:server-busy" = 503,
    "com.microsoft:argument-error" = 400,
    "com.microsoft:argument-out-of-range" = 400,
    "com.microsoft:store-lock-lost" = 410,
    "com.microsoft:session-cannot-be-locked" = 410,
    "com.microsoft:partition-not-owned" = 410,
    "com.microsoft:entity-disabled" = 400,
    "com.microsoft:publisher-revoked" = 401,
    "amqp:link:stolen" = 410,
    "amqp:not-allowed" = 400,
    "amqp:unauthorized-access" = 401,
    "amqp:resource-limit-exceeded" = 403
}

/**
 * Describes the connection config object that is created after parsing an EventHub or ServiceBus
 * connection string.
 */
export declare interface ConnectionConfig {
    /**
     * @property {string} endpoint - The service bus endpoint
     * "sb://<yournamespace>.servicebus.windows.net/".
     */
    endpoint: string;
    /**
     * @property {string} host - The host "<yournamespace>.servicebus.windows.net".
     */
    host: string;
    /**
     * @property {string} connectionString - The connection string.
     */
    connectionString: string;
    /**
     * @property {string} entityPath - The name/path of the entity (hub/queue/topic name) to which the
     * connection needs to happen.
     */
    entityPath?: string;
    /**
     * @property {string} sharedAccessKeyName - The name of the access key.
     */
    sharedAccessKeyName: string;
    /**
     * @property {string} sharedAccessKey - The secret value of the access key.
     */
    sharedAccessKey: string;
    /**
     * @property {WebSocketImpl} [webSocket] - The WebSocket constructor used to create an AMQP connection
     * over a WebSocket. In browsers, the built-in WebSocket will be  used by default. In Node, a
     * TCP socket will be used if a WebSocket constructor is not provided.
     */
    webSocket?: WebSocketImpl;
    /**
     * @property {string} [webSocketEndpointPath] - The path for the endpoint that accepts an AMQP
     * connection over WebSockets.
     */
    webSocketEndpointPath?: string;
    /**
     * @property {any} [webSocketConstructorOptions] - Options to be passed to the WebSocket constructor
     */
    webSocketConstructorOptions?: any;
}

/**
 * Describes the ConnectionConfig module
 * @module ConnectionConfig
 */
export declare namespace ConnectionConfig {
    /**
     * Creates the connection config.
     * @param {string} connectionString - The connection string for a given service like
     * EventHub/ServiceBus.
     * @param {string} [path]           - The name/path of the entity (hub name) to which the
     * connection needs to happen. This will override the EntityPath in the connectionString
     * if present.
     * @returns {ConnectionConfig} ConnectionConfig
     */
    export function create(connectionString: string, path?: string): ConnectionConfig;
    /**
     * Validates the properties of connection config.
     * @param {ConnectionConfig} config The connection config to be validated.
     * @returns {void} void
     */
    export function validate(config: ConnectionConfig, options?: ConnectionConfigOptions): void;
}

/**
 * Describes the options that can be provided while creating a connection config.
 */
export declare interface ConnectionConfigOptions {
    /**
     * @property {boolean} [isEntityPathRequired] Indicates whether the entity path is required in the
     * connection config.
     */
    isEntityPathRequired?: boolean;
}

/**
 * Provides contextual information like the underlying amqp connection, cbs session, tokenProvider,
 * Connection config, data transformer, etc.
 */
export declare interface ConnectionContextBase {
    /**
     * @property {ConnectionConfig} config The EventHub connection config that is created after
     * parsing the connection string.
     */
    readonly config: ConnectionConfig;
    /**
     * @property {string} connectionLock The unqiue lock name per connection that is used to
     * acquire the lock for establishing an aqmp connection per client if one does not exist.
     */
    connectionLock: string;
    /**
     * @property {string} negotiateClaimLock The unqiue lock name per connection that is used to
     * acquire the lock for negotiating cbs claim by an entity on that connection.
     */
    negotiateClaimLock: string;
    /**
     * @property {SharedKeyCredential | TokenCredential} tokenCredential The credential to be used for getting tokens
     * for authentication for the EventHub client.
     */
    readonly tokenCredential: SharedKeyCredential | TokenCredential;
    /**
     * @property {Connection} connection The underlying AMQP connection.
     */
    connection: Connection;
    /**
     * @property {string} connectionId The amqp connection id that uniquely identifies the
     * connection within a process.
     */
    connectionId: string;
    /**
     * @property {boolean} wasConnectionCloseCalled Indicates whether the close() method was
     * called on the connection object.
     */
    wasConnectionCloseCalled: boolean;
    /**
     * @property {DataTransformer} dataTransformer A DataTransformer object that has methods named
     * - encode Responsible for encoding the AMQP message before sending it on the wire.
     * - decode Responsible for decoding the received AMQP message before passing it to the customer.
     */
    dataTransformer: DataTransformer;
    /**
     * @property {CbsClient} cbsSession A reference to the cbs session ($cbs endpoint) on the
     * underlying AMQP connection for the EventHub Client.
     */
    cbsSession: CbsClient;
    /**
     * Updates the context to use a new underlying AMQP connection and new cbs session.
     */
    refreshConnection: () => void;
}

export declare module ConnectionContextBase {
    /**
     * Creates the base connection context.
     * @param {CreateConnectionContextBaseParameters} parameters Parameters to be provided to create
     * the base connection context.
     */
    export function create(parameters: CreateConnectionContextBaseParameters): ConnectionContextBase;
}

/**
 * Defines the properties that need to be set while establishing the AMQP connection.
 */
export declare interface ConnectionProperties {
    /**
     * @property {string} product The name of the product that will be populated as the AMQP
     * connection property. Example: "MSJSClient".
     */
    product: string;
    /**
     * @property {string} version The version of the package/sdk that is making the AMQP connection.
     */
    version: string;
    /**
     * @property {string} userAgent The userAgent that needs to be set as the AMQP connection
     * property. Example: `"/js-service-bus"` or `"/js-event-hubs,/js-event-processor-host=1.0.0"`.
     */
    userAgent: string;
}

export declare const Constants: {
    readonly associatedLinkName: "associated-link-name";
    readonly partitionKey: "x-opt-partition-key";
    readonly sequenceNumber: "x-opt-sequence-number";
    readonly enqueueSequenceNumber: "x-opt-enqueue-sequence-number";
    readonly enqueuedTime: "x-opt-enqueued-time";
    readonly scheduledEnqueueTime: "x-opt-scheduled-enqueue-time";
    readonly offset: "x-opt-offset";
    readonly lockedUntil: "x-opt-locked-until";
    readonly partitionIdName: "x-opt-partition-id";
    readonly publisher: "x-opt-publisher-name";
    readonly viaPartitionKey: "x-opt-via-partition-key";
    readonly deadLetterSource: "x-opt-deadletter-source";
    readonly enqueuedTimeAnnotation: "amqp.annotation.x-opt-enqueued-time";
    readonly offsetAnnotation: "amqp.annotation.x-opt-offset";
    readonly sequenceNumberAnnotation: "amqp.annotation.x-opt-sequence-number";
    readonly guidSize: 16;
    readonly message: "message";
    readonly error: "error";
    readonly statusCode: "status-code";
    readonly statusDescription: "status-description";
    readonly errorCondition: "error-condition";
    readonly management: "$management";
    readonly partition: "partition";
    readonly partitionId: "partitionId";
    readonly readOperation: "READ";
    readonly TLS: "tls";
    readonly establishConnection: "establishConnection";
    readonly defaultConsumerGroup: "$default";
    readonly eventHub: "eventhub";
    readonly cbsEndpoint: "$cbs";
    readonly cbsReplyTo: "cbs";
    readonly operationPutToken: "put-token";
    readonly aadEventHubsAudience: "https://eventhubs.azure.net/";
    readonly aadEventHubsScope: "https://eventhubs.azure.net//.default";
    readonly aadServiceBusAudience: "https://servicebus.azure.net/";
    readonly aadServiceBusScope: "https://servicebus.azure.net//.default";
    readonly maxUserAgentLength: 512;
    readonly vendorString: "com.microsoft";
    readonly attachEpoch: "com.microsoft:epoch";
    readonly receiverIdentifierName: "com.microsoft:receiver-name";
    readonly enableReceiverRuntimeMetricName: "com.microsoft:enable-receiver-runtime-metric";
    readonly timespan: "com.microsoft:timespan";
    readonly uri: "com.microsoft:uri";
    readonly dateTimeOffset: "com.microsoft:datetime-offset";
    readonly sessionFilterName: "com.microsoft:session-filter";
    readonly receiverError: "receiver_error";
    readonly senderError: "sender_error";
    readonly sessionError: "session_error";
    readonly connectionError: "connection_error";
    readonly defaultOperationTimeoutInMs: 60000;
    readonly defaultConnectionIdleTimeoutInMs: 60000;
    readonly managementRequestKey: "managementRequest";
    readonly negotiateCbsKey: "negotiateCbs";
    readonly negotiateClaim: "negotiateClaim";
    readonly ensureContainerAndBlob: "ensureContainerAndBlob";
    readonly defaultPrefetchCount: 1000;
    readonly reconnectLimit: 100;
    readonly maxMessageIdLength: 128;
    readonly maxPartitionKeyLength: 128;
    readonly maxSessionIdLength: 128;
    readonly pathDelimiter: "/";
    readonly ruleNameMaximumLength: 50;
    readonly maximumSqlFilterStatementLength: 1024;
    readonly maximumSqlRuleActionStatementLength: 1024;
    readonly maxDeadLetterReasonLength: 4096;
    readonly maxDurationValue: 922337203685477;
    readonly minDurationValue: -922337203685477;
    readonly maxAbsoluteExpiryTime: number;
    readonly aadTokenValidityMarginInMs: 5000;
    readonly connectionReconnectDelay: 300;
    readonly defaultMaxRetries: 3;
    readonly defaultMaxRetriesForConnection: 150;
    readonly defaultDelayBetweenOperationRetriesInMs: 30000;
    readonly defaultMaxDelayForExponentialRetryInMs: 90000;
    readonly receiverSettleMode: "receiver-settle-mode";
    readonly dispositionStatus: "disposition-status";
    readonly fromSequenceNumber: "from-sequence-number";
    readonly messageCount: "message-count";
    readonly lockTokens: "lock-tokens";
    readonly messageIdMapKey: "message-id";
    readonly sequenceNumberMapKey: "sequence-number";
    readonly lockTokenMapKey: "lock-token";
    readonly sessionIdMapKey: "session-id";
    readonly sequenceNumbers: "sequence-numbers";
    readonly deadLetterReason: "deadletter-reason";
    readonly deadLetterDescription: "deadletter-description";
    readonly propertiesToModify: "properties-to-modify";
    readonly deadLetterName: "com.microsoft:dead-letter";
    readonly trackingId: "com.microsoft:tracking-id";
    readonly serverTimeout: "com.microsoft:server-timeout";
    readonly operations: {
        readonly putToken: "put-token";
        readonly read: "READ";
        readonly cancelScheduledMessage: "com.microsoft:cancel-scheduled-message";
        readonly scheduleMessage: "com.microsoft:schedule-message";
        readonly renewLock: "com.microsoft:renew-lock";
        readonly peekMessage: "com.microsoft:peek-message";
        readonly receiveBySequenceNumber: "com.microsoft:receive-by-sequence-number";
        readonly updateDisposition: "com.microsoft:update-disposition";
        readonly renewSessionLock: "com.microsoft:renew-session-lock";
        readonly setSessionState: "com.microsoft:set-session-state";
        readonly getSessionState: "com.microsoft:get-session-state";
        readonly enumerateSessions: "com.microsoft:get-message-sessions";
        readonly addRule: "com.microsoft:add-rule";
        readonly removeRule: "com.microsoft:remove-rule";
        readonly enumerateRules: "com.microsoft:enumerate-rules";
    };
    readonly descriptorCodes: {
        readonly ruleDescriptionList: 1335734829060;
        readonly sqlFilterList: 83483426822;
        readonly correlationFilterList: 83483426825;
        readonly sqlRuleActionList: 1335734829062;
        readonly trueFilterList: 83483426823;
        readonly falseFilterList: 83483426824;
    };
};

/**
 * Describes the parameters that can be provided to create the base connection context.
 */
export declare interface CreateConnectionContextBaseParameters {
    /**
     * @property {ConnectionConfig} config The connection config that is created by parsing the
     * connection string.
     */
    config: ConnectionConfig;
    /**
     * @property {ConnectionProperties} connectionProperties Properties to be provided while creating
     * the AMQP connection.
     */
    connectionProperties: ConnectionProperties;
    /**
     * @property {SharedKeyCredential | TokenCredential} [tokenCredential] The credential to be used for Authentication.
     * Default value: SharedKeyCredentials.
     */
    tokenCredential?: SharedKeyCredential | TokenCredential;
    /**
     * @property {DataTransformer} [dataTransformer] The datatransformer to be used for encoding and
     * decoding messages. Default value: DefaultDataTransformer
     */
    dataTransformer?: DataTransformer;
    /**
     * @property {boolean} [isEntityPathRequired] Determines whether entity path should be a part of
     * the connection config. If `true` it must be present, `false` otherwise. Default value false.
     */
    isEntityPathRequired?: boolean;
    /**
     * @property {number} [operationTimeoutInMs] - The duration in which the promise should
     * complete (resolve/reject). If it is not completed, then the Promise will be rejected after
     * timeout occurs. Default: `60000 milliseconds`.
     */
    operationTimeoutInMs?: number;
}

/**
 * Describes the transformations that can be performed to encode/decode the data before sending it
 * on (or receiving it from) the wire.
 */
export declare interface DataTransformer {
    /**
     * @property {Function} encode A function that takes the body property from an EventData object
     * and returns an encoded body (some form of AMQP type).
     */
    encode: (body: any) => any;
    /**
     * @property {Function} decode A function that takes the body property from an AMQP message
     * and returns the decoded message body. If it cannot decode the body then it returns the body
     * as-is.
     */
    decode: (body: any) => any;
}

/**
 * The default data transformer that will be used by the Azure SDK.
 */
export declare class DefaultDataTransformer implements DataTransformer {
    /**
     * A function that takes the body property from an EventData object
     * and returns an encoded body (some form of AMQP type).
     *
     * @param {*} body The AMQP message body
     * @return {DataSection} encodedBody - The encoded AMQP message body as an AMQP Data type
     * (data section in rhea terms). Section object with following properties:
     * - typecode: 117 (0x75)
     * - content: The given AMQP message body as a Buffer.
     * - multiple: true | undefined.
     */
    encode(body: any): any;
    /**
     * @property {Function} [decode] A function that takes the body property from an AMQP message
     * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.
     * If it cannot decode the body then it returns the body
     * as-is.
     * @param {DataSection} body The AMQP message body
     * @return {*} decoded body or the given body as-is.
     */
    decode(body: any): any;
}

/**
 * @constant {AsyncLock} defaultLock The async lock instance with default settings.
 */
export declare const defaultLock: AsyncLock;

/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param {number} delayInMs - The number of milliseconds to be delayed.
 * @param {AbortSignalLike} abortSignal - The abortSignal associated with containing operation.
 * @param {string} abortErrorMsg - The abort error message associated with containing operation.
 * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
 * @returns {Promise<T>} - Resolved promise
 */
export declare function delay<T>(delayInMs: number, abortSignal?: AbortSignalLike, abortErrorMsg?: string, value?: T): Promise<T>;
export { Dictionary }

/**
 * Maps the Error names to the amqp error conditions.
 * @enum {ErrorNameConditionMapper}
 */
export declare enum ErrorNameConditionMapper {
    /**
     * Error is thrown when the address is already in use.
     */
    AddressAlreadyInUseError = "com.microsoft:address-already-in-use",
    /**
     * Error is thrown when the store lock is lost.
     */
    StoreLockLostError = "com.microsoft:store-lock-lost",
    /**
     * Error is thrown when a matching subscription is not found.
     */
    NoMatchingSubscriptionError = "com.microsoft:no-matching-subscription",
    /**
     * Error is thrown when an attempt is made to access a parition that is not owned by the
     * requesting entity.
     */
    PartitionNotOwnedError = "com.microsoft:partition-not-owned",
    /**
     * Error is thrown when access to publisher has been revoked.
     */
    PublisherRevokedError = "com.microsoft:publisher-revoked",
    /**
     * Error is thrown when an attempt is made to create an entity that already exists.
     */
    MessagingEntityAlreadyExistsError = "com.microsoft:entity-already-exists",
    /**
     * Error is thrown when trying to access/connect to a disabled messaging entity.
     */
    MessagingEntityDisabledError = "com.microsoft:entity-disabled",
    /**
     * Error is thrown when the lock on the message is lost.
     */
    MessageLockLostError = "com.microsoft:message-lock-lost",
    /**
     * Error is thrown when the lock on the Azure ServiceBus session is lost.
     */
    SessionLockLostError = "com.microsoft:session-lock-lost",
    /**
     * Error is thrown when the Azure ServiceBus session cannot be locked.
     */
    SessionCannotBeLockedError = "com.microsoft:session-cannot-be-locked",
    /**
     * Error is thrown when an internal server error occured. You may have found a bug?
     */
    InternalServerError = "amqp:internal-error",
    /**
     * Error for signaling general communication errors related to messaging operations.
     */
    ServiceCommunicationError = "amqp:not-found",
    /**
     * Error is thrown when message is not found.
     */
    MessageNotFoundError = "com.microsoft:message-not-found",
    /**
     * Error is thrown when relay is not found.
     */
    RelayNotFoundError = "com.microsoft:relay-not-found",
    /**
     * Error is thrown when a feature is not implemented yet but the placeholder is present.
     */
    NotImplementedError = "amqp:not-implemented",
    /**
     * Error is thrown when an operation is attempted but is not allowed.
     */
    InvalidOperationError = "amqp:not-allowed",
    /**
     * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
     * Quotas are reset periodically, this operation will have to wait until then.
     * The messaging entity has reached its maximum allowable size.
     * This can happen if the maximum number of receivers (which is 5) has already
     * been opened on a per-consumer group level.
     */
    QuotaExceededError = "amqp:resource-limit-exceeded",
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    UnauthorizedError = "amqp:unauthorized-access",
    /**
     * Error is thrown when the service is unavailable. The operation should be retried.
     */
    ServiceUnavailableError = "com.microsoft:timeout",
    /**
     * Error is thrown when no new messages are received for the specified time.
     */
    MessageWaitTimeout = "com.microsoft:message-wait-timeout",
    /**
     * Error is thrown when an argument has a value that is out of the admissible range.
     */
    ArgumentOutOfRangeError = "com.microsoft:argument-out-of-range",
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    PreconditionFailedError = "amqp:precondition-failed",
    /**
     * Error is thrown when data could not be decoded.
     */
    DecodeError = "amqp:decode-error",
    /**
     * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
     */
    InvalidFieldError = "amqp:invalid-field",
    /**
     * Error is thrown when the client attempted to work with a server entity to which it
     * has no access because another client is working with it.
     */
    ResourceLockedError = "amqp:resource-locked",
    /**
     * Error is thrown when a server entity the client is working with has been deleted.
     */
    ResourceDeletedError = "amqp:resource-deleted",
    /**
     * Error is thrown when the peer sent a frame that is not permitted in the current state.
     */
    IllegalStateError = "amqp:illegal-state",
    /**
     * Error is thrown when the peer cannot send a frame because the smallest encoding of
     * the performative with the currently valid values would be too large to fit within
     * a frame of the agreed maximum frame size.
     */
    FrameSizeTooSmallError = "amqp:frame-size-too-small",
    /**
     * Error is thrown when an operator intervened to detach for some reason.
     */
    DetachForcedError = "amqp:link:detach-forced",
    /**
     * Error is thrown when the peer sent more message transfers than currently allowed on the link.
     */
    TransferLimitExceededError = "amqp:link:transfer-limit-exceeded",
    /**
     * Error is thrown when the message sent is too large: the maximum size is 256Kb.
     */
    MessageTooLargeError = "amqp:link:message-size-exceeded",
    /**
     * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
     */
    LinkRedirectError = "amqp:link:redirect",
    /**
     * Error is thrown when two or more instances connect to the same partition
     * with different epoch values.
     */
    ReceiverDisconnectedError = "amqp:link:stolen",
    /**
     * Error is thrown when the peer violated incoming window for the session.
     */
    SessionWindowViolationError = "amqp:session:window-violation",
    /**
     * Error is thrown when input was received for a link that was detached with an error.
     */
    ErrantLinkError = "amqp:session:errant-link",
    /**
     * Error is thrown when an attach was received using a handle that is already in use for an attached link.
     */
    HandleInUseError = "amqp:session:handle-in-use",
    /**
     * Error is thrown when a frame (other than attach) was received referencing a handle which is not
     * currently in use of an attached link.
     */
    UnattachedHandleError = "amqp:session:unattached-handle",
    /**
     * Error is thrown when an operator intervened to close the connection for some reason.
     */
    ConnectionForcedError = "amqp:connection:forced",
    /**
     * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
     */
    FramingError = "amqp:connection:framing-error",
    /**
     * Error is thrown when the container is no longer available on the current connection.
     */
    ConnectionRedirectError = "amqp:connection:redirect",
    /**
     * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
     */
    ServerBusyError = "com.microsoft:server-busy",
    /**
     * Error is thrown when an incorrect argument was received.
     */
    ArgumentError = "com.microsoft:argument-error",
    /**
     * Error is thrown when server cancels the operation due to an internal issue.
     */
    OperationCancelledError = "com.microsoft:operation-cancelled",
    /**
     * Error is thrown when the client sender does not have enough link credits to send the message.
     */
    SenderBusyError = "client.sender:not-enough-link-credit",
    /**
     * Error is thrown when a low level system error is thrown by node.js.
     * {@link https://nodejs.org/api/errors.html#errors_class_systemerror}
     */
    SystemError = "system:error"
}

/**
 * Describes the connection config object that is created after parsing an EventHub connection
 * string. It also provides some convenience methods for getting the address and audience for
 * different entities.
 */
export declare interface EventHubConnectionConfig extends ConnectionConfig {
    /**
     * @property {string} entityPath - The name/path of the entity (event hub name) to which the
     * connection needs to happen.
     */
    entityPath: string;
    /**
     * Provides the EventHub Sender address in one of the following forms based on the input:
     * - `"<hubName>"`
     * - `"<hubName>/Partitions/<partitionId>"`
     *
     * @param partitionId The partitionId in the EventHub to which messages will be sent.
     */
    getSenderAddress(partitionId?: string | number): string;
    /**
     * Provides the EventHub Sender audience in one of the following forms based on the input:
     * - `"sb://<yournamespace>.servicebus.windows.net/<hubName>"`
     * - `"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>"`
     *
     * @param partitionId The partitionId in the EventHub to which messages will be sent.
     */
    getSenderAudience(partitionId?: string | number): string;
    /**
     * Provides the EventHub Receiver address:
     * - `"<hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`
     *
     * @param partitionId The partitionId in the EventHub from which messages will be received.
     * @param consumergroup The consumergoup in the EventHub from which the messages will
     * be received. Default: `$default`.
     */
    getReceiverAddress(partitionId: string | number, consumergroup?: string): string;
    /**
     * Provides the EventHub Receiver audience.
     * - `"sb://<your-namespace>.servicebus.windows.net/<hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`
     *
     * @param partitionId The partitionId in the EventHub from which messages will be received.
     * @param consumergroup The consumergoup in the EventHub from which the messages will
     * be received. Default: `$default`.
     */
    getReceiverAudience(partitionId: string | number, consumergroup?: string): string;
    /**
     * Provides the EventHub Management address.
     * - `"<hub-name>/$management"`
     */
    getManagementAddress(): string;
    /**
     * Provides the EventHub Management audience.
     * - `"sb://<your-namespace>.servicebus.windows.net/<hub-name>/$management"`
     */
    getManagementAudience(): string;
}

/**
 * Describes the connection config object that is created after parsing an EventHub connection
 * string. It also provides some convenience methods for getting the address and audience for
 * different entities.
 * @module EventHubConnectionConfig
 */
export declare module EventHubConnectionConfig {
    /**
     * Creates the connection config.
     * @param {string} connectionString - The connection string for a given service like
     * EventHub/ServiceBus.
     * @param {string} [path]           - The name/path of the entity (hub name) to which the
     * connection needs to happen. This will override the EntityPath in the connectionString
     * if present.
     * @returns {EventHubConnectionConfig} EventHubConnectionConfig
     */
    export function create(connectionString: string, path?: string): EventHubConnectionConfig;
    /**
     * Creates an EventHubConnectionConfig from the provided base ConnectionConfig.
     * @param config The base connection config from which the EventHubConnectionConfig needs to be
     * created.
     * @returns EventHubConnectionConfig
     */
    export function createFromConnectionConfig(config: ConnectionConfig): EventHubConnectionConfig;
    /**
     * Validates the properties of connection config.
     * @param {ConnectionConfig} config The connection config to be validated.
     * @returns {void} void
     */
    export function validate(config: EventHubConnectionConfig): void;
}

/**
 * Describes the eventhub connection string model.
 */
export declare interface EventHubConnectionStringModel {
    Endpoint: string;
    SharedAccessKeyName: string;
    SharedAccessKey: string;
    EntityPath?: string;
    [x: string]: any;
}

export declare function executePromisesSequentially(promiseFactories: Array<any>, kickstart?: any): Promise<any>;

/**
 * Type declaration for a Function type where T is the input to the function and V is the output
 * of the function.
 */
export declare type Func<T, V> = (a: T) => V;

/**
 * Gets a new instance of the async lock with desired settings.
 * @param {AsyncLockOptions} [options] The async lock options.
 * @returns {AsyncLock} AsyncLock
 */
export declare function getNewAsyncLock(options?: AsyncLockOptions): AsyncLock;

/**
 * @ignore
 */
export declare interface IotHubConnectionConfig {
    /**
     * @property {string} endpoint - The iothub endpoint `"<iothub-namespace>.azure-devices.net"`.
     */
    hostName: string;
    /**
     * @property {string} host - The host `"<yournamespace>"`.
     */
    host: string;
    /**
     * @property {string} connectionString - The IotHub connection string.
     */
    connectionString: string;
    /**
     * @property {string} entityPath - The name/path of the entity to which the connection needs to happen.
     */
    entityPath: string;
    /**
     * @property {string} sharedAccessKeyName - The name of the access key.
     */
    sharedAccessKeyName: string;
    /**
     * @property {string} sharedAccessKey - The secret value of the access key.
     */
    sharedAccessKey: string;
    /**
     * @property {string} [deviceId] - The unique device identifier.
     */
    deviceId?: string;
}

/**
 * @module IotHubConnectionConfig
 * @ignore
 */
export declare namespace IotHubConnectionConfig {
    /**
     * Creates the connection config.
     * @ignore
     * @param {string} connectionString - The event hub connection string
     * @param {string} [path]           - The name/path of the entity (hub name) to which the connection needs to happen
     */
    export function create(connectionString: string, path?: string): IotHubConnectionConfig;
    /**
     * Validates the properties of connection config.
     * @ignore
     * @param {ConnectionConfig} config The connection config to be validated.
     */
    export function validate(config: IotHubConnectionConfig): void;
    /**
     * Convert iothub connection config to eventhub connection config.
     * @ignore
     * @param {IotHubConnectionConfig} iotHubConfig
     */
    export function convertToEventHubConnectionConfig(iotHubConfig: IotHubConnectionConfig): EventHubConnectionConfig;
}

/**
 * Describes the iothub connection string model.
 */
export declare interface IotHubConnectionStringModel {
    HostName: string;
    SharedAccessKeyName: string;
    SharedAccessKey: string;
    DeviceId?: string;
}

/**
 * @class IotSharedKeyCredential
 * @ignore
 * Defines the IotSharedKeyCredential for IotHub.
 */
export declare class IotSharedKeyCredential extends SharedKeyCredential {
    /**
     * Gets the sas token for the specified audience for IotHub.
     * @ignore
     * @param {string} [audience] - The audience for which the token is desired. If not
     * provided then the Endpoint from the connection string will be applied.
     */
    getToken(audience: string): AccessToken;
}
export { isAmqpError }

/**
 * Determines whether the given connection string is an iothub connection string.
 * @param {string} connectionString The connection string.
 * @return {boolean} boolean.
 */
export declare function isIotHubConnectionString(connectionString: string): boolean;

/**
 * A constant that indicates whether the environment is node.js or browser based.
 */
export declare const isNode: boolean;

/**
 * Checks whether the provided error is a node.js SystemError.
 * @param err An object that may contain error information.
 */
export declare function isSystemError(err: any): err is NetworkSystemError;
export { isTokenCredential }

/**
 * The @azure/logger configuration for this package.
 * This will output logs using the `azure:event-hubs` namespace prefix.
 */
export declare const logger: import("@azure/logger").AzureLogger;

/**
 * Describes the defined set of standard header properties of the message.
 */
export declare interface MessageHeader {
    /**
     * @property {boolean} [firstAcquirer] If this value is true, then this message has not been
     * acquired by any other link. Ifthis value is false, then this message MAY have previously
     * been acquired by another link or links.
     */
    firstAcquirer?: boolean;
    /**
     * @property {number} [deliveryCount] The number of prior unsuccessful delivery attempts.
     */
    deliveryCount?: number;
    /**
     * @property {number} [ttl] time to live in ms.
     */
    ttl?: number;
    /**
     * @property {boolean} [durable] Specifies durability requirements.
     */
    durable?: boolean;
    /**
     * @property {number} [priority] The relative message priority. Higher numbers indicate higher
     * priority messages.
     */
    priority?: number;
}

/**
 * Describes the operations that can be performed on the message header.
 * @module MessageHeader
 */
export declare namespace MessageHeader {
    /**
     * Converts MessageHeader to AmqpMessageHeader.
     *
     * @param {MessageHeader} props Message header.
     * @returns {AmqpMessageHeader} AmqpMessageHeader
     */
    export function toAmqpMessageHeader(props: MessageHeader): AmqpMessageHeader;
    /**
     * Converts AmqpMessageHeader to MessageHeader.
     *
     * @param {AmqpMessageHeader} props Amqp Message Header
     * @returns {MessageHeader} MessageHeader.
     */
    export function fromAmqpMessageHeader(props: AmqpMessageHeader): MessageHeader;
}

/**
 * Describes the defined set of standard properties of the message.
 */
export declare interface MessageProperties {
    /**
     * @property {string | number | Buffer} [messageId] The application message identifier that uniquely idenitifes a message.
     * The user is responsible for making sure that this is unique in the given context. Guids usually make a good fit.
     */
    messageId?: string | number | Buffer;
    /**
     * @property {string} [replyTo] The address of the node to send replies to.
     */
    replyTo?: string;
    /**
     * @property {string} [to] The address of the node the message is destined for.
     */
    to?: string;
    /**
     * @property {string | number | Buffer} [correlationId] The id that can be used to mark or identify messages between clients.
     */
    correlationId?: string | number | Buffer;
    /**
     * @property {string} [contentType] MIME type for the message.
     */
    contentType?: string;
    /**
     * @property {string} [contentEncoding] The content-encoding property is used as a modifier to the content-type.
     * When present, its valueindicates what additional content encodings have been applied to the application-data.
     */
    contentEncoding?: string;
    /**
     * @property {number} [absoluteExpiryTime] The time when this message is considered expired.
     */
    absoluteExpiryTime?: number;
    /**
     * @property {number} [creationTime] The time this message was created.
     */
    creationTime?: number;
    /**
     * @property {string} [groupId] The group this message belongs to.
     */
    groupId?: string;
    /**
     * @property {number} [groupSequence] The sequence number of this message with its group.
     */
    groupSequence?: number;
    /**
     * @property {string} [replyToGroupId] The group the reply message belongs to.
     */
    replyToGroupId?: string;
    /**
     * @property {string} [subject] A common field for summary information about the message
     * content and purpose.
     */
    subject?: string;
    /**
     * @property {string} [userId] The identity of the user responsible for producing the message.
     */
    userId?: string;
}

/**
 * Describes the operations that can be performed on the amqp message properties.
 * @module MessageProperties
 */
export declare namespace MessageProperties {
    /**
     * Converts MessageProperties to AmqpMessageProperties.
     * @param {MessageProperties} props Message properties.
     * @returns {AmqpMessageProperties} AmqpMessageProperties.
     */
    export function toAmqpMessageProperties(props: MessageProperties): AmqpMessageProperties;
    /**
     * Converts AmqpMessageProperties to MessageProperties.
     * @param {AmqpMessageProperties} props Amqp message properties.
     * @returns {MessageProperties} MessageProperties.
     */
    export function fromAmqpMessageProperties(props: AmqpMessageProperties): MessageProperties;
}

/**
 * Describes the base class for Messaging Error.
 * @class {MessagingError}
 * @extends Error
 */
export declare class MessagingError extends Error {
    /**
     * Address to which the network connection failed.
     * Only present if the `MessagingError` was instantiated with a Node.js `SystemError`.
     */
    address?: string;
    /**
     * A string label that identifies the error.
     */
    code?: string;
    /**
     * System-provided error number.
     * Only present if the `MessagingError` was instantiated with a Node.js `SystemError`.
     */
    errno?: number | string;
    /**
     * @property {string} name The error name. Default value: "MessagingError".
     */
    name: string;
    /**
     * The unavailable network connection port.
     * Only present if the `MessagingError` was instantiated with a Node.js `SystemError`.
     */
    port?: number;
    /**
     * Name of the system call that triggered the error.
     * Only present if the `MessagingError` was instantiated with a Node.js `SystemError`.
     */
    syscall?: string;
    /**
     *
     * @property {boolean} retryable Describes whether the error is retryable. Default: true.
     */
    retryable: boolean;
    /**
     * @property {any} [info] Extra details about the error.
     */
    info?: any;
    /**
     * @param {string} message The error message that provides more information about the error.
     * @param originalError An error whose properties will be copied to the MessagingError if the
     * property matches one found on the Node.js `SystemError`.
     */
    constructor(message: string, originalError?: Error);
}

/**
 * Describes the fields on a Node.js SystemError.
 * Omits fields that are not related to network calls (e.g. file system calls).
 * See https://nodejs.org/dist/latest-v12.x/docs/api/errors.html#errors_class_systemerror
 */
export declare interface NetworkSystemError {
    address?: string;
    code: string;
    errno: string | number;
    info?: any;
    message: string;
    name: string;
    port?: number;
    stack: string;
    syscall: string;
}

/**
 * Parses the connection string and returns an object of type T.
 *
 * Connection strings have the following syntax:
 *
 * ConnectionString ::= Part { ";" Part } [ ";" ] [ WhiteSpace ]
 * Part             ::= [ PartLiteral [ "=" PartLiteral ] ]
 * PartLiteral      ::= [ WhiteSpace ] Literal [ WhiteSpace ]
 * Literal          ::= ? any sequence of characters except ; or = or WhiteSpace ?
 * WhiteSpace       ::= ? all whitespace characters including \r and \n ?
 *
 * @param {string} connectionString The connection string to be parsed.
 * @returns {ParsedOutput<T>} ParsedOutput<T>.
 */
export declare function parseConnectionString<T>(connectionString: string): ParsedOutput<T>;

/**
 * Defines an object with possible properties defined in T.
 * @type ParsedOutput<T>
 */
export declare type ParsedOutput<T> = {
    [P in keyof T]: T[P];
};

/**
 * Generates a random number between the given interval
 * @param {number} min Min number of the range (inclusive).
 * @param {number} max Max number of the range (inclusive).
 */
export declare function randomNumberFromInterval(min: number, max: number): number;

/**
 * Describes an amqp request(sender)-response(receiver) link that is created over an amqp session.
 * @class RequestResponseLink
 */
export declare class RequestResponseLink implements ReqResLink {
    session: Session;
    sender: Sender;
    receiver: Receiver;
    /**
     * @constructor
     * @param {Session} session The amqp session.
     * @param {Sender} sender The amqp sender link.
     * @param {Receiver} receiver The amqp receiver link.
     */
    constructor(session: Session, sender: Sender, receiver: Receiver);
    /**
     * Provides the underlying amqp connection object.
     * @returns {Connection} Connection.
     */
    get connection(): Connection;
    /**
     * Indicates whether the session and the sender and receiver links are all open or closed.
     * @returns {boolean} boolean - `true` - `open`, `false` - `closed`.
     */
    isOpen(): boolean;
    /**
     * Sends the given request message and returns the received response. If the operation is not
     * completed in the provided timeout in milliseconds `default: 60000`, then `OperationTimeoutError` is thrown.
     *
     * @param {Message} request The AMQP (request) message.
     * @param {SendRequestOptions} [options] Options that can be provided while sending a request.
     * @returns {Promise<Message>} Promise<Message> The AMQP (response) message.
     */
    sendRequest(request: AmqpMessage, options?: SendRequestOptions): Promise<AmqpMessage>;
    /**
     * Closes the sender, receiver link and the underlying session.
     * @returns {Promise<void>} Promise<void>
     */
    close(): Promise<void>;
    /**
     * Removes the sender, receiver link and it's underlying session.
     * @returns {void} void
     */
    remove(): void;
    /**
     * Creates an amqp request/response link.
     *
     * @param {Connection} connection The amqp connection.
     * @param {SenderOptions} senderOptions Options that must be provided to create the sender link.
     * @param {ReceiverOptions} receiverOptions Options that must be provided to create the receiver link.
     * @returns {Promise<RequestResponseLink>} Promise<RequestResponseLink>
     */
    static create(connection: Connection, senderOptions: SenderOptions, receiverOptions: ReceiverOptions): Promise<RequestResponseLink>;
}

/**
 * Every operation is attempted at least once. Additional attempts are made if the previous attempt failed
 * with a retryable error. The number of additional attempts is governed by the `maxRetries` property provided
 * on the `RetryConfig` argument.
 *
 * If `mode` option is set to `Fixed`, then the retries are made on the
 * given operation for a specified number of times, with a fixed delay in between each retry each time.
 *
 * If `mode` option is set to `Exponential`, then the delay between retries is adjusted to increase
 * exponentially with each attempt using back-off factor of power 2.
 *
 * @param {RetryConfig<T>} config Parameters to configure retry operation
 *
 * @return {Promise<T>} Promise<T>.
 */
export declare function retry<T>(config: RetryConfig<T>): Promise<T>;

/**
 * Provides a list of retryable AMQP errors.
 * "InternalServerError", "ServerBusyError", "ServiceUnavailableError", "OperationCancelledError",
 * "SenderBusyError", "MessagingError", "DetachForcedError", "ConnectionForcedError",
 * "TransferLimitExceededError"
 */
export declare const retryableErrors: string[];

/**
 * Describes the parameters that need to be configured for the retry operation.
 */
export declare interface RetryConfig<T> {
    /**
     * @property {Promise<T>} operation The operation that needs to be retried.
     */
    operation: () => Promise<T>;
    /**
     * @property {string} connectionId The connection identifier. Used in logging information.
     * Extremely useful when multiple connections are logged in the same file.
     */
    connectionId: string;
    /**
     * @property {RetryOperationType} operationType The name/type of operation to be performed.
     * Extremely useful in providing better debug logs.
     */
    operationType: RetryOperationType;
    /**
     * @property {string} connectionHost The host "<yournamespace>.servicebus.windows.net".
     * Used to check network connectivity.
     */
    connectionHost?: string;
    /**
     * @property {RetryOptions} retryOptions The retry related options associated with given operation execution.
     */
    retryOptions?: RetryOptions;
    /**
     * @property {AbortSignalLike} [abortSignal] The `AbortSignal` associated with the operation being retried on.
     * If this signal is fired during the wait time between retries, then the `retry()` method will ensure that the wait is abandoned and the retry process gets cancelled. If this signal is fired when the operation is in progress, then the operation is expected to react to it.
     */
    abortSignal?: AbortSignalLike;
}

/**
 * Describes the Retry Mode type
 * @enum RetryMode
 */
export declare enum RetryMode {
    Exponential = 0,
    Fixed = 1
}

/**
 * Describes the retry operation type.
 * @enum RetryOperationType
 */
export declare enum RetryOperationType {
    cbsAuth = "cbsAuth",
    connection = "connection",
    management = "management",
    receiverLink = "receiverLink",
    senderLink = "senderLink",
    sendMessage = "sendMessage",
    receiveMessage = "receiveMessage",
    session = "session"
}

/**
 * Retry policy options that determine the mode, number of retries, retry interval etc.
 */
export declare interface RetryOptions {
    /**
     * @property {number} [maxRetries] Number of times the operation needs to be retried in case
     * of retryable error. Default: 3.
     */
    maxRetries?: number;
    /**
     * @property {number} [retryDelayInMs] Amount of time to wait in milliseconds before making the
     * next attempt. Default: `30000 milliseconds`.
     * When `mode` option is set to `Exponential`,
     * this is used to compute the exponentially increasing delays between retries.
     */
    retryDelayInMs?: number;
    /**
     * Number of milliseconds to wait before declaring that current attempt has timed out which will trigger a retry
     * A minimum value of `60000` milliseconds will be used if a value not greater than this is provided.
     */
    timeoutInMs?: number;
    /**
     * @property {RetryMode} [mode] Denotes which retry mode to apply. If undefined, defaults to `Fixed`
     */
    mode?: RetryMode;
    /**
     * @property {number} [maxRetryDelayInMs] Denotes the maximum delay between retries
     * that the retry attempts will be capped at. Applicable only when performing exponential retry.
     */
    maxRetryDelayInMs?: number;
}

/**
 * Describes the options that can be specified while sending a request.
 */
export declare interface SendRequestOptions {
    /**
     * @property {AbortSignalLike} [abortSignal] Cancels the operation.
     */
    abortSignal?: AbortSignalLike;
    /**
     * @property {number} [timeoutInMs] Max time to wait for the operation to complete.
     * Default: `60000 milliseconds`.
     */
    timeoutInMs?: number;
    /**
     * @property {string} [requestName] Name of the request being performed.
     */
    requestName?: string;
}

/**
 * Describes the servicebus connection string model.
 */
export declare interface ServiceBusConnectionStringModel {
    Endpoint: string;
    SharedAccessKeyName: string;
    SharedAccessKey: string;
    EntityPath?: string;
    [x: string]: any;
}

/**
 * @class SharedKeyCredential
 * Defines the SharedKeyCredential .
 */
export declare class SharedKeyCredential {
    /**
     * @property {string} keyName - The name of the EventHub/ServiceBus key.
     */
    keyName: string;
    /**
     * @property {string} key - The secret value associated with the above EventHub/ServiceBus key.
     */
    key: string;
    /**
     * Initializes a new instance of SharedKeyCredential
     * @constructor
     * @param {string} keyName - The name of the EventHub/ServiceBus key.
     * @param {string} key - The secret value associated with the above EventHub/ServiceBus key
     */
    constructor(keyName: string, key: string);
    /**
     * Gets the sas token for the specified audience
     * @param {string} [audience] - The audience for which the token is desired.
     */
    getToken(audience: string): AccessToken;
    /**
     * Creates the sas token based on the provided information
     * @param {string | number} expiry - The time period in unix time after which the token will expire.
     * @param {string} [audience] - The audience for which the token is desired.
     * @param {string | Buffer} [hashInput] The input to be provided to hmac to create the hash.
     */
    protected _createToken(expiry: number, audience: string, hashInput?: string | Buffer): AccessToken;
    /**
     * Creates a token provider from the EventHub/ServiceBus connection string;
     * @param {string} connectionString - The EventHub/ServiceBus connection string
     */
    static fromConnectionString(connectionString: string): SharedKeyCredential;
}

/**
 * Describes the stroage connection string model.
 */
export declare interface StorageConnectionStringModel {
    DefaultEndpointsProtocol: string;
    AccountName: string;
    AccountKey: string;
    EndpointSuffix: string;
    [x: string]: any;
}

/**
 * Maps some SytemErrors to amqp error conditions
 * @enum SystemErrorConditionMapper
 */
export declare enum SystemErrorConditionMapper {
    ENOTFOUND = "amqp:not-found",
    EBUSY = "com.microsoft:server-busy",
    ECONNREFUSED = "amqp:connection:forced",
    ETIMEDOUT = "com.microsoft:timeout",
    ECONNRESET = "com.microsoft:timeout",
    ENETDOWN = "com.microsoft:timeout",
    EHOSTDOWN = "com.microsoft:timeout",
    ENETRESET = "com.microsoft:timeout",
    ENETUNREACH = "com.microsoft:timeout",
    ENONET = "com.microsoft:timeout"
}

/**
 * Describes a Timeout class that can wait for the specified amount of time and then resolve/reject
 * the promise with the given value.
 * @class Timout
 */
export declare class Timeout {
    private _timer?;
    set<T>(t: number, value?: T): Promise<T>;
    clear(): void;
    wrap<T>(promise: Promise<T>, t: number, value?: T): Promise<T>;
    private _promiseFinally;
    static set<T>(t: number, value?: T): Promise<T>;
    static wrap<T>(promise: Promise<T>, t: number, value?: T): Promise<T>;
}
export { TokenCredential }

/**
 * Describes the type of supported tokens.
 * @enum TokenType
 */
export declare enum TokenType {
    /**
     * The "jwt" token type. Used with AADTokenCredential.
     */
    CbsTokenTypeJwt = "jwt",
    /**
     * The sas token type. Used with SharedKeyCredential.
     */
    CbsTokenTypeSas = "servicebus.windows.net:sastoken"
}

/**
 * Translates the AQMP error received at the protocol layer or a SystemError into a MessagingError.
 * All other errors are returned unaltered.
 *
 * @param {AmqpError} err The amqp error that was received.
 * @returns {MessagingError} MessagingError object.
 */
export declare function translate(err: AmqpError | Error): MessagingError | Error;

/**
 * Options to configure the channelling of the AMQP connection over Web Sockets.
 */
export declare interface WebSocketOptions {
    /**
     * @property
     * The WebSocket constructor used to create an AMQP connection over a WebSocket.
     * This option should be provided in the below scenarios:
     * - The TCP port 5671 which is that is used by the AMQP connection to Event Hubs is blocked in your environment.
     * - Your application needs to be run behind a proxy server.
     * - Your application needs to run in the browser and you want to provide your own choice of Websocket implementation
     *   instead of the built-in WebSocket in the browser.
     */
    webSocket?: WebSocketImpl;
    /**
     * @property
     * Options to be passed to the WebSocket constructor when the underlying `rhea` library instantiates
     * the WebSocket.
     */
    webSocketConstructorOptions?: any;
}

export { }
