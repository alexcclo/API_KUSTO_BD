{"version":3,"file":"dataTransformer.js","sourceRoot":"","sources":["../../src/dataTransformer.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC;AAElC,OAAO,EAAE,OAAO,EAAE,MAAM,cAAc,CAAC;AACvC,OAAO,EAAE,MAAM,EAAE,kBAAkB,EAAE,MAAM,OAAO,CAAC;AACnD,OAAO,QAAQ,MAAM,WAAW,CAAC;AACjC,OAAO,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAoBhC;;GAEG;AACH,MAAM,OAAO,sBAAsB;IACjC;;;;;;;;;;OAUG;IACH,MAAM,CAAC,IAAS;QACd,IAAI,MAAW,CAAC;QAChB,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE;YAClB,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;SACrC;aAAM;YACL,6EAA6E;YAC7E,sFAAsF;YACtF,uBAAuB;YACvB,IAAI,IAAI,KAAK,SAAS;gBAAE,IAAI,GAAG,IAAI,CAAC,CAAC,sBAAsB;YAC3D,IAAI;gBACF,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBACrC,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC;aAC7D;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,GAAG,GACP,uEAAuE;oBACvE,IAAI;oBACJ,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC;gBAC7C,MAAM,CAAC,OAAO,CAAC,WAAW,GAAG,GAAG,CAAC,CAAC;gBAClC,kBAAkB,CAAC,GAAG,CAAC,CAAC;gBACxB,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;aACtB;SACF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;;;OAOG;IACH,MAAM,CAAC,IAAS;QACd,IAAI,aAAa,GAAQ,IAAI,CAAC;QAC9B,IAAI;YACF,IAAI,IAAI,CAAC,OAAO,IAAI,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;gBAC1C,sFAAsF;gBACtF,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC;aAC9B;YACD,IAAI;gBACF,wFAAwF;gBACxF,yBAAyB;gBACzB,MAAM,OAAO,GAAW,aAAa,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;gBACvD,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;aACrC;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,CAAC,OAAO,CACZ,6EAA6E;oBAC3E,iBAAiB,EACnB,GAAG,CACJ,CAAC;aACH;SACF;QAAC,OAAO,GAAG,EAAE;YACZ,MAAM,CAAC,OAAO,CACZ,uFAAuF,EACvF,GAAG,CACJ,CAAC;SACH;QACD,OAAO,aAAa,CAAC;IACvB,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { message } from \"rhea-promise\";\nimport { logger, logErrorStackTrace } from \"./log\";\nimport isBuffer from \"is-buffer\";\nimport { Buffer } from \"buffer\";\n\n/**\n * Describes the transformations that can be performed to encode/decode the data before sending it\n * on (or receiving it from) the wire.\n */\nexport interface DataTransformer {\n  /**\n   * @property {Function} encode A function that takes the body property from an EventData object\n   * and returns an encoded body (some form of AMQP type).\n   */\n  encode: (body: any) => any;\n  /**\n   * @property {Function} decode A function that takes the body property from an AMQP message\n   * and returns the decoded message body. If it cannot decode the body then it returns the body\n   * as-is.\n   */\n  decode: (body: any) => any;\n}\n\n/**\n * The default data transformer that will be used by the Azure SDK.\n */\nexport class DefaultDataTransformer implements DataTransformer {\n  /**\n   * A function that takes the body property from an EventData object\n   * and returns an encoded body (some form of AMQP type).\n   *\n   * @param {*} body The AMQP message body\n   * @return {DataSection} encodedBody - The encoded AMQP message body as an AMQP Data type\n   * (data section in rhea terms). Section object with following properties:\n   * - typecode: 117 (0x75)\n   * - content: The given AMQP message body as a Buffer.\n   * - multiple: true | undefined.\n   */\n  encode(body: any): any {\n    let result: any;\n    if (isBuffer(body)) {\n      result = message.data_section(body);\n    } else {\n      // string, undefined, null, boolean, array, object, number should end up here\n      // coercing undefined to null as that will ensure that null value will be given to the\n      // customer on receive.\n      if (body === undefined) body = null; // tslint:disable-line\n      try {\n        const bodyStr = JSON.stringify(body);\n        result = message.data_section(Buffer.from(bodyStr, \"utf8\"));\n      } catch (err) {\n        const msg =\n          `An error occurred while executing JSON.stringify() on the given body ` +\n          body +\n          `${err ? err.stack : JSON.stringify(err)}`;\n        logger.warning(\"[encode] \" + msg);\n        logErrorStackTrace(err);\n        throw new Error(msg);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @property {Function} [decode] A function that takes the body property from an AMQP message\n   * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.\n   * If it cannot decode the body then it returns the body\n   * as-is.\n   * @param {DataSection} body The AMQP message body\n   * @return {*} decoded body or the given body as-is.\n   */\n  decode(body: any): any {\n    let processedBody: any = body;\n    try {\n      if (body.content && isBuffer(body.content)) {\n        // This indicates that we are getting the AMQP described type. Let us try decoding it.\n        processedBody = body.content;\n      }\n      try {\n        // Trying to stringify and JSON.parse() anything else will fail flat and we shall return\n        // the original type back\n        const bodyStr: string = processedBody.toString(\"utf8\");\n        processedBody = JSON.parse(bodyStr);\n      } catch (err) {\n        logger.verbose(\n          \"[decode] An error occurred while trying JSON.parse() on the received body. \" +\n            \"The error is %O\",\n          err\n        );\n      }\n    } catch (err) {\n      logger.verbose(\n        \"[decode] An error occurred while decoding the received message body. The error is: %O\",\n        err\n      );\n    }\n    return processedBody;\n  }\n}\n"]}