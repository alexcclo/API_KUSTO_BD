// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import { translate } from "./errors";
import { delay } from "./util/utils";
import { logger } from "./log";
import { Constants } from "./util/constants";
import { checkNetworkConnection } from "./util/checkNetworkConnection";
/**
 * Determines whether the object is a Delivery object.
 * @ignore
 */
function isDelivery(obj) {
    let result = false;
    if (obj &&
        typeof obj.id === "number" &&
        typeof obj.settled === "boolean" &&
        typeof obj.remote_settled === "boolean" &&
        typeof obj.format === "number") {
        result = true;
    }
    return result;
}
/**
 * Describes the Retry Mode type
 * @enum RetryMode
 */
export var RetryMode;
(function (RetryMode) {
    RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
    RetryMode[RetryMode["Fixed"] = 1] = "Fixed";
})(RetryMode || (RetryMode = {}));
/**
 * Describes the retry operation type.
 * @enum RetryOperationType
 */
export var RetryOperationType;
(function (RetryOperationType) {
    RetryOperationType["cbsAuth"] = "cbsAuth";
    RetryOperationType["connection"] = "connection";
    RetryOperationType["management"] = "management";
    RetryOperationType["receiverLink"] = "receiverLink";
    RetryOperationType["senderLink"] = "senderLink";
    RetryOperationType["sendMessage"] = "sendMessage";
    RetryOperationType["receiveMessage"] = "receiveMessage";
    RetryOperationType["session"] = "session";
})(RetryOperationType || (RetryOperationType = {}));
/**
 * Validates the retry config.
 * @ignore
 */
function validateRetryConfig(config) {
    if (!config.operation) {
        throw new TypeError("Missing 'operation' in retry configuration");
    }
    if (!config.connectionId) {
        throw new TypeError("Missing 'connectionId' in retry configuration");
    }
    if (!config.operationType) {
        throw new TypeError("Missing 'operationType' in retry configuration");
    }
}
/**
 * Every operation is attempted at least once. Additional attempts are made if the previous attempt failed
 * with a retryable error. The number of additional attempts is governed by the `maxRetries` property provided
 * on the `RetryConfig` argument.
 *
 * If `mode` option is set to `Fixed`, then the retries are made on the
 * given operation for a specified number of times, with a fixed delay in between each retry each time.
 *
 * If `mode` option is set to `Exponential`, then the delay between retries is adjusted to increase
 * exponentially with each attempt using back-off factor of power 2.
 *
 * @param {RetryConfig<T>} config Parameters to configure retry operation
 *
 * @return {Promise<T>} Promise<T>.
 */
export function retry(config) {
    return __awaiter(this, void 0, void 0, function* () {
        validateRetryConfig(config);
        if (!config.retryOptions) {
            config.retryOptions = {};
        }
        if (config.retryOptions.maxRetries == undefined || config.retryOptions.maxRetries < 0) {
            config.retryOptions.maxRetries = Constants.defaultMaxRetries;
        }
        if (config.retryOptions.retryDelayInMs == undefined || config.retryOptions.retryDelayInMs < 0) {
            config.retryOptions.retryDelayInMs = Constants.defaultDelayBetweenOperationRetriesInMs;
        }
        if (config.retryOptions.maxRetryDelayInMs == undefined ||
            config.retryOptions.maxRetryDelayInMs < 0) {
            config.retryOptions.maxRetryDelayInMs = Constants.defaultMaxDelayForExponentialRetryInMs;
        }
        if (config.retryOptions.mode == undefined) {
            config.retryOptions.mode = RetryMode.Fixed;
        }
        let lastError;
        let result;
        let success = false;
        const totalNumberOfAttempts = config.retryOptions.maxRetries + 1;
        for (let i = 1; i <= totalNumberOfAttempts; i++) {
            logger.verbose("[%s] Attempt number: %d", config.connectionId, config.operationType, i);
            try {
                result = yield config.operation();
                success = true;
                logger.verbose("[%s] Success for '%s', after attempt number: %d.", config.connectionId, config.operationType, i);
                if (result && !isDelivery(result)) {
                    logger.verbose("[%s] Success result for '%s': %O", config.connectionId, config.operationType, result);
                }
                break;
            }
            catch (err) {
                if (!err.translated) {
                    err = translate(err);
                }
                if (!err.retryable && err.name === "ServiceCommunicationError" && config.connectionHost) {
                    const isConnected = yield checkNetworkConnection(config.connectionHost);
                    if (!isConnected) {
                        err.name = "ConnectionLostError";
                        err.retryable = true;
                    }
                }
                lastError = err;
                logger.verbose("[%s] Error occured for '%s' in attempt number %d: %O", config.connectionId, config.operationType, i, err);
                let targetDelayInMs = config.retryOptions.retryDelayInMs;
                if (config.retryOptions.mode === RetryMode.Exponential) {
                    let incrementDelta = Math.pow(2, i) - 1;
                    const boundedRandDelta = config.retryOptions.retryDelayInMs * 0.8 +
                        Math.floor(Math.random() *
                            (config.retryOptions.retryDelayInMs * 1.2 - config.retryOptions.retryDelayInMs * 0.8));
                    incrementDelta *= boundedRandDelta;
                    targetDelayInMs = Math.min(incrementDelta, config.retryOptions.maxRetryDelayInMs);
                }
                if (lastError && lastError.retryable) {
                    logger.verbose("[%s] Sleeping for %d milliseconds for '%s'.", config.connectionId, targetDelayInMs, config.operationType);
                    yield delay(targetDelayInMs, config.abortSignal, `The retry operation has been cancelled by the user.`);
                    continue;
                }
                else {
                    break;
                }
            }
        }
        if (success) {
            return result;
        }
        else {
            throw lastError;
        }
    });
}
//# sourceMappingURL=retry.js.map