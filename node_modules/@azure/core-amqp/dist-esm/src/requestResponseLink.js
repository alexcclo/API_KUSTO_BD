// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import { AbortError } from "@azure/abort-controller";
import { Constants } from "./util/constants";
import { ReceiverEvents } from "rhea-promise";
import { translate, ConditionStatusMapper } from "./errors";
import { logger, logErrorStackTrace } from "./log";
/**
 * Describes an amqp request(sender)-response(receiver) link that is created over an amqp session.
 * @class RequestResponseLink
 */
export class RequestResponseLink {
    /**
     * @constructor
     * @param {Session} session The amqp session.
     * @param {Sender} sender The amqp sender link.
     * @param {Receiver} receiver The amqp receiver link.
     */
    constructor(session, sender, receiver) {
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
    }
    /**
     * Provides the underlying amqp connection object.
     * @returns {Connection} Connection.
     */
    get connection() {
        return this.session.connection;
    }
    /**
     * Indicates whether the session and the sender and receiver links are all open or closed.
     * @returns {boolean} boolean - `true` - `open`, `false` - `closed`.
     */
    isOpen() {
        return this.session.isOpen() && this.sender.isOpen() && this.receiver.isOpen();
    }
    /**
     * Sends the given request message and returns the received response. If the operation is not
     * completed in the provided timeout in milliseconds `default: 60000`, then `OperationTimeoutError` is thrown.
     *
     * @param {Message} request The AMQP (request) message.
     * @param {SendRequestOptions} [options] Options that can be provided while sending a request.
     * @returns {Promise<Message>} Promise<Message> The AMQP (response) message.
     */
    sendRequest(request, options = {}) {
        const timeoutInMs = options.timeoutInMs || Constants.defaultOperationTimeoutInMs;
        const aborter = options.abortSignal;
        return new Promise((resolve, reject) => {
            let waitTimer;
            let timeOver = false;
            const rejectOnAbort = () => {
                const address = this.receiver.address || "address";
                const requestName = options.requestName;
                const desc = `[${this.connection.id}] The request "${requestName}" ` +
                    `to "${address}" has been cancelled by the user.`;
                // Cancellation is a user-intended action, so log to info instead of warning.
                logger.info(desc);
                const error = new AbortError(`The ${requestName ? requestName + " " : ""}operation has been cancelled by the user.`);
                reject(error);
            };
            const onAbort = () => {
                // remove the event listener as this will be registered next time someone makes a request.
                this.receiver.removeListener(ReceiverEvents.message, messageCallback);
                // safe to clear the timeout if it hasn't already occurred.
                if (!timeOver) {
                    clearTimeout(waitTimer);
                }
                aborter.removeEventListener("abort", onAbort);
                rejectOnAbort();
            };
            if (aborter) {
                // the aborter may have been triggered between request attempts
                // so check if it was triggered and reject if needed.
                if (aborter.aborted) {
                    return rejectOnAbort();
                }
                aborter.addEventListener("abort", onAbort);
            }
            // Handle different variations of property names in responses emitted by EventHubs and ServiceBus.
            const getCodeDescriptionAndError = (props) => {
                if (!props)
                    props = {};
                return {
                    statusCode: (props[Constants.statusCode] || props.statusCode),
                    statusDescription: (props[Constants.statusDescription] ||
                        props.statusDescription),
                    errorCondition: (props[Constants.errorCondition] || props.errorCondition)
                };
            };
            const messageCallback = (context) => {
                if (aborter) {
                    aborter.removeEventListener("abort", onAbort);
                }
                const info = getCodeDescriptionAndError(context.message.application_properties);
                const responseCorrelationId = context.message.correlation_id;
                logger.verbose("[%s] %s response: ", this.connection.id, request.to || "$management", context.message);
                if (request.message_id !== responseCorrelationId &&
                    request.correlation_id !== responseCorrelationId) {
                    // do not remove message listener.
                    // parallel requests listen on the same receiver, so continue waiting until respose that matches
                    // request via correlationId is found.
                    logger.verbose("[%s] request-messageId | '%s' != '%s' | response-correlationId. " +
                        "Hence dropping this response and waiting for the next one.", this.connection.id, request.message_id, responseCorrelationId);
                    return;
                }
                // remove the event listeners as they will be registered next time when someone makes a request.
                this.receiver.removeListener(ReceiverEvents.message, messageCallback);
                if (info.statusCode > 199 && info.statusCode < 300) {
                    if (!timeOver) {
                        clearTimeout(waitTimer);
                    }
                    logger.verbose("[%s] request-messageId | '%s' == '%s' | response-correlationId.", this.connection.id, request.message_id, responseCorrelationId);
                    return resolve(context.message);
                }
                else {
                    const condition = info.errorCondition || ConditionStatusMapper[info.statusCode] || "amqp:internal-error";
                    const e = {
                        condition: condition,
                        description: info.statusDescription
                    };
                    const error = translate(e);
                    logger.warning(error);
                    logErrorStackTrace(error);
                    return reject(error);
                }
            };
            const actionAfterTimeout = () => {
                timeOver = true;
                this.receiver.removeListener(ReceiverEvents.message, messageCallback);
                if (aborter) {
                    aborter.removeEventListener("abort", onAbort);
                }
                const address = this.receiver.address || "address";
                const desc = `The request with message_id "${request.message_id}" to "${address}" ` +
                    `endpoint timed out. Please try again later.`;
                const e = {
                    name: "OperationTimeoutError",
                    message: desc
                };
                return reject(translate(e));
            };
            waitTimer = setTimeout(actionAfterTimeout, timeoutInMs);
            this.receiver.on(ReceiverEvents.message, messageCallback);
            logger.verbose("[%s] %s request sent: %O", this.connection.id, request.to || "$managment", request);
            this.sender.send(request);
        });
    }
    /**
     * Closes the sender, receiver link and the underlying session.
     * @returns {Promise<void>} Promise<void>
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sender.close();
            yield this.receiver.close();
            yield this.session.close();
        });
    }
    /**
     * Removes the sender, receiver link and it's underlying session.
     * @returns {void} void
     */
    remove() {
        this.sender.remove();
        this.receiver.remove();
        this.session.remove();
    }
    /**
     * Creates an amqp request/response link.
     *
     * @param {Connection} connection The amqp connection.
     * @param {SenderOptions} senderOptions Options that must be provided to create the sender link.
     * @param {ReceiverOptions} receiverOptions Options that must be provided to create the receiver link.
     * @returns {Promise<RequestResponseLink>} Promise<RequestResponseLink>
     */
    static create(connection, senderOptions, receiverOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const session = yield connection.createSession();
            const sender = yield session.createSender(senderOptions);
            const receiver = yield session.createReceiver(receiverOptions);
            logger.verbose("[%s] Successfully created the sender and receiver links on the same session.", connection.id);
            return new RequestResponseLink(session, sender, receiver);
        });
    }
}
//# sourceMappingURL=requestResponseLink.js.map