'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var logger$1 = require('@azure/logger');
var coreAmqp = require('@azure/core-amqp');
var os = require('os');
var crypto = _interopDefault(require('crypto'));
var rheaPromise = require('rhea-promise');
var abortController = require('@azure/abort-controller');
var coreTracing = require('@azure/core-tracing');
var types = require('@opentelemetry/types');
require('@azure/core-asynciterator-polyfill');

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The @azure/logger configuration for this package.
 * This will output logs using the `azure:event-hubs` namespace prefix.
 */
const logger = logger$1.createClientLogger("event-hubs");
/**
 * Logs the error's stack trace to "verbose" if a stack trace is available.
 * @param error Error containing a stack trace.
 * @ignore
 */
function logErrorStackTrace(error) {
    if (error && error.stack) {
        logger.verbose(error.stack);
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Returns information about the platform this function is being run on.
 * @ignore
 * @internal
 */
function getRuntimeInfo() {
    return `NODE-VERSION ${process.version}; ${os.type()} ${os.release()}`;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * @ignore
 */
const packageJsonInfo = {
    name: "@azure/event-hubs",
    version: "5.1.0"
};

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.



var rng = function nodeRNG() {
  return crypto.randomBytes(16);
};

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

var bytesToUuid_1 = bytesToUuid;

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid_1(rnds);
}

var v4_1 = v4;

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the base class for entities like EventHub Sender, Receiver and Management link.
 * @internal
 * @ignore
 * @class LinkEntity
 */
class LinkEntity {
    /**
     * Creates a new LinkEntity instance.
     * @ignore
     * @constructor
     * @param context The connection context.
     * @param [options] Options that can be provided while creating the LinkEntity.
     */
    constructor(context, options) {
        /**
         * @property isConnecting Indicates whether the link is in the process of connecting
         * (establishing) itself. Default value: `false`.
         */
        this.isConnecting = false;
        if (!options)
            options = {};
        this._context = context;
        this.address = options.address || "";
        this.audience = options.audience || "";
        this.name = `${options.name}-${v4_1()}`;
        this.partitionId = options.partitionId;
    }
    /**
     * Negotiates cbs claim for the LinkEntity.
     * @ignore
     * @protected
     * @param [setTokenRenewal] Set the token renewal timer. Default false.
     * @returns Promise<void>
     */
    _negotiateClaim(setTokenRenewal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Acquire the lock and establish a cbs session if it does not exist on the connection.
            // Although node.js is single threaded, we need a locking mechanism to ensure that a
            // race condition does not happen while creating a shared resource (in this case the
            // cbs session, since we want to have exactly 1 cbs session per connection).
            logger.verbose("[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: " +
                "'%s' with address: '%s'.", this._context.connectionId, this._context.cbsSession.cbsLock, this._type, this.name, this.address);
            yield coreAmqp.defaultLock.acquire(this._context.cbsSession.cbsLock, () => {
                return this._context.cbsSession.init();
            });
            let tokenObject;
            let tokenType;
            if (this._context.tokenCredential instanceof coreAmqp.SharedKeyCredential) {
                tokenObject = this._context.tokenCredential.getToken(this.audience);
                tokenType = coreAmqp.TokenType.CbsTokenTypeSas;
                // renew sas token in every 45 minutess
                this._tokenTimeoutInMs = (3600 - 900) * 1000;
            }
            else {
                const aadToken = yield this._context.tokenCredential.getToken(coreAmqp.Constants.aadEventHubsScope);
                if (!aadToken) {
                    throw new Error(`Failed to get token from the provided "TokenCredential" object`);
                }
                tokenObject = aadToken;
                tokenType = coreAmqp.TokenType.CbsTokenTypeJwt;
                this._tokenTimeoutInMs = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;
            }
            logger.verbose("[%s] %s: calling negotiateClaim for audience '%s'.", this._context.connectionId, this._type, this.audience);
            // Acquire the lock to negotiate the CBS claim.
            logger.verbose("[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this._context.connectionId, this._context.negotiateClaimLock, this._type, this.name, this.address);
            yield coreAmqp.defaultLock.acquire(this._context.negotiateClaimLock, () => {
                return this._context.cbsSession.negotiateClaim(this.audience, tokenObject, tokenType);
            });
            logger.verbose("[%s] Negotiated claim for %s '%s' with with address: %s", this._context.connectionId, this._type, this.name, this.address);
            if (setTokenRenewal) {
                yield this._ensureTokenRenewal();
            }
        });
    }
    /**
     * Ensures that the token is renewed within the predefined renewal margin.
     * @ignore
     * @protected
     * @returns
     */
    _ensureTokenRenewal() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this._tokenTimeoutInMs) {
                return;
            }
            this._tokenRenewalTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield this._negotiateClaim(true);
                }
                catch (err) {
                    logger.verbose("[%s] %s '%s' with address %s, an error occurred while renewing the token: %O", this._context.connectionId, this._type, this.name, this.address, err);
                }
            }), this._tokenTimeoutInMs);
            logger.verbose("[%s] %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).", this._context.connectionId, this._type, this.name, this.address, this._tokenTimeoutInMs, new Date(Date.now() + this._tokenTimeoutInMs).toString());
        });
    }
    /**
     * Closes the Sender|Receiver link and it's underlying session and also removes it from the
     * internal map.
     * @ignore
     * @param [link] The Sender or Receiver link that needs to be closed and
     * removed.
     */
    _closeLink(link) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._tokenRenewalTimer);
            if (link) {
                try {
                    // Closing the link and its underlying sessionÂ if the link is open. This should also
                    // remove them from the internal map.
                    yield link.close();
                    logger.verbose("[%s] %s '%s' with address '%s' closed.", this._context.connectionId, this._type, this.name, this.address);
                }
                catch (err) {
                    logger.verbose("[%s] An error occurred while closing the %s '%s' with address '%s': %O", this._context.connectionId, this._type, this.name, this.address, err);
                }
            }
        });
    }
    /**
     * Provides the current type of the LinkEntity.
     * @returns The entity type.
     */
    get _type() {
        let result = "LinkEntity";
        if (this.constructor && this.constructor.name) {
            result = this.constructor.name;
        }
        return result;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * @ignore
 */
function getRetryAttemptTimeoutInMs(retryOptions) {
    const timeoutInMs = retryOptions == undefined ||
        typeof retryOptions.timeoutInMs !== "number" ||
        !isFinite(retryOptions.timeoutInMs) ||
        retryOptions.timeoutInMs < coreAmqp.Constants.defaultOperationTimeoutInMs
        ? coreAmqp.Constants.defaultOperationTimeoutInMs
        : retryOptions.timeoutInMs;
    return timeoutInMs;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @class ManagementClient
 * @internal
 * @ignore
 * Descibes the EventHubs Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
class ManagementClient extends LinkEntity {
    /**
     * Instantiates the management client.
     * @constructor
     * @ignore
     * @param context The connection context.
     * @param [address] The address for the management endpoint. For IotHub it will be
     * `/messages/events/$management`.
     */
    constructor(context, options) {
        super(context, {
            address: options && options.address ? options.address : coreAmqp.Constants.management,
            audience: options && options.audience ? options.audience : context.config.getManagementAudience()
        });
        this.managementLock = `${coreAmqp.Constants.managementRequestKey}-${v4_1()}`;
        /**
         * @property replyTo The reply to Guid for the management client.
         */
        this.replyTo = v4_1();
        this._context = context;
        this.entityPath = context.config.entityPath;
    }
    /**
     * Gets the security token for the management application properties.
     * @ignore
     * @internal
     */
    getSecurityToken() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._context.tokenCredential instanceof coreAmqp.SharedKeyCredential) {
                // the security_token has the $management address removed from the end of the audience
                // expected audience: sb://fully.qualified.namespace/event-hub-name/$management
                const audienceParts = this.audience.split("/");
                // for management links, address should be '$management'
                if (audienceParts[audienceParts.length - 1] === this.address) {
                    audienceParts.pop();
                }
                const audience = audienceParts.join("/");
                return this._context.tokenCredential.getToken(audience);
            }
            // aad credentials use the aad scope
            return this._context.tokenCredential.getToken(coreAmqp.Constants.aadEventHubsScope);
        });
    }
    /**
     * Provides the eventhub runtime information.
     * @ignore
     * @param connection - The established amqp connection
     * @returns
     */
    getHubRuntimeInformation(options) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!options) {
                options = {};
            }
            const securityToken = yield this.getSecurityToken();
            const request = {
                body: Buffer.from(JSON.stringify([])),
                message_id: v4_1(),
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.readOperation,
                    name: this.entityPath,
                    type: `${coreAmqp.Constants.vendorString}:${coreAmqp.Constants.eventHub}`,
                    security_token: (_a = securityToken) === null || _a === void 0 ? void 0 : _a.token
                }
            };
            const info = yield this._makeManagementRequest(request, Object.assign(Object.assign({}, options), { requestName: "getHubRuntimeInformation" }));
            const runtimeInfo = {
                name: info.name,
                createdOn: new Date(info.created_at),
                partitionIds: info.partition_ids
            };
            logger.verbose("[%s] The hub runtime info is: %O", this._context.connectionId, runtimeInfo);
            return runtimeInfo;
        });
    }
    /**
     * Provides an array of partitionIds.
     * @ignore
     * @param connection - The established amqp connection
     * @returns
     */
    getPartitionIds() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const runtimeInfo = yield this.getHubRuntimeInformation();
            return runtimeInfo.partitionIds;
        });
    }
    /**
     * Provides information about the specified partition.
     * @ignore
     * @param connection - The established amqp connection
     * @param partitionId Partition ID for which partition information is required.
     */
    getPartitionProperties(partitionId, options) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!options) {
                options = {};
            }
            const securityToken = yield this.getSecurityToken();
            const request = {
                body: Buffer.from(JSON.stringify([])),
                message_id: v4_1(),
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.readOperation,
                    name: this.entityPath,
                    type: `${coreAmqp.Constants.vendorString}:${coreAmqp.Constants.partition}`,
                    partition: `${partitionId}`,
                    security_token: (_a = securityToken) === null || _a === void 0 ? void 0 : _a.token
                }
            };
            const info = yield this._makeManagementRequest(request, Object.assign(Object.assign({}, options), { requestName: "getPartitionInformation" }));
            const partitionInfo = {
                beginningSequenceNumber: info.begin_sequence_number,
                eventHubName: info.name,
                lastEnqueuedOffset: info.last_enqueued_offset,
                lastEnqueuedOnUtc: new Date(info.last_enqueued_time_utc),
                lastEnqueuedSequenceNumber: info.last_enqueued_sequence_number,
                partitionId: info.partition,
                isEmpty: info.is_partition_empty
            };
            logger.verbose("[%s] The partition info is: %O.", this._context.connectionId, partitionInfo);
            return partitionInfo;
        });
    }
    /**
     * Closes the AMQP management session to the Event Hub for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @ignore
     * @returns
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._isMgmtRequestResponseLinkOpen()) {
                    const mgmtLink = this._mgmtReqResLink;
                    this._mgmtReqResLink = undefined;
                    clearTimeout(this._tokenRenewalTimer);
                    yield mgmtLink.close();
                    logger.info("Successfully closed the management session.");
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the management session: ${err}`;
                logger.warning(msg);
                logErrorStackTrace(err);
                throw new Error(msg);
            }
        });
    }
    _init() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this._isMgmtRequestResponseLinkOpen()) {
                    yield this._negotiateClaim();
                    const rxopt = {
                        source: { address: this.address },
                        name: this.replyTo,
                        target: { address: this.replyTo },
                        onSessionError: (context) => {
                            const id = context.connection.options.id;
                            const ehError = coreAmqp.translate(context.session.error);
                            logger.verbose("[%s] An error occurred on the session for request/response links for " +
                                "$management: %O", id, ehError);
                        }
                    };
                    const sropt = { target: { address: this.address } };
                    logger.verbose("[%s] Creating sender/receiver links on a session for $management endpoint with " +
                        "srOpts: %o, receiverOpts: %O.", this._context.connectionId, sropt, rxopt);
                    this._mgmtReqResLink = yield coreAmqp.RequestResponseLink.create(this._context.connection, sropt, rxopt);
                    this._mgmtReqResLink.sender.on(rheaPromise.SenderEvents.senderError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = coreAmqp.translate(context.sender.error);
                        logger.verbose("[%s] An error occurred on the $management sender link.. %O", id, ehError);
                    });
                    this._mgmtReqResLink.receiver.on(rheaPromise.ReceiverEvents.receiverError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = coreAmqp.translate(context.receiver.error);
                        logger.verbose("[%s] An error occurred on the $management receiver link.. %O", id, ehError);
                    });
                    logger.verbose("[%s] Created sender '%s' and receiver '%s' links for $management endpoint.", this._context.connectionId, this._mgmtReqResLink.sender.name, this._mgmtReqResLink.receiver.name);
                    yield this._ensureTokenRenewal();
                }
            }
            catch (err) {
                err = coreAmqp.translate(err);
                logger.warning("[%s] An error occured while establishing the $management links: %O", this._context.connectionId, err);
                logErrorStackTrace(err);
                throw err;
            }
        });
    }
    /**
     * @private
     * Helper method to make the management request
     * @param request The AMQP message to send
     * @param options The options to use when sending a request over a $management link
     */
    _makeManagementRequest(request, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const retryOptions = options.retryOptions || {};
            try {
                const abortSignal = options && options.abortSignal;
                const sendOperationPromise = () => new Promise((resolve, reject) => tslib.__awaiter(this, void 0, void 0, function* () {
                    let count = 0;
                    const retryTimeoutInMs = getRetryAttemptTimeoutInMs(options.retryOptions);
                    let timeTakenByInit = 0;
                    const rejectOnAbort = () => {
                        const requestName = options.requestName;
                        const desc = `[${this._context.connectionId}] The request "${requestName}" ` +
                            `to has been cancelled by the user.`;
                        // Cancellation is user-intended behavior, so log to info instead of warning.
                        logger.info(desc);
                        const error = new abortController.AbortError(`The ${requestName ? requestName + " " : ""}operation has been cancelled by the user.`);
                        reject(error);
                    };
                    if (abortSignal) {
                        if (abortSignal.aborted) {
                            return rejectOnAbort();
                        }
                    }
                    if (!this._isMgmtRequestResponseLinkOpen()) {
                        logger.verbose("[%s] Acquiring lock to get the management req res link.", this._context.connectionId);
                        const initOperationStartTime = Date.now();
                        const actionAfterTimeout = () => {
                            const desc = `The request with message_id "${request.message_id}" timed out. Please try again later.`;
                            const e = {
                                name: "OperationTimeoutError",
                                message: desc
                            };
                            return reject(coreAmqp.translate(e));
                        };
                        const waitTimer = setTimeout(actionAfterTimeout, retryTimeoutInMs);
                        try {
                            yield coreAmqp.defaultLock.acquire(this.managementLock, () => {
                                return this._init();
                            });
                        }
                        catch (err) {
                            return reject(coreAmqp.translate(err));
                        }
                        finally {
                            clearTimeout(waitTimer);
                        }
                        timeTakenByInit = Date.now() - initOperationStartTime;
                    }
                    const remainingOperationTimeoutInMs = retryTimeoutInMs - timeTakenByInit;
                    const sendRequestOptions = {
                        abortSignal: options.abortSignal,
                        requestName: options.requestName,
                        timeoutInMs: remainingOperationTimeoutInMs
                    };
                    count++;
                    if (count !== 1) {
                        // Generate a new message_id every time after the first attempt
                        request.message_id = rheaPromise.generate_uuid();
                    }
                    else if (!request.message_id) {
                        // Set the message_id in the first attempt only if it is not set
                        request.message_id = rheaPromise.generate_uuid();
                    }
                    try {
                        const result = yield this._mgmtReqResLink.sendRequest(request, sendRequestOptions);
                        resolve(result);
                    }
                    catch (err) {
                        err = coreAmqp.translate(err);
                        logger.warning("[%s] An error occurred during send on management request-response link with address " +
                            "'%s': %O", this._context.connectionId, this.address, err);
                        logErrorStackTrace(err);
                        reject(err);
                    }
                }));
                const config = {
                    operation: sendOperationPromise,
                    connectionId: this._context.connectionId,
                    operationType: coreAmqp.RetryOperationType.management,
                    abortSignal: abortSignal,
                    retryOptions: retryOptions
                };
                return (yield coreAmqp.retry(config)).body;
            }
            catch (err) {
                err = coreAmqp.translate(err);
                logger.warning("An error occurred while making the request to $management endpoint: %O", err);
                logErrorStackTrace(err);
                throw err;
            }
        });
    }
    _isMgmtRequestResponseLinkOpen() {
        return this._mgmtReqResLink && this._mgmtReqResLink.isOpen();
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * @ignore
 */
var ConnectionContext;
(function (ConnectionContext) {
    /**
     * @property userAgent The user agent string for the EventHubs client.
     * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk
     */
    const userAgent = `azsdk-js-azureeventhubs/${packageJsonInfo.version} (${getRuntimeInfo()})`;
    function getUserAgent(options) {
        const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;
        if (finalUserAgent.length > coreAmqp.Constants.maxUserAgentLength) {
            throw new Error(`The user-agent string cannot be more than ${coreAmqp.Constants.maxUserAgentLength} characters in length.` +
                `The given user-agent string is: ${finalUserAgent} with length: ${finalUserAgent.length}`);
        }
        return finalUserAgent;
    }
    ConnectionContext.getUserAgent = getUserAgent;
    function create(config, tokenCredential, options) {
        if (!options)
            options = {};
        config.webSocket = options.webSocketOptions && options.webSocketOptions.webSocket;
        config.webSocketEndpointPath = "$servicebus/websocket";
        config.webSocketConstructorOptions =
            options.webSocketOptions && options.webSocketOptions.webSocketConstructorOptions;
        const parameters = {
            config: config,
            tokenCredential: tokenCredential,
            // re-enabling this will be a post-GA discussion.
            // dataTransformer: options.dataTransformer,
            isEntityPathRequired: true,
            connectionProperties: {
                product: "MSJSClient",
                userAgent: getUserAgent(options),
                version: packageJsonInfo.version
            }
        };
        // Let us create the base context and then add EventHub specific ConnectionContext properties.
        const connectionContext = coreAmqp.ConnectionContextBase.create(parameters);
        connectionContext.wasConnectionCloseCalled = false;
        connectionContext.senders = {};
        connectionContext.receivers = {};
        const mOptions = {
            address: options.managementSessionAddress,
            audience: options.managementSessionAudience
        };
        connectionContext.managementSession = new ManagementClient(connectionContext, mOptions);
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = (context) => {
            connectionContext.wasConnectionCloseCalled = false;
            logger.verbose("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            logger.verbose("[%s] 'disconnected' event occurred on the amqp connection.", connectionContext.connection.id);
            if (context.connection && context.connection.error) {
                logger.verbose("[%s] Accompanying error on the context.connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                logger.verbose("[%s] Accompanying error on the context: %O", connectionContext.connection.id, context.error);
            }
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numSenders: Object.keys(connectionContext.senders).length,
                numReceivers: Object.keys(connectionContext.receivers).length
            };
            logger.verbose("[%s] Closing all open senders and receivers in the state: %O", connectionContext.connection.id, state);
            // Clear internal map maintained by rhea to avoid reconnecting of old links once the
            // connection is back up.
            connectionContext.connection.removeAllSessions();
            // Close the cbs session to ensure all the event handlers are released.
            yield connectionContext.cbsSession.close();
            // Close the management session to ensure all the event handlers are released.
            yield connectionContext.managementSession.close();
            // Close all senders and receivers to ensure clean up of timers & other resources.
            if (state.numSenders || state.numReceivers) {
                for (const senderName of Object.keys(connectionContext.senders)) {
                    const sender = connectionContext.senders[senderName];
                    if (!sender.isConnecting) {
                        yield sender.close().catch((err) => {
                            logger.verbose("[%s] Error when closing sender [%s] after disconnected event: %O", connectionContext.connection.id, senderName, err);
                        });
                    }
                }
                for (const receiverName of Object.keys(connectionContext.receivers)) {
                    const receiver = connectionContext.receivers[receiverName];
                    if (!receiver.isConnecting) {
                        yield receiver.close().catch((err) => {
                            logger.verbose("[%s] Error when closing sender [%s] after disconnected event: %O", connectionContext.connection.id, receiverName, err);
                        });
                    }
                }
            }
        });
        const protocolError = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            logger.verbose("[%s] 'protocol_error' event occurred on the amqp connection.", connectionContext.connection.id);
            if (context.connection && context.connection.error) {
                logger.verbose("[%s] Accompanying error on the context.connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                logger.verbose("[%s] Accompanying error on the context: %O", connectionContext.connection.id, context.error);
            }
        });
        const error = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            logger.verbose("[%s] 'error' event occurred on the amqp connection.", connectionContext.connection.id);
            if (context.connection && context.connection.error) {
                logger.verbose("[%s] Accompanying error on the context.connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                logger.verbose("[%s] Accompanying error on the context: %O", connectionContext.connection.id, context.error);
            }
        });
        // Add listeners on the connection object.
        connectionContext.connection.on(rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.disconnected, disconnected);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.protocolError, protocolError);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.error, error);
        logger.verbose("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
})(ConnectionContext || (ConnectionContext = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
const messagePropertiesMap = {
    message_id: "messageId",
    user_id: "userId",
    to: "to",
    subject: "subject",
    reply_to: "replyTo",
    correlation_id: "correlationId",
    content_type: "contentType",
    content_encoding: "contentEncoding",
    absolute_expiry_time: "absoluteExpiryTime",
    creation_time: "creationTime",
    group_id: "groupId",
    group_sequence: "groupSequence",
    reply_to_group_id: "replyToGroupId"
};
/**
 * Converts the AMQP message to an EventData.
 * @param msg The AMQP message that needs to be converted to EventData.
 * @ignore
 */
function fromAmqpMessage(msg) {
    const data = {
        body: msg.body
    };
    if (msg.message_annotations) {
        for (const annotationKey of Object.keys(msg.message_annotations)) {
            switch (annotationKey) {
                case coreAmqp.Constants.partitionKey:
                    data.partitionKey = msg.message_annotations[annotationKey];
                    break;
                case coreAmqp.Constants.sequenceNumber:
                    data.sequenceNumber = msg.message_annotations[annotationKey];
                    break;
                case coreAmqp.Constants.enqueuedTime:
                    data.enqueuedTimeUtc = new Date(msg.message_annotations[annotationKey]);
                    break;
                case coreAmqp.Constants.offset:
                    data.offset = msg.message_annotations[annotationKey];
                    break;
                default:
                    if (!data.systemProperties) {
                        data.systemProperties = {};
                    }
                    data.systemProperties[annotationKey] = msg.message_annotations[annotationKey];
                    break;
            }
        }
    }
    if (msg.application_properties) {
        data.properties = msg.application_properties;
    }
    if (msg.delivery_annotations) {
        data.lastEnqueuedOffset = msg.delivery_annotations.last_enqueued_offset;
        data.lastSequenceNumber = msg.delivery_annotations.last_enqueued_sequence_number;
        data.lastEnqueuedTime = new Date(msg.delivery_annotations.last_enqueued_time_utc);
        data.retrievalTime = new Date(msg.delivery_annotations.runtime_info_retrieval_time_utc);
    }
    const messageProperties = Object.keys(messagePropertiesMap);
    for (const messageProperty of messageProperties) {
        if (!data.systemProperties) {
            data.systemProperties = {};
        }
        if (msg[messageProperty] != null) {
            data.systemProperties[messagePropertiesMap[messageProperty]] = msg[messageProperty];
        }
    }
    return data;
}
/**
 * Converts an EventData object to an AMQP message.
 * @param data The EventData object that needs to be converted to an AMQP message.
 * @param partitionKey An optional key to determine the partition that this event should land in.
 * @ignore
 */
function toAmqpMessage(data, partitionKey) {
    const msg = {
        body: data.body
    };
    // As per the AMQP 1.0 spec If the message-annotations or delivery-annotations section is omitted,
    // it is equivalent to a message-annotations section containing anempty map of annotations.
    msg.message_annotations = {};
    if (data.properties) {
        msg.application_properties = data.properties;
    }
    if (partitionKey != undefined) {
        msg.message_annotations[coreAmqp.Constants.partitionKey] = partitionKey;
        // Event Hub service cannot route messages to a specific partition based on the partition key
        // if AMQP message header is an empty object. Hence we make sure that header is always present
        // with atleast one property. Setting durable to true, helps us achieve that.
        msg.durable = true;
    }
    return msg;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * @ignore
 * Logs and throws Error if the current AMQP connection is closed.
 * @param context The ConnectionContext associated with the current AMQP connection.
 */
function throwErrorIfConnectionClosed(context) {
    if (context && context.wasConnectionCloseCalled) {
        const errorMessage = "The underlying AMQP connection is closed.";
        const error = new Error(errorMessage);
        logger.warning(`[${context.connectionId}] %O`, error);
        logErrorStackTrace(error);
        throw error;
    }
}
/**
 * @internal
 * @ignore
 * Logs and Throws TypeError if given parameter is undefined or null
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param methodName Name of the method that was passed the parameter
 * @param parameterName Name of the parameter to check
 * @param parameterValue Value of the parameter to check
 */
function throwTypeErrorIfParameterMissing(connectionId, methodName, parameterName, parameterValue) {
    if (parameterValue === undefined || parameterValue === null) {
        const error = new TypeError(`${methodName} called without required argument "${parameterName}"`);
        logger.warning(`[${connectionId}] %O`, error);
        logErrorStackTrace(error);
        throw error;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 */
const TRACEPARENT_PROPERTY = "Diagnostic-Id";
/**
 * Populates the `EventData` with `SpanContext` info to support trace propagation.
 * Creates and returns a copy of the passed in `EventData` unless the `EventData`
 * has already been instrumented.
 * @param eventData The `EventData` to instrument.
 * @param span The `Span` containing the context to propagate tracing information.
 * @ignore
 * @internal
 */
function instrumentEventData(eventData, span) {
    if (eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]) {
        return eventData;
    }
    // create a copy so the original isn't modified
    eventData = Object.assign(Object.assign({}, eventData), { properties: Object.assign({}, eventData.properties) });
    const traceParent = coreTracing.getTraceParentHeader(span.context());
    if (traceParent) {
        eventData.properties[TRACEPARENT_PROPERTY] = traceParent;
    }
    return eventData;
}
/**
 * Extracts the `SpanContext` from an `EventData` if the context exists.
 * @param eventData An individual `EventData` object.
 * @internal
 * @ignore
 */
function extractSpanContextFromEventData(eventData) {
    if (!eventData.properties || !eventData.properties[TRACEPARENT_PROPERTY]) {
        return;
    }
    const diagnosticId = eventData.properties[TRACEPARENT_PROPERTY];
    return coreTracing.extractSpanContextFromTraceParentHeader(diagnosticId);
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * @ignore
 */
function createMessageSpan(parentSpan) {
    const tracer = coreTracing.getTracer();
    const span = tracer.startSpan("Azure.EventHubs.message", {
        kind: types.SpanKind.PRODUCER,
        parent: parentSpan
    });
    span.setAttribute("az.namespace", "Microsoft.EventHub");
    return span;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.
 * @param eventDataBatch The instance of `EventDataBatch` to verify.
 * @internal
 * @ignore
 */
function isEventDataBatch(eventDataBatch) {
    return (eventDataBatch &&
        typeof eventDataBatch.tryAdd === "function" &&
        typeof eventDataBatch.count === "number" &&
        typeof eventDataBatch.sizeInBytes === "number");
}
/**
 * An internal class representing a batch of events which can be used to send events to Event Hub.
 *
 * @class
 * @internal
 * @ignore
 */
class EventDataBatchImpl {
    /**
     * EventDataBatch should not be constructed using `new EventDataBatch()`
     * Use the `createBatch()` method on your `EventHubProducer` instead.
     * @constructor
     * @internal
     * @ignore
     */
    constructor(context, maxSizeInBytes, partitionKey, _partitionId) {
        this._partitionId = _partitionId;
        /**
         * @property Encoded amqp messages.
         */
        this._encodedMessages = [];
        /**
         * List of 'message' span contexts.
         */
        this._spanContexts = [];
        this._context = context;
        this._maxSizeInBytes = maxSizeInBytes;
        this._partitionKey = partitionKey;
        this._sizeInBytes = 0;
        this._count = 0;
    }
    /**
     * @property The maximum size of the batch, in bytes.
     * @readonly
     */
    get maxSizeInBytes() {
        return this._maxSizeInBytes;
    }
    /**
     * @property The partitionKey set during `EventDataBatch` creation. This value is hashed to
     * produce a partition assignment when the producer is created without a `partitionId`
     * @readonly
     */
    get partitionKey() {
        return this._partitionKey;
    }
    /**
     * The partitionId set during `EventDataBatch` creation.
     * If this value is set then partitionKey can not be set.
     * @readonly
     */
    get partitionId() {
        return this._partitionId;
    }
    /**
     * @property Size of the `EventDataBatch` instance after the events added to it have been
     * encoded into a single AMQP message.
     * @readonly
     */
    get sizeInBytes() {
        return this._sizeInBytes;
    }
    /**
     * @property Number of events in the `EventDataBatch` instance.
     * @readonly
     */
    get count() {
        return this._count;
    }
    /**
     * @property Represents the single AMQP message which is the result of encoding all the events
     * added into the `EventDataBatch` instance.
     *
     * This is not meant for the user to use directly.
     *
     * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,
     * this single batched AMQP message is what gets sent over the wire to the service.
     * @readonly
     */
    get _message() {
        return this._batchMessage;
    }
    /**
     * Gets the "message" span contexts that were created when adding events to the batch.
     * @internal
     * @ignore
     */
    get _messageSpanContexts() {
        return this._spanContexts;
    }
    /**
     * Tries to add an event data to the batch if permitted by the batch's size limit.
     * **NOTE**: Always remember to check the return value of this method, before calling it again
     * for the next event.
     *
     * @param eventData  An individual event data object.
     * @returns A boolean value indicating if the event data has been added to the batch or not.
     */
    tryAdd(eventData, options = {}) {
        throwTypeErrorIfParameterMissing(this._context.connectionId, "tryAdd", "eventData", eventData);
        // check if the event has already been instrumented
        const previouslyInstrumented = Boolean(eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]);
        if (!previouslyInstrumented) {
            const messageSpan = createMessageSpan(options.parentSpan);
            eventData = instrumentEventData(eventData, messageSpan);
            this._spanContexts.push(messageSpan.context());
            messageSpan.end();
        }
        // Convert EventData to AmqpMessage.
        const amqpMessage = toAmqpMessage(eventData, this._partitionKey);
        amqpMessage.body = this._context.dataTransformer.encode(eventData.body);
        // Encode every amqp message and then convert every encoded message to amqp data section
        this._encodedMessages.push(rheaPromise.message.encode(amqpMessage));
        const batchMessage = {
            body: rheaPromise.message.data_sections(this._encodedMessages)
        };
        if (amqpMessage.message_annotations) {
            batchMessage.message_annotations = amqpMessage.message_annotations;
        }
        const encodedBatchMessage = rheaPromise.message.encode(batchMessage);
        const currentSize = encodedBatchMessage.length;
        // this._batchMessage will be used for final send operation
        if (currentSize > this._maxSizeInBytes) {
            this._encodedMessages.pop();
            if (!previouslyInstrumented &&
                Boolean(eventData.properties && eventData.properties[TRACEPARENT_PROPERTY])) {
                this._spanContexts.pop();
            }
            return false;
        }
        this._batchMessage = encodedBatchMessage;
        this._sizeInBytes = currentSize;
        this._count++;
        return true;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the EventHubSender that will send event data to EventHub.
 * @class EventHubSender
 * @internal
 * @ignore
 */
class EventHubSender extends LinkEntity {
    /**
     * Creates a new EventHubSender instance.
     * @ignore
     * @constructor
     * @param context The connection context.
     * @param [partitionId] The EventHub partition id to which the sender
     * wants to send the event data.
     */
    constructor(context, partitionId) {
        super(context, {
            name: context.config.getSenderAddress(partitionId),
            partitionId: partitionId
        });
        /**
         * @property senderLock The unqiue lock name per connection that is used to acquire the
         * lock for establishing a sender link by an entity on that connection.
         * @readonly
         */
        this.senderLock = `sender-${v4_1()}`;
        this.address = context.config.getSenderAddress(partitionId);
        this.audience = context.config.getSenderAudience(partitionId);
        this._onAmqpError = (context) => {
            const senderError = context.sender && context.sender.error;
            logger.verbose("[%s] 'sender_error' event occurred on the sender '%s' with address '%s'. " +
                "The associated error is: %O", this._context.connectionId, this.name, this.address, senderError);
            // TODO: Consider rejecting promise in trySendBatch() or createBatch()
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            logger.verbose("[%s] 'session_error' event occurred on the session of sender '%s' with address '%s'. " +
                "The associated error is: %O", this._context.connectionId, this.name, this.address, sessionError);
            // TODO: Consider rejecting promise in trySendBatch() or createBatch()
        };
        this._onAmqpClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const sender = this._sender || context.sender;
            logger.verbose("[%s] 'sender_close' event occurred on the sender '%s' with address '%s'. " +
                "Value for isItselfClosed on the receiver is: '%s' " +
                "Value for isConnecting on the session is: '%s'.", this._context.connectionId, this.name, this.address, sender ? sender.isItselfClosed().toString() : undefined, this.isConnecting);
            if (sender && !this.isConnecting) {
                // Call close to clean up timers & other resources
                yield sender.close().catch((err) => {
                    logger.verbose("[%s] Error when closing sender [%s] after 'sender_close' event: %O", this._context.connectionId, this.name, err);
                });
            }
        });
        this._onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const sender = this._sender || context.sender;
            logger.verbose("[%s] 'session_close' event occurred on the session of sender '%s' with address '%s'. " +
                "Value for isSessionItselfClosed on the session is: '%s' " +
                "Value for isConnecting on the session is: '%s'.", this._context.connectionId, this.name, this.address, sender ? sender.isSessionItselfClosed().toString() : undefined, this.isConnecting);
            if (sender && !this.isConnecting) {
                // Call close to clean up timers & other resources
                yield sender.close().catch((err) => {
                    logger.verbose("[%s] Error when closing sender [%s] after 'session_close' event: %O", this._context.connectionId, this.name, err);
                });
            }
        });
    }
    /**
     * Deletes the sender fromt the context. Clears the token renewal timer. Closes the sender link.
     * @ignore
     * @returns Promise<void>
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._sender) {
                logger.info("[%s] Closing the Sender for the entity '%s'.", this._context.connectionId, this._context.config.entityPath);
                const senderLink = this._sender;
                this._deleteFromCache();
                yield this._closeLink(senderLink);
            }
        });
    }
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     * @ignore
     * @returns boolean
     */
    isOpen() {
        const result = this._sender && this._sender.isOpen();
        logger.verbose("[%s] Sender '%s' with address '%s' is open? -> %s", this._context.connectionId, this.name, this.address, result);
        return result;
    }
    /**
     * Returns maximum message size on the AMQP sender link.
     * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     * @returns Promise<number>
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getMaxMessageSize(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const abortSignal = options.abortSignal;
            const retryOptions = options.retryOptions || {};
            if (this.isOpen()) {
                return this._sender.maxMessageSize;
            }
            return new Promise((resolve, reject) => tslib.__awaiter(this, void 0, void 0, function* () {
                const rejectOnAbort = () => {
                    const desc = `[${this._context.connectionId}] The create batch operation has been cancelled by the user.`;
                    // Cancellation is user-intented, so treat as info instead of warning.
                    logger.info(desc);
                    const error = new abortController.AbortError(`The create batch operation has been cancelled by the user.`);
                    reject(error);
                };
                const onAbort = () => {
                    if (abortSignal) {
                        abortSignal.removeEventListener("abort", onAbort);
                    }
                    rejectOnAbort();
                };
                if (abortSignal) {
                    // the aborter may have been triggered between request attempts
                    // so check if it was triggered and reject if needed.
                    if (abortSignal.aborted) {
                        return rejectOnAbort();
                    }
                    abortSignal.addEventListener("abort", onAbort);
                }
                try {
                    logger.verbose("Acquiring lock %s for initializing the session, sender and " +
                        "possibly the connection.", this.senderLock);
                    const senderOptions = this._createSenderOptions(coreAmqp.Constants.defaultOperationTimeoutInMs);
                    yield coreAmqp.defaultLock.acquire(this.senderLock, () => {
                        const config = {
                            operation: () => this._init(senderOptions),
                            connectionId: this._context.connectionId,
                            operationType: coreAmqp.RetryOperationType.senderLink,
                            abortSignal: abortSignal,
                            retryOptions: retryOptions
                        };
                        return coreAmqp.retry(config);
                    });
                    resolve(this._sender.maxMessageSize);
                }
                catch (err) {
                    logger.warning("[%s] An error occurred while creating the sender %s", this._context.connectionId, this.name);
                    logErrorStackTrace(err);
                    reject(err);
                }
                finally {
                    if (abortSignal) {
                        abortSignal.removeEventListener("abort", onAbort);
                    }
                }
            }));
        });
    }
    /**
     * Send a batch of EventData to the EventHub. The "message_annotations",
     * "application_properties" and "properties" of the first message will be set as that
     * of the envelope (batch message).
     * @ignore
     * @param events  An array of EventData objects to be sent in a Batch message.
     * @param options Options to control the way the events are batched along with request options
     * @return Promise<void>
     */
    send(events, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                // throw an error if partition key and partition id are both defined
                if (options &&
                    typeof options.partitionKey === "string" &&
                    typeof options.partitionId === "string") {
                    const error = new Error("Partition key is not supported when using producers that were created using a partition id.");
                    logger.warning("[%s] Partition key is not supported when using producers that were created using a partition id. %O", this._context.connectionId, error);
                    logErrorStackTrace(error);
                    throw error;
                }
                // throw an error if partition key is different than the one provided in the options.
                if (isEventDataBatch(events) && options && options.partitionKey) {
                    const error = new Error("Partition key is not supported when sending a batch message. Pass the partition key when creating the batch message instead.");
                    logger.warning("[%s] Partition key is not supported when sending a batch message. Pass the partition key when creating the batch message instead. %O", this._context.connectionId, error);
                    logErrorStackTrace(error);
                    throw error;
                }
                logger.info("[%s] Sender '%s', trying to send EventData[].", this._context.connectionId, this.name);
                let encodedBatchMessage;
                if (isEventDataBatch(events)) {
                    encodedBatchMessage = events._message;
                }
                else {
                    const partitionKey = (options && options.partitionKey) || undefined;
                    const messages = [];
                    // Convert EventData to AmqpMessage.
                    for (let i = 0; i < events.length; i++) {
                        const message = toAmqpMessage(events[i], partitionKey);
                        message.body = this._context.dataTransformer.encode(events[i].body);
                        messages[i] = message;
                    }
                    // Encode every amqp message and then convert every encoded message to amqp data section
                    const batchMessage = {
                        body: rheaPromise.message.data_sections(messages.map(rheaPromise.message.encode))
                    };
                    // Set message_annotations of the first message as
                    // that of the envelope (batch message).
                    if (messages[0].message_annotations) {
                        batchMessage.message_annotations = messages[0].message_annotations;
                    }
                    // Finally encode the envelope (batch message).
                    encodedBatchMessage = rheaPromise.message.encode(batchMessage);
                }
                logger.info("[%s] Sender '%s', sending encoded batch message.", this._context.connectionId, this.name, encodedBatchMessage);
                return yield this._trySendBatch(encodedBatchMessage, options);
            }
            catch (err) {
                logger.warning("An error occurred while sending the batch message %O", err);
                logErrorStackTrace(err);
                throw err;
            }
        });
    }
    _deleteFromCache() {
        this._sender = undefined;
        delete this._context.senders[this.name];
        logger.verbose("[%s] Deleted the sender '%s' with address '%s' from the client cache.", this._context.connectionId, this.name, this.address);
    }
    _createSenderOptions(timeoutInMs, newName) {
        if (newName)
            this.name = `${v4_1()}`;
        const srOptions = {
            name: this.name,
            target: {
                address: this.address
            },
            onError: this._onAmqpError,
            onClose: this._onAmqpClose,
            onSessionError: this._onSessionError,
            onSessionClose: this._onSessionClose,
            sendTimeoutInSeconds: timeoutInMs / 1000
        };
        logger.verbose("Creating sender with options: %O", srOptions);
        return srOptions;
    }
    /**
     * Tries to send the message to EventHub if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     * @ignore
     * @param message The message to be sent to EventHub.
     * @returns Promise<void>
     */
    _trySendBatch(message, options = {}) {
        const abortSignal = options.abortSignal;
        const retryOptions = options.retryOptions || {};
        const sendEventPromise = () => new Promise((resolve, reject) => tslib.__awaiter(this, void 0, void 0, function* () {
            const rejectOnAbort = () => {
                const desc = `[${this._context.connectionId}] The send operation on the Sender "${this.name}" with ` +
                    `address "${this.address}" has been cancelled by the user.`;
                // Cancellation is user-intended, so log to info instead of warning.
                logger.info(desc);
                return reject(new abortController.AbortError("The send operation has been cancelled by the user."));
            };
            if (abortSignal && abortSignal.aborted) {
                // operation has been cancelled, so exit quickly
                return rejectOnAbort();
            }
            const removeListeners = () => {
                clearTimeout(waitTimer);
                if (abortSignal) {
                    abortSignal.removeEventListener("abort", onAborted);
                }
            };
            const onAborted = () => {
                removeListeners();
                return rejectOnAbort();
            };
            if (abortSignal) {
                abortSignal.addEventListener("abort", onAborted);
            }
            const actionAfterTimeout = () => {
                removeListeners();
                const desc = `[${this._context.connectionId}] Sender "${this.name}" with ` +
                    `address "${this.address}", was not able to send the message right now, due ` +
                    `to operation timeout.`;
                logger.warning(desc);
                const e = {
                    name: "OperationTimeoutError",
                    message: desc
                };
                return reject(coreAmqp.translate(e));
            };
            const waitTimer = setTimeout(actionAfterTimeout, getRetryAttemptTimeoutInMs(options.retryOptions));
            if (!this.isOpen()) {
                logger.verbose("Acquiring lock %s for initializing the session, sender and " +
                    "possibly the connection.", this.senderLock);
                try {
                    const senderOptions = this._createSenderOptions(getRetryAttemptTimeoutInMs(options.retryOptions));
                    yield coreAmqp.defaultLock.acquire(this.senderLock, () => {
                        return this._init(senderOptions);
                    });
                }
                catch (err) {
                    removeListeners();
                    err = coreAmqp.translate(err);
                    logger.warning("[%s] An error occurred while creating the sender %s", this._context.connectionId, this.name, err);
                    logErrorStackTrace(err);
                    return reject(err);
                }
            }
            logger.verbose("[%s] Sender '%s', credit: %d available: %d", this._context.connectionId, this.name, this._sender.credit, this._sender.session.outgoing.available());
            if (this._sender.sendable()) {
                logger.verbose("[%s] Sender '%s', sending message with id '%s'.", this._context.connectionId, this.name);
                try {
                    const delivery = yield this._sender.send(message, undefined, 0x80013700);
                    logger.info("[%s] Sender '%s', sent message with delivery id: %d", this._context.connectionId, this.name, delivery.id);
                    return resolve();
                }
                catch (err) {
                    err = coreAmqp.translate(err.innerError || err);
                    logger.warning("[%s] An error occurred while sending the message", this._context.connectionId, err);
                    logErrorStackTrace(err);
                    return reject(err);
                }
                finally {
                    removeListeners();
                }
            }
            else {
                // let us retry to send the message after some time.
                const msg = `[${this._context.connectionId}] Sender "${this.name}", ` +
                    `cannot send the message right now. Please try later.`;
                logger.warning(msg);
                const amqpError = {
                    condition: coreAmqp.ErrorNameConditionMapper.SenderBusyError,
                    description: msg
                };
                reject(coreAmqp.translate(amqpError));
            }
        }));
        const config = {
            operation: sendEventPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.sendMessage,
            abortSignal: abortSignal,
            retryOptions: retryOptions
        };
        return coreAmqp.retry(config);
    }
    /**
     * Initializes the sender session on the connection.
     * @ignore
     * @returns
     */
    _init(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.isOpen() && !this.isConnecting) {
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    logger.verbose("[%s] Trying to create sender '%s'...", this._context.connectionId, this.name);
                    this._sender = yield this._context.connection.createAwaitableSender(options);
                    this.isConnecting = false;
                    logger.verbose("[%s] Sender '%s' created with sender options: %O", this._context.connectionId, this.name, options);
                    this._sender.setMaxListeners(1000);
                    // It is possible for someone to close the sender and then start it again.
                    // Thus make sure that the sender is present in the client cache.
                    if (!this._context.senders[this.name])
                        this._context.senders[this.name] = this;
                    yield this._ensureTokenRenewal();
                }
                else {
                    logger.verbose("[%s] The sender '%s' with address '%s' is open -> %s and is connecting " +
                        "-> %s. Hence not reconnecting.", this._context.connectionId, this.name, this.address, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                err = coreAmqp.translate(err);
                logger.warning("[%s] An error occurred while creating the sender %s", this._context.connectionId, this.name, err);
                logErrorStackTrace(err);
                throw err;
            }
        });
    }
    /**
     * Creates a new sender to the given event hub, and optionally to a given partition if it is
     * not present in the context or returns the one present in the context.
     * @ignore
     * @static
     * @param [partitionId] Partition ID to which it will send event data.
     * @returns
     */
    static create(context, partitionId) {
        const ehSender = new EventHubSender(context, partitionId);
        if (!context.senders[ehSender.name]) {
            context.senders[ehSender.name] = ehSender;
        }
        return context.senders[ehSender.name];
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * @internal
 * @ignore
 */
function getParentSpan(options) {
    return (options &&
        options.tracingOptions &&
        options.tracingOptions.spanOptions &&
        options.tracingOptions.spanOptions.parent);
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A producer responsible for sending events to an Event Hub.
 * To create a producer use the `createProducer()` method on your `EventHubClient`.
 * You can pass the below in the `options` when creating a producer.
 * - `partitionId`  : The identifier of the partition that the producer can be bound to.
 * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.
 * A simple usage can be `{ "maxRetries": 4 }`.
 *
 * If `partitionId` is specified when creating a producer, all event data sent using the producer
 * will be sent to the specified partition.
 * Otherwise, they are automatically routed to an available partition by the Event Hubs service.
 *
 * Automatic routing of partitions is recommended because:
 *  - The sending of events will be highly available.
 *  - The event data will be evenly distributed among all available partitions.
 *
 * @class
 * @internal
 * @ignore
 */
class EventHubProducer {
    /**
     * EventHubProducer should not be constructed using `new EventHubProduer()`
     * Use the `createProducer()` method on your `EventHubClient` instead.
     * @private
     * @constructor
     * @internal
     * @ignore
     */
    constructor(eventHubName, endpoint, context, options) {
        /**
         * @property Denotes if close() was called on this sender
         */
        this._isClosed = false;
        this._context = context;
        this._senderOptions = options || {};
        const partitionId = this._senderOptions.partitionId != undefined
            ? String(this._senderOptions.partitionId)
            : undefined;
        this._eventHubSender = EventHubSender.create(this._context, partitionId);
        this._eventHubName = eventHubName;
        this._endpoint = endpoint;
    }
    /**
     * @property Returns `true` if either the producer or the client that created it has been closed.
     * @readonly
     */
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    /**
     * Creates an instance of `EventDataBatch` to which one can add events until the maximum supported size is reached.
     * The batch can be passed to the `send()` method of the `EventHubProducer` to be sent to Azure Event Hubs.
     * @param options  A set of options to configure the behavior of the batch.
     * - `partitionKey`  : A value that is hashed to produce a partition assignment.
     * Not applicable if the `EventHubProducer` was created using a `partitionId`.
     * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.
     * - `abortSignal`   : A signal the request to cancel the send operation.
     * @returns Promise<EventDataBatch>
     */
    createBatch(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            if (!options) {
                options = {};
            }
            // throw an error if partition key and partition id are both defined
            if (typeof options.partitionKey === "string" &&
                typeof this._senderOptions.partitionId === "string") {
                const error = new Error("Creating a batch with partition key is not supported when using producers that were created using a partition id.");
                logger.warning("[%s] Creating a batch with partition key is not supported when using producers that were created using a partition id. %O", this._context.connectionId, error);
                logErrorStackTrace(error);
                throw error;
            }
            let maxMessageSize = yield this._eventHubSender.getMaxMessageSize({
                retryOptions: this._senderOptions.retryOptions,
                abortSignal: options.abortSignal
            });
            if (options.maxSizeInBytes) {
                if (options.maxSizeInBytes > maxMessageSize) {
                    const error = new Error(`Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`);
                    logger.warning(`[${this._context.connectionId}] Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link. ${error}`);
                    logErrorStackTrace(error);
                    throw error;
                }
                maxMessageSize = options.maxSizeInBytes;
            }
            return new EventDataBatchImpl(this._context, maxMessageSize, options.partitionKey, options.partitionId);
        });
    }
    /**
     * Send one or more of events to the associated Event Hub.
     *
     * @param eventData  An individual `EventData` object, or an array of `EventData` objects or an
     * instance of `EventDataBatch`.
     * @param options The set of options that can be specified to influence the way in which
     * events are sent to the associated Event Hub.
     * - `partitionKey` : A value that is hashed to produce a partition assignment.
     * Not applicable if the `EventHubProducer` was created using a `partitionId`.
     * - `abortSignal`  : A signal the request to cancel the send operation.
     *
     * @returns Promise<void>
     * @throws AbortError if the operation is cancelled via the abortSignal.
     * @throws MessagingError if an error is encountered while sending a message.
     * @throws TypeError if a required parameter is missing.
     * @throws Error if the underlying connection or sender has been closed.
     * @throws Error if a partitionKey is provided when the producer was created with a partitionId.
     * @throws Error if batch was created with partitionKey different than the one provided in the options.
     * Create a new producer using the EventHubClient createProducer method.
     */
    send(eventData, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "send", "eventData", eventData);
            if (Array.isArray(eventData) && eventData.length === 0) {
                logger.info(`[${this._context.connectionId}] Empty array was passed. No events to send.`);
                return;
            }
            if (isEventDataBatch(eventData) && eventData.count === 0) {
                logger.info(`[${this._context.connectionId}] Empty batch was passsed. No events to send.`);
                return;
            }
            if (!Array.isArray(eventData) && !isEventDataBatch(eventData)) {
                eventData = [eventData];
            }
            // link message span contexts
            let spanContextsToLink = [];
            if (Array.isArray(eventData)) {
                for (let i = 0; i < eventData.length; i++) {
                    const event = eventData[i];
                    if (!event.properties || !event.properties[TRACEPARENT_PROPERTY]) {
                        const messageSpan = createMessageSpan(getParentSpan(options));
                        // since these message spans are created from same context as the send span,
                        // these message spans don't need to be linked.
                        // replace the original event with the instrumented one
                        eventData[i] = instrumentEventData(eventData[i], messageSpan);
                        messageSpan.end();
                    }
                }
            }
            else if (isEventDataBatch(eventData)) {
                spanContextsToLink = eventData._messageSpanContexts;
            }
            const sendSpan = this._createSendSpan(getParentSpan(options), spanContextsToLink);
            try {
                const result = yield this._eventHubSender.send(eventData, Object.assign(Object.assign({}, this._senderOptions), options));
                sendSpan.setStatus({ code: types.CanonicalCode.OK });
                return result;
            }
            catch (err) {
                sendSpan.setStatus({
                    code: types.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                throw err;
            }
            finally {
                sendSpan.end();
            }
        });
    }
    /**
     * Closes the underlying AMQP sender link.
     * Once closed, the producer cannot be used for any further operations.
     * Use the `createProducer` function on the EventHubClient to instantiate a new EventHubProducer.
     *
     * @returns
     * @throws Error if the underlying connection encounters an error while closing.
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.connection && this._context.connection.isOpen() && this._eventHubSender) {
                    yield this._eventHubSender.close();
                    this._eventHubSender = undefined;
                }
                this._isClosed = true;
            }
            catch (err) {
                logger.warning("[%s] An error occurred while closing the Sender for %s: %O", this._context.connectionId, this._context.config.entityPath, err);
                logErrorStackTrace(err);
                throw err;
            }
        });
    }
    _createSendSpan(parentSpan, spanContextsToLink = []) {
        const links = spanContextsToLink.map((spanContext) => {
            return {
                spanContext
            };
        });
        const tracer = coreTracing.getTracer();
        const span = tracer.startSpan("Azure.EventHubs.send", {
            kind: types.SpanKind.CLIENT,
            parent: parentSpan,
            links
        });
        span.setAttribute("az.namespace", "Microsoft.EventHub");
        span.setAttribute("message_bus.destination", this._eventHubName);
        span.setAttribute("peer.address", this._endpoint);
        return span;
    }
    _throwIfSenderOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (this.isClosed) {
            const errorMessage = `The EventHubProducer for "${this._context.config.entityPath}" has been closed and can no longer be used. ` +
                `Please create a new EventHubProducer using the "createProducer" function on the EventHubClient.`;
            const error = new Error(errorMessage);
            logger.warning(`[${this._context.connectionId}] %O`, error);
            logErrorStackTrace(error);
            throw error;
        }
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * @ignore
 * Gets the expression to be set as the filter clause when creating the receiver
 * @return {string} filterExpression
 */
function getEventPositionFilter(eventPosition) {
    let result;
    // order of preference
    if (eventPosition.offset != undefined) {
        result = eventPosition.isInclusive
            ? `${coreAmqp.Constants.offsetAnnotation} >= '${eventPosition.offset}'`
            : `${coreAmqp.Constants.offsetAnnotation} > '${eventPosition.offset}'`;
    }
    else if (eventPosition.sequenceNumber != undefined) {
        result = eventPosition.isInclusive
            ? `${coreAmqp.Constants.sequenceNumberAnnotation} >= '${eventPosition.sequenceNumber}'`
            : `${coreAmqp.Constants.sequenceNumberAnnotation} > '${eventPosition.sequenceNumber}'`;
    }
    else if (eventPosition.enqueuedOn != undefined) {
        const time = eventPosition.enqueuedOn instanceof Date
            ? eventPosition.enqueuedOn.getTime()
            : eventPosition.enqueuedOn;
        result = `${coreAmqp.Constants.enqueuedTimeAnnotation} > '${time}'`;
    }
    if (!result) {
        throw coreAmqp.translate({
            condition: coreAmqp.ErrorNameConditionMapper.ArgumentError,
            description: "No starting position was set in the EventPosition."
        });
    }
    return result;
}
/**
 * Gets the `EventPosition` corresponding to the location of the the first event present in the partition.
 * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the
 * first event in the partition which has not expired due to the retention policy.
 */
const earliestEventPosition = {
    offset: -1
};
/**
 * Gets the `EventPosition` corresponding to the end of the partition.
 * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the
 * event that is enqueued right after the method call.
 * @returns EventPosition
 */
const latestEventPosition = {
    offset: "@latest"
};
/**
 * @ignore
 * @internal
 */
function validateEventPositions(position) {
    if (position == undefined) {
        return;
    }
    const keys = Object.keys(position);
    if (!keys.length) {
        throw new TypeError("Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.");
    }
    if (isEventPosition(position)) {
        validateEventPosition(position);
        return;
    }
    const positions = position;
    for (let i = 0; i < keys.length; i++) {
        if (Object.prototype.hasOwnProperty.call(positions, keys[i])) {
            validateEventPosition(positions[keys[i]]);
        }
    }
}
/**
 * Determines whether a position is an EventPosition.
 * Does not validate that the position is allowed.
 * @param position
 * @ignore
 * @internal
 */
function isEventPosition(position) {
    if (!position) {
        return false;
    }
    if (position.offset != undefined) {
        return true;
    }
    if (position.sequenceNumber != undefined) {
        return true;
    }
    if (position.enqueuedOn != undefined) {
        return true;
    }
    return false;
}
function validateEventPosition(position) {
    if (position == undefined) {
        return;
    }
    const offsetPresent = position.offset != undefined;
    const sequenceNumberPresent = position.sequenceNumber != undefined;
    const enqueuedOnPresent = position.enqueuedOn != undefined;
    if ((offsetPresent && sequenceNumberPresent) ||
        (offsetPresent && enqueuedOnPresent) ||
        (enqueuedOnPresent && sequenceNumberPresent)) {
        throw new TypeError("Invalid value for EventPosition found. Set only one of offset, sequenceNumber or enqueuedOn properties.");
    }
    if (!offsetPresent && !enqueuedOnPresent && !sequenceNumberPresent) {
        throw new TypeError("Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.");
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the EventHubReceiver that will receive event data from EventHub.
 * @class EventHubReceiver
 * @internal
 * @ignore
 */
class EventHubReceiver extends LinkEntity {
    /**
     * Instantiates a receiver that can be used to receive events over an AMQP receiver link in
     * either batching or streaming mode.
     * @ignore
     * @constructor
     * @param context        The connection context corresponding to the EventHubClient instance
     * @param consumerGroup  The consumer group from which the receiver should receive events from.
     * @param partitionId    The Partition ID from which to receive.
     * @param eventPosition  The position in the stream from where to start receiving events.
     * @param [options]      Receiver options.
     */
    constructor(context, consumerGroup, partitionId, eventPosition, options = {}) {
        super(context, {
            partitionId: partitionId,
            name: context.config.getReceiverAddress(partitionId, consumerGroup)
        });
        /**
         * @property _checkpoint The sequence number of the most recently received AMQP message.
         * @private
         */
        this._checkpoint = -1;
        /**
         * @property _internalQueue A queue of events that were received from the AMQP link but not consumed externally by `EventHubConsumer`
         * @private
         */
        this._internalQueue = [];
        /**
         * @property _usingInternalQueue Indicates that events in the internal queue are being processed to be consumed by `EventHubConsumer`
         * @private
         */
        this._usingInternalQueue = false;
        /**
         * @property _isReceivingMessages Indicates if messages are being received from this receiver.
         * @private
         */
        this._isReceivingMessages = false;
        /**
         * @property _isStreaming Indicated if messages are being received in streaming mode.
         * @private
         */
        this._isStreaming = false;
        this.consumerGroup = consumerGroup;
        this.address = context.config.getReceiverAddress(partitionId, this.consumerGroup);
        this.audience = context.config.getReceiverAudience(partitionId, this.consumerGroup);
        this.ownerLevel = options.ownerLevel;
        this.eventPosition = eventPosition;
        this.options = options;
        this.runtimeInfo = {};
    }
    /**
     * @property Returns sequenceNumber of the last event received from the service. This will not match the
     * last event received by `EventHubConsumer` when the `_internalQueue` is not empty
     * @readonly
     */
    get checkpoint() {
        return this._checkpoint;
    }
    /**
     * @property Indicates if messages are being received from this receiver.
     * @readonly
     */
    get isReceivingMessages() {
        return this._isReceivingMessages;
    }
    _onAmqpMessage(context) {
        if (!context.message) {
            return;
        }
        const data = fromAmqpMessage(context.message);
        const receivedEventData = {
            body: this._context.dataTransformer.decode(context.message.body),
            properties: data.properties,
            offset: data.offset,
            sequenceNumber: data.sequenceNumber,
            enqueuedTimeUtc: data.enqueuedTimeUtc,
            partitionKey: data.partitionKey,
            systemProperties: data.systemProperties
        };
        this._checkpoint = receivedEventData.sequenceNumber;
        if (this.options.trackLastEnqueuedEventProperties && data) {
            this.runtimeInfo.sequenceNumber = data.lastSequenceNumber;
            this.runtimeInfo.enqueuedOn = data.lastEnqueuedTime;
            this.runtimeInfo.offset = data.lastEnqueuedOffset;
            this.runtimeInfo.retrievedOn = data.retrievalTime;
        }
        // Add to internal queue if
        // - There are no listeners, we are probably getting events due to pending credits
        // - Or Events from internal queue are being processed, so add to it to ensure order of processing is retained
        if (!this._onMessage || this._usingInternalQueue) {
            this._internalQueue.push(receivedEventData);
        }
        else {
            if (this._isStreaming) {
                this._addCredit(1);
            }
            this._onMessage(receivedEventData);
        }
    }
    _onAmqpError(context) {
        const rheaReceiver = this._receiver || context.receiver;
        const amqpError = rheaReceiver && rheaReceiver.error;
        logger.verbose("[%s] 'receiver_error' event occurred on the receiver '%s' with address '%s'. " +
            "The associated error is: %O", this._context.connectionId, this.name, this.address, amqpError);
        if (this._onError && amqpError) {
            const error = coreAmqp.translate(amqpError);
            logErrorStackTrace(error);
            this._onError(error);
        }
    }
    _onAmqpSessionError(context) {
        const sessionError = context.session && context.session.error;
        logger.verbose("[%s] 'session_error' event occurred on the session of receiver '%s' with address '%s'. " +
            "The associated error is: %O", this._context.connectionId, this.name, this.address, sessionError);
        if (this._onError && sessionError) {
            const error = coreAmqp.translate(sessionError);
            logErrorStackTrace(error);
            this._onError(error);
        }
    }
    _onAmqpClose(context) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const rheaReceiver = this._receiver || context.receiver;
            logger.verbose("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s'. " +
                "Value for isItselfClosed on the receiver is: '%s' " +
                "Value for isConnecting on the session is: '%s'.", this._context.connectionId, this.name, this.address, rheaReceiver ? rheaReceiver.isItselfClosed().toString() : undefined, this.isConnecting);
            if (rheaReceiver && !this.isConnecting) {
                // Call close to clean up timers & other resources
                yield rheaReceiver.close().catch((err) => {
                    logger.verbose("[%s] Error when closing receiver [%s] after 'receiver_close' event: %O", this._context.connectionId, this.name, err);
                });
            }
        });
    }
    _onAmqpSessionClose(context) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const rheaReceiver = this._receiver || context.receiver;
            logger.verbose("[%s] 'session_close' event occurred on the session of receiver '%s' with address '%s'. " +
                "Value for isSessionItselfClosed on the session is: '%s' " +
                "Value for isConnecting on the session is: '%s'.", this._context.connectionId, this.name, this.address, rheaReceiver ? rheaReceiver.isSessionItselfClosed().toString() : undefined, this.isConnecting);
            if (rheaReceiver && !this.isConnecting) {
                // Call close to clean up timers & other resources
                yield rheaReceiver.close().catch((err) => {
                    logger.verbose("[%s] Error when closing receiver [%s] after 'session_close' event: %O", this._context.connectionId, this.name, err);
                });
            }
        });
    }
    abort() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const desc = `[${this._context.connectionId}] The receive operation on the Receiver "${this.name}" with ` +
                `address "${this.address}" has been cancelled by the user.`;
            // Cancellation is user-intended, so log to info instead of warning.
            logger.info(desc);
            if (this._onError) {
                const error = new abortController.AbortError("The receive operation has been cancelled by the user.");
                this._onError(error);
            }
            this.clearHandlers();
            yield this.close();
        });
    }
    /**
     * Clears the user-provided handlers and updates the receiving messages flag.
     * @ignore
     */
    clearHandlers() {
        if (this._abortSignal && this._onAbort) {
            this._abortSignal.removeEventListener("abort", this._onAbort);
        }
        this._abortSignal = undefined;
        this._onAbort = undefined;
        this._onError = undefined;
        this._onMessage = undefined;
        this._isReceivingMessages = false;
        this._isStreaming = false;
    }
    /**
     * Closes the underlying AMQP receiver.
     * @ignore
     * @returns
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this.clearHandlers();
            if (!this._receiver) {
                return;
            }
            const receiverLink = this._receiver;
            this._deleteFromCache();
            yield this._closeLink(receiverLink);
        });
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     * @ignore
     * @returns boolean
     */
    isOpen() {
        const result = Boolean(this._receiver && this._receiver.isOpen());
        logger.verbose("[%s] Receiver '%s' with address '%s' is open? -> %s", this._context.connectionId, this.name, this.address, result);
        return result;
    }
    /**
     * Registers the user's onMessage and onError handlers.
     * Sends buffered events from the queue before adding additional credits to the AMQP link.
     * @ignore
     */
    registerHandlers(onMessage, onError, maximumCreditCount, isStreaming, abortSignal, onAbort) {
        this._abortSignal = abortSignal;
        this._onAbort = onAbort;
        this._onError = onError;
        this._onMessage = onMessage;
        this._isStreaming = isStreaming;
        // indicate that messages are being received.
        this._isReceivingMessages = true;
        this._useInternalQueue(onMessage, abortSignal)
            .then((processedEventCount) => tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._onMessage !== onMessage) {
                // the original handler has been removed, so no further action required.
                return;
            }
            // check if more messages are required
            if (!isStreaming && maximumCreditCount - processedEventCount <= 0) {
                return;
            }
            if (!this.isOpen()) {
                try {
                    yield this.initialize();
                    if (abortSignal && abortSignal.aborted) {
                        yield this.abort();
                    }
                }
                catch (err) {
                    return this._onError === onError && onError(err);
                }
            }
            else {
                logger.verbose("[%s] Receiver link already present, hence reusing it.", this._context.connectionId);
            }
            // add credits
            const existingCredits = this._receiver ? this._receiver.credit : 0;
            const prcoessedEventCountToExclude = isStreaming ? 0 : processedEventCount;
            const creditsToAdd = Math.max(maximumCreditCount - (existingCredits + prcoessedEventCountToExclude), 0);
            this._addCredit(creditsToAdd);
        }))
            .catch((err) => {
            // something really unexpected happened, so attempt to call user's error handler
            if (this._onError === onError) {
                onError(err);
            }
        });
    }
    _addCredit(credit) {
        if (this._receiver) {
            this._receiver.addCredit(credit);
        }
    }
    _deleteFromCache() {
        this._receiver = undefined;
        delete this._context.receivers[this.name];
        logger.verbose("[%s] Deleted the receiver '%s' from the client cache.", this._context.connectionId, this.name);
    }
    _useInternalQueue(onMessage, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let processedMessagesCount = 0;
            // allow the event loop to process any blocking code outside
            // this code path before sending any events.
            yield coreAmqp.delay(0);
            this._usingInternalQueue = true;
            while (this._internalQueue.length) {
                if (!this._onMessage) {
                    break;
                }
                if (abortSignal && abortSignal.aborted) {
                    break;
                }
                // These will not be equal if clearHandlers and registerHandlers were called
                // in the same tick of the event loop. If onMessage isn't the currently active
                // handler, it should stop getting messages from the queue.
                if (this._onMessage !== onMessage) {
                    break;
                }
                const eventData = this._internalQueue.splice(0, 1)[0];
                processedMessagesCount++;
                onMessage(eventData);
                // allow the event loop to process any blocking code outside
                // this code path before sending the next event.
                yield coreAmqp.delay(0);
            }
            this._usingInternalQueue = false;
            return processedMessagesCount;
        });
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     * @ignore
     * @returns
     */
    initialize() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.isOpen() && !this.isConnecting) {
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    const receiverOptions = {
                        onClose: (context) => this._onAmqpClose(context),
                        onError: (context) => this._onAmqpError(context),
                        onMessage: (context) => this._onAmqpMessage(context),
                        onSessionClose: (context) => this._onAmqpSessionClose(context),
                        onSessionError: (context) => this._onAmqpSessionError(context)
                    };
                    if (this.checkpoint > -1) {
                        receiverOptions.eventPosition = { sequenceNumber: this.checkpoint };
                    }
                    const options = this._createReceiverOptions(receiverOptions);
                    logger.verbose("[%s] Trying to create receiver '%s' with options %O", this._context.connectionId, this.name, options);
                    this._receiver = yield this._context.connection.createReceiver(options);
                    this.isConnecting = false;
                    logger.verbose("[%s] Receiver '%s' created with receiver options: %O", this._context.connectionId, this.name, options);
                    // store the underlying link in a cache
                    this._context.receivers[this.name] = this;
                    yield this._ensureTokenRenewal();
                }
                else {
                    logger.verbose("[%s] The receiver '%s' with address '%s' is open -> %s and is connecting " +
                        "-> %s. Hence not reconnecting.", this._context.connectionId, this.name, this.address, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                const error = coreAmqp.translate(err);
                logger.warning("[%s] An error occured while creating the receiver '%s': %O", this._context.connectionId, this.name, error);
                logErrorStackTrace(err);
                throw error;
            }
        });
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     * @ignore
     */
    _createReceiverOptions(options) {
        if (options.newName)
            this.name = v4_1();
        const rcvrOptions = {
            name: this.name,
            autoaccept: true,
            source: {
                address: this.address
            },
            credit_window: 0,
            onMessage: options.onMessage || ((context) => this._onAmqpMessage(context)),
            onError: options.onError || ((context) => this._onAmqpError(context)),
            onClose: options.onClose || ((context) => this._onAmqpClose(context)),
            onSessionError: options.onSessionError || ((context) => this._onAmqpSessionError(context)),
            onSessionClose: options.onSessionClose || ((context) => this._onAmqpSessionClose(context))
        };
        if (typeof this.ownerLevel === "number") {
            rcvrOptions.properties = {
                [coreAmqp.Constants.attachEpoch]: rheaPromise.types.wrap_long(this.ownerLevel)
            };
        }
        if (this.options.trackLastEnqueuedEventProperties) {
            rcvrOptions.desired_capabilities = coreAmqp.Constants.enableReceiverRuntimeMetricName;
        }
        const eventPosition = options.eventPosition || this.eventPosition;
        if (eventPosition) {
            // Set filter on the receiver if event position is specified.
            const filterClause = getEventPositionFilter(eventPosition);
            if (filterClause) {
                rcvrOptions.source.filter = {
                    "apache.org:selector-filter:string": rheaPromise.types.wrap_described(filterClause, 0x468c00000004)
                };
            }
        }
        return rcvrOptions;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the receive handler object that is returned from the receive() method with handlers.
 * The ReceiveHandler is used to stop receiving more messages.
 * @class ReceiveHandler
 * @ignore
 * @internal
 */
class ReceiveHandler {
    /**
     * Creates an instance of the ReceiveHandler.
     * @constructor
     * @internal
     * @param receiver The underlying EventHubReceiver.
     */
    constructor(receiver) {
        this._receiver = receiver;
    }
    /**
     * @property The partitionId from which the handler is receiving events.
     * @readonly
     */
    get partitionId() {
        return this._receiver ? this._receiver.partitionId : undefined;
    }
    /**
     * @property The consumer group from which the handler is receiving events.
     * @readonly
     */
    get consumerGroup() {
        return this._receiver ? this._receiver.consumerGroup : undefined;
    }
    /**
     * @property Indicates whether the receiver is connected/open.
     * `true` - is open; `false` otherwise.
     * @readonly
     */
    get isReceiverOpen() {
        return this._receiver ? this._receiver.isOpen() : false;
    }
    /**
     * Stops the underlying EventHubReceiver from receiving more messages.
     * @returns Promise<void>
     * @throws Error if the underlying connection encounters an error while closing.
     */
    stop() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._receiver) {
                try {
                    yield this._receiver.close();
                }
                catch (err) {
                    logger.warning("An error occurred while stopping the receiver '%s' with address '%s': %O", this._receiver.name, this._receiver.address, err);
                    logErrorStackTrace(err);
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A consumer is responsible for reading `EventData` from a specific Event Hub partition
 * in the context of a specific consumer group.
 * To create a consumer use the `createConsumer()` method on your `EventHubClient`.
 *
 * You can pass the below in the `options` when creating a consumer.
 * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other
 * consumers to fail if their `ownerLevel` is lower or doesn't exist.
 * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.
 *
 * Multiple consumers are allowed on the same partition in a consumer group.
 * If there is a need to have an exclusive consumer for a partition in a consumer group,
 * then specify the `ownerLevel` in the `options`.
 * Exclusive consumers were previously referred to as "Epoch Receivers".
 *
 * The consumer can be used to receive messages in a batch using `receiveBatch()` or by registering handlers
 * by using `receive()` or via an async iterable got by using `getEventIterator()`
 * @class
 * @ignore
 * @internal
 */
class EventHubConsumer {
    /**
     * EventHubConsumer should not be constructed using `new EventHubConsumer()`
     * Use the `createConsumer()` method on your `EventHubClient` instead.
     * @private
     * @constructor
     * @internal
     * @ignore
     */
    constructor(context, consumerGroup, partitionId, eventPosition, options) {
        /**
         * @property Denotes if close() was called on this receiver
         */
        this._isClosed = false;
        this._context = context;
        this._consumerGroup = consumerGroup;
        this._partitionId = partitionId;
        this._lastEnqueuedEventProperties = {};
        this._receiverOptions = options || {};
        this._retryOptions = this._receiverOptions.retryOptions || {};
        this._baseConsumer = new EventHubReceiver(context, consumerGroup, partitionId, eventPosition, options);
    }
    /**
     * @property The last enqueued event information. This property will only
     * be enabled when `trackLastEnqueuedEventProperties` option is set to true in the
     * `client.createConsumer()` method.
     * @readonly
     */
    get lastEnqueuedEventProperties() {
        return this._lastEnqueuedEventProperties;
    }
    /**
     * @property Returns `true` if the consumer is closed. This can happen either because the consumer
     * itself has been closed or the client that created it has been closed.
     * @readonly
     */
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    /**
     * @property The identifier of the Event Hub partition that this consumer is associated with.
     * Events will be read only from this partition.
     * @readonly
     */
    get partitionId() {
        return this._partitionId;
    }
    /**
     * @property The name of the consumer group that this consumer is associated with.
     * Events will be read only in the context of this group.
     * @readonly
     */
    get consumerGroup() {
        return this._consumerGroup;
    }
    /**
     * @property The owner level associated with an exclusive consumer; for a non-exclusive consumer, this value will be null or undefined.
     *
     * When provided, the owner level indicates that a consumer is intended to be the exclusive receiver of events for the
     * requested partition and the associated consumer group.
     * When multiple consumers exist for the same partition/consumer group pair, then the ones with lower or no
     * `ownerLevel` will get a `ReceiverDisconnectedError` during the next attempted receive operation.
     * @readonly
     */
    get ownerLevel() {
        return this._receiverOptions.ownerLevel;
    }
    /**
     * Indicates whether the consumer is currently receiving messages or not.
     * When this returns true, new `receive()` or `receiveBatch()` calls cannot be made.
     */
    get isReceivingMessages() {
        return Boolean(this._baseConsumer && this._baseConsumer.isReceivingMessages);
    }
    /**
     * Starts receiving events from the service and calls the user provided message handler for each event.
     * Returns an object that can be used to query the state of the receiver and to stop receiving events as well.
     *
     * @param onMessage The message handler to receive event data objects.
     * @param onError The error handler for errora that can occur when receiving events.
     * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     * @returns ReceiveHandler - An object that provides a mechanism to stop receiving more messages.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     * @throws TypeError if a required parameter is missing.
     * @throws Error if the underlying connection or receiver has been closed.
     * Create a new EventHubConsumer using the EventHubClient createConsumer method.
     * @throws Error if the receiver is already receiving messages.
     */
    receive(onMessage, onError, abortSignal) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        const baseConsumer = this._baseConsumer;
        if (typeof onMessage !== "function") {
            throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
        }
        if (typeof onError !== "function") {
            throw new TypeError("The parameter 'onError' must be of type 'function'.");
        }
        // return immediately if the abortSignal is already aborted.
        if (abortSignal && abortSignal.aborted) {
            onError(new abortController.AbortError("The receive operation has been cancelled by the user."));
            // close this receiver when user triggers a cancellation.
            this.close().catch(() => { }); // no-op close error handler
            return new ReceiveHandler(baseConsumer);
        }
        const wrappedOnError = (error) => {
            // ignore retryable errors
            if (error.retryable) {
                return;
            }
            logger.warning("[%s] Since the error is not retryable, we let the user know about it by calling the user's error handler.", this._context.connectionId);
            logErrorStackTrace(error);
            if (error.name === "AbortError") {
                // close this receiver when user triggers a cancellation.
                this.close().catch(() => { }); // no-op close error handler
            }
            onError(error);
        };
        const onAbort = () => {
            if (this._baseConsumer) {
                this._baseConsumer.abort();
            }
        };
        baseConsumer.registerHandlers(onMessage, wrappedOnError, coreAmqp.Constants.defaultPrefetchCount, true, abortSignal, onAbort);
        if (this._receiverOptions.trackLastEnqueuedEventProperties &&
            this._baseConsumer &&
            this._baseConsumer.runtimeInfo) {
            this._lastEnqueuedEventProperties = this._baseConsumer.runtimeInfo;
        }
        return new ReceiveHandler(baseConsumer);
    }
    /**
     * Returns a promise that resolves to an array of events received from the service.
     *
     * @param maxMessageCount The maximum number of messages to receive.
     * @param maxWaitTimeInSeconds The maximum amount of time to wait to build up the requested message count;
     * If not provided, it defaults to 60 seconds.
     * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @returns Promise<ReceivedEventData[]>.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     * @throws MessagingError if an error is encountered while receiving a message.
     * @throws Error if the underlying connection or receiver has been closed.
     * Create a new EventHubConsumer using the EventHubClient createConsumer method.
     * @throws Error if the receiver is already receiving messages.
     */
    receiveBatch(maxMessageCount, maxWaitTimeInSeconds = 60, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            this._throwIfAlreadyReceiving();
            // store events across multiple retries
            const receivedEvents = [];
            const retrieveEvents = () => {
                return new Promise((resolve, reject) => tslib.__awaiter(this, void 0, void 0, function* () {
                    // if this consumer was closed, _baseConsumer might be undefined.
                    // resolve the operation's promise with the events collected thus far in case
                    // the promise hasn't already been resolved.
                    if (!this._baseConsumer) {
                        return resolve(receivedEvents);
                    }
                    let timer;
                    const logOnAbort = () => {
                        const baseConsumer = this._baseConsumer;
                        const name = baseConsumer && baseConsumer.name;
                        const address = baseConsumer && baseConsumer.address;
                        const desc = `[${this._context.connectionId}] The request operation on the Receiver "${name}" with ` +
                            `address "${address}" has been cancelled by the user.`;
                        // Cancellation is intentional so logging to 'info'.
                        logger.info(desc);
                    };
                    const rejectOnAbort = () => tslib.__awaiter(this, void 0, void 0, function* () {
                        logOnAbort();
                        try {
                            yield this.close();
                        }
                        finally {
                            return reject(new abortController.AbortError("The receive operation has been cancelled by the user."));
                        }
                    });
                    // operation has been cancelled, so exit immediately
                    if (abortSignal && abortSignal.aborted) {
                        return yield rejectOnAbort();
                    }
                    // updates the prefetch count so that the baseConsumer adds
                    // the correct number of credits to receive the same number of events.
                    const prefetchCount = Math.max(maxMessageCount - receivedEvents.length, 0);
                    if (prefetchCount === 0) {
                        return resolve(receivedEvents);
                    }
                    logger.verbose("[%s] Receiver '%s', setting the prefetch count to %d.", this._context.connectionId, this._baseConsumer && this._baseConsumer.name, prefetchCount);
                    const cleanUpBeforeReturn = () => {
                        if (this._baseConsumer) {
                            this._baseConsumer.clearHandlers();
                        }
                        clearTimeout(timer);
                    };
                    const onAbort = () => {
                        clearTimeout(timer);
                        rejectOnAbort();
                    };
                    this._baseConsumer.registerHandlers((eventData) => {
                        receivedEvents.push(eventData);
                        if (this._receiverOptions.trackLastEnqueuedEventProperties &&
                            this._baseConsumer &&
                            this._baseConsumer.runtimeInfo) {
                            this._lastEnqueuedEventProperties = this._baseConsumer.runtimeInfo;
                        }
                        // resolve the operation's promise after the requested
                        // number of events are received.
                        if (receivedEvents.length === maxMessageCount) {
                            logger.info("[%s] Batching Receiver '%s', %d messages received within %d seconds.", this._context.connectionId, this._baseConsumer && this._baseConsumer.name, receivedEvents.length, maxWaitTimeInSeconds);
                            cleanUpBeforeReturn();
                            resolve(receivedEvents);
                        }
                    }, (err) => {
                        cleanUpBeforeReturn();
                        if (err.name === "AbortError") {
                            rejectOnAbort();
                        }
                        else {
                            reject(err);
                        }
                    }, maxMessageCount - receivedEvents.length, false, abortSignal, onAbort);
                    const addTimeout = () => {
                        const msg = "[%s] Setting the wait timer for %d seconds for receiver '%s'.";
                        logger.verbose(msg, this._context.connectionId, maxWaitTimeInSeconds, this._baseConsumer && this._baseConsumer.name);
                        // resolve the operation's promise after the requested
                        // max number of seconds have passed.
                        timer = setTimeout(() => {
                            logger.info("[%s] Batching Receiver '%s', %d messages received when max wait time in seconds %d is over.", this._context.connectionId, this._baseConsumer && this._baseConsumer.name, receivedEvents.length, maxWaitTimeInSeconds);
                            cleanUpBeforeReturn();
                            resolve(receivedEvents);
                        }, maxWaitTimeInSeconds * 1000);
                    };
                    addTimeout();
                    if (abortSignal && !abortSignal.aborted) {
                        abortSignal.addEventListener("abort", onAbort);
                    }
                }));
            };
            const retryOptions = this._retryOptions;
            const config = {
                connectionHost: this._context.config.host,
                connectionId: this._context.connectionId,
                operation: retrieveEvents,
                operationType: coreAmqp.RetryOperationType.receiveMessage,
                abortSignal: abortSignal,
                retryOptions: retryOptions
            };
            return coreAmqp.retry(config);
        });
    }
    /**
     * Closes the underlying AMQP receiver link.
     * Once closed, the consumer cannot be used for any further operations.
     * Use the `createConsumer` function on the EventHubClient to instantiate
     * a new EventHubConsumer.
     *
     * @returns
     * @throws Error if the underlying connection encounters an error while closing.
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.connection && this._context.connection.isOpen()) {
                    if (this._baseConsumer) {
                        yield this._baseConsumer.close();
                        this._baseConsumer = void 0;
                    }
                }
            }
            catch (err) {
                throw err;
            }
            finally {
                this._isClosed = true;
            }
        });
    }
    _throwIfAlreadyReceiving() {
        if (this.isReceivingMessages) {
            const errorMessage = `The EventHubConsumer for "${this._context.config.entityPath}" is already receiving messages.`;
            const error = new Error(errorMessage);
            logger.warning(`[${this._context.connectionId}] %O`, error);
            logErrorStackTrace(error);
            throw error;
        }
    }
    _throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (!this._baseConsumer || this.isClosed) {
            const errorMessage = `The EventHubConsumer for "${this._context.config.entityPath}" has been closed and can no longer be used. ` +
                `Please create a new EventHubConsumer using the "createConsumer" function on the EventHubClient.`;
            const error = new Error(errorMessage);
            logger.error(`[${this._context.connectionId}] %O`, error);
            logErrorStackTrace(error);
            throw error;
        }
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @class
 * The client is the main point of interaction with Azure Event Hubs service.
 * It offers connection to a specific Event Hub within the Event Hubs namespace along with
 * operations for sending event data, receiving events, and inspecting the connected Event Hub.
 *
 * There are multiple ways to create an `EventHubClient`
 * - Use the connection string from the SAS policy created for your Event Hub instance.
 * - Use the connection string from the SAS policy created for your Event Hub namespace,
 * and the name of the Event Hub instance
 * - Use the fully qualified domain name of your Event Hub namespace like `<yournamespace>.servicebus.windows.net`,
 * and a credentials object.
 *
 * @internal
 * @ignore
 */
class EventHubClient {
    constructor(hostOrConnectionString, eventHubNameOrOptions, credentialOrOptions, options) {
        let connectionString;
        let config;
        let credential;
        hostOrConnectionString = String(hostOrConnectionString);
        if (!coreAmqp.isTokenCredential(credentialOrOptions)) {
            const parsedCS = coreAmqp.parseConnectionString(hostOrConnectionString);
            if (!(parsedCS.EntityPath ||
                (typeof eventHubNameOrOptions === "string" && eventHubNameOrOptions))) {
                throw new TypeError(`Either provide "eventHubName" or the "connectionString": "${hostOrConnectionString}", ` +
                    `must contain "EntityPath=<your-event-hub-name>".`);
            }
            if (parsedCS.EntityPath &&
                typeof eventHubNameOrOptions === "string" &&
                eventHubNameOrOptions &&
                parsedCS.EntityPath !== eventHubNameOrOptions) {
                throw new TypeError(`The entity path "${parsedCS.EntityPath}" in connectionString: "${hostOrConnectionString}" ` +
                    `doesn't match with eventHubName: "${eventHubNameOrOptions}".`);
            }
            connectionString = hostOrConnectionString;
            if (typeof eventHubNameOrOptions !== "string") {
                // connectionstring and/or options were passed to constructor
                config = coreAmqp.EventHubConnectionConfig.create(connectionString);
                options = eventHubNameOrOptions;
            }
            else {
                // connectionstring, eventHubName and/or options were passed to constructor
                const eventHubName = eventHubNameOrOptions;
                config = coreAmqp.EventHubConnectionConfig.create(connectionString, eventHubName);
                options = credentialOrOptions;
            }
            // Since connectionstring was passed, create a SharedKeyCredential
            credential = new coreAmqp.SharedKeyCredential(config.sharedAccessKeyName, config.sharedAccessKey);
        }
        else {
            // host, eventHubName, a TokenCredential and/or options were passed to constructor
            const eventHubName = eventHubNameOrOptions;
            let host = hostOrConnectionString;
            credential = credentialOrOptions;
            if (!eventHubName) {
                throw new TypeError(`"eventHubName" is missing`);
            }
            if (!host.endsWith("/"))
                host += "/";
            connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;EntityPath=${eventHubName}`;
            config = coreAmqp.EventHubConnectionConfig.create(connectionString);
        }
        coreAmqp.ConnectionConfig.validate(config);
        this.endpoint = config.endpoint;
        this._clientOptions = options || {};
        this._context = ConnectionContext.create(config, credential, this._clientOptions);
    }
    /**
     * @property
     * @readonly
     * The name of the Event Hub instance for which this client is created.
     */
    get eventHubName() {
        return this._context.config.entityPath;
    }
    /**
     * @property
     * @readonly
     * The fully qualified Event Hubs namespace for which this client is created. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net.
     */
    get fullyQualifiedNamespace() {
        return this._context.config.host;
    }
    _createClientSpan(operationName, parentSpan, internal = false) {
        const tracer = coreTracing.getTracer();
        const span = tracer.startSpan(`Azure.EventHubs.${operationName}`, {
            kind: internal ? types.SpanKind.INTERNAL : types.SpanKind.CLIENT,
            parent: parentSpan
        });
        span.setAttribute("az.namespace", "Microsoft.EventHub");
        span.setAttribute("message_bus.destination", this.eventHubName);
        span.setAttribute("peer.address", this.endpoint);
        return span;
    }
    /**
     * Closes the AMQP connection to the Event Hub instance,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns Promise<void>
     * @throws Error if the underlying connection encounters an error while closing.
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.connection.isOpen()) {
                    // Close all the senders.
                    for (const senderName of Object.keys(this._context.senders)) {
                        yield this._context.senders[senderName].close();
                    }
                    // Close all the receivers.
                    for (const receiverName of Object.keys(this._context.receivers)) {
                        yield this._context.receivers[receiverName].close();
                    }
                    // Close the cbs session;
                    yield this._context.cbsSession.close();
                    // Close the management session
                    yield this._context.managementSession.close();
                    yield this._context.connection.close();
                    this._context.wasConnectionCloseCalled = true;
                    logger.info("Closed the amqp connection '%s' on the client.", this._context.connectionId);
                }
            }
            catch (err) {
                err = err instanceof Error ? err : JSON.stringify(err);
                logger.warning(`An error occurred while closing the connection "${this._context.connectionId}":\n${err}`);
                logErrorStackTrace(err);
                throw err;
            }
        });
    }
    /**
     * Creates an Event Hub producer that can send events to the Event Hub.
     * If `partitionId` is specified in the `options`, all event data sent using the producer
     * will be sent to the specified partition.
     * Otherwise, they are automatically routed to an available partition by the Event Hubs service.
     *
     * Automatic routing of partitions is recommended because:
     *  - The sending of events will be highly available.
     *  - The event data will be evenly distributed among all available partitions.
     *
     * @param options The set of options to apply when creating the producer.
     * - `partitionId`  : The identifier of the partition that the producer can be bound to.
     * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.
     * A simple usage can be `{ "maxRetries": 4 }`.
     *
     * @throws Error if the underlying connection has been closed, create a new EventHubClient.
     * @returns EventHubProducer
     */
    createProducer(options) {
        if (!options) {
            options = {};
        }
        if (!options.retryOptions) {
            options.retryOptions = this._clientOptions.retryOptions;
        }
        throwErrorIfConnectionClosed(this._context);
        return new EventHubProducer(this.eventHubName, this.endpoint, this._context, options);
    }
    /**
     * Creates an Event Hub consumer that can receive events from a specific Event Hub partition,
     * in the context of a specific consumer group.
     *
     * Multiple consumers are allowed on the same partition in a consumer group.
     * If there is a need to have an exclusive consumer for a partition in a consumer group,
     * then specify the `ownerLevel` in the `options`.
     * Exclusive consumers were previously referred to as "Epoch Receivers".
     *
     * @param consumerGroup The name of the consumer group this consumer is associated with.
     * Events are read in the context of this group. You can get this information from Azure portal.
     * @param partitionId The identifier of the Event Hub partition from which events will be received.
     * You can get identifiers for all partitions by using the `getPartitionProperties` method on the `EventHubClient`.
     * @param eventPosition The position within the partition where the consumer should begin reading events.
     * @param options The set of options to apply when creating the consumer.
     * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other
     * consumers to fail if their `ownerLevel` is lower or doesn't exist.
     * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.
     * A simple usage can be `{ "maxRetries": 4 }`.
     *
     * @throws Error if the underlying connection has been closed, create a new EventHubClient.
     * @throws TypeError if a required parameter is missing.
     */
    createConsumer(consumerGroup, partitionId, eventPosition, options) {
        if (!options) {
            options = {};
        }
        if (!options.retryOptions) {
            options.retryOptions = this._clientOptions.retryOptions;
        }
        throwErrorIfConnectionClosed(this._context);
        throwTypeErrorIfParameterMissing(this._context.connectionId, "createConsumer", "consumerGroup", consumerGroup);
        throwTypeErrorIfParameterMissing(this._context.connectionId, "createConsumer", "partitionId", partitionId);
        throwTypeErrorIfParameterMissing(this._context.connectionId, "createConsumer", "eventPosition", eventPosition);
        partitionId = String(partitionId);
        return new EventHubConsumer(this._context, consumerGroup, partitionId, eventPosition, options);
    }
    /**
     * Provides the Event Hub runtime information.
     * @param [options] The set of options to apply to the operation call.
     * @returns A promise that resolves with EventHubProperties.
     * @throws Error if the underlying connection has been closed, create a new EventHubClient.
     * @throws AbortError if the operation is cancelled via the abortSignal3.
     */
    getProperties(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            const clientSpan = this._createClientSpan("getEventHubProperties", getParentSpan(options));
            try {
                const result = yield this._context.managementSession.getHubRuntimeInformation({
                    retryOptions: this._clientOptions.retryOptions,
                    abortSignal: options.abortSignal
                });
                clientSpan.setStatus({ code: types.CanonicalCode.OK });
                return result;
            }
            catch (err) {
                clientSpan.setStatus({
                    code: types.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                logger.warning("An error occurred while getting the hub runtime information: %O", err);
                logErrorStackTrace(err);
                throw err;
            }
            finally {
                clientSpan.end();
            }
        });
    }
    /**
     * Provides an array of partitionIds.
     * @param [options] The set of options to apply to the operation call.
     * @returns A promise that resolves with an Array of strings.
     * @throws Error if the underlying connection has been closed, create a new EventHubClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getPartitionIds(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            const clientSpan = this._createClientSpan("getPartitionIds", getParentSpan(options), true);
            try {
                const runtimeInfo = yield this.getProperties(Object.assign(Object.assign({}, options), { tracingOptions: {
                        spanOptions: {
                            parent: clientSpan
                        }
                    } }));
                clientSpan.setStatus({ code: types.CanonicalCode.OK });
                return runtimeInfo.partitionIds;
            }
            catch (err) {
                clientSpan.setStatus({
                    code: types.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                logger.warning("An error occurred while getting the partition ids: %O", err);
                logErrorStackTrace(err);
                throw err;
            }
            finally {
                clientSpan.end();
            }
        });
    }
    /**
     * Provides information about the specified partition.
     * @param partitionId Partition ID for which partition information is required.
     * @param [options] The set of options to apply to the operation call.
     * @returns A promise that resoloves with PartitionProperties.
     * @throws Error if the underlying connection has been closed, create a new EventHubClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getPartitionProperties(partitionId, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            throwTypeErrorIfParameterMissing(this._context.connectionId, "getPartitionProperties", "partitionId", partitionId);
            partitionId = String(partitionId);
            const clientSpan = this._createClientSpan("getPartitionProperties", getParentSpan(options));
            try {
                const result = yield this._context.managementSession.getPartitionProperties(partitionId, {
                    retryOptions: this._clientOptions.retryOptions,
                    abortSignal: options.abortSignal
                });
                clientSpan.setStatus({ code: types.CanonicalCode.OK });
                return result;
            }
            catch (err) {
                clientSpan.setStatus({
                    code: types.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                logger.warning("An error occurred while getting the partition information: %O", err);
                logErrorStackTrace(err);
                throw err;
            }
            finally {
                clientSpan.end();
            }
        });
    }
}
/**
 * @property
 * The name of the default consumer group in the Event Hubs service.
 */
EventHubClient.defaultConsumerGroupName = coreAmqp.Constants.defaultConsumerGroup;

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The `EventProcessor` relies on a `CheckpointStore` to store checkpoints and handle partition
 * ownerships. `InMemoryCheckpointStore` is simple partition manager that stores checkpoints and
 * partition ownerships in memory of your program.
 *
 * You can use the `InMemoryCheckpointStore` to get started with using the `EventProcessor`.
 * But in production, you should choose an implementation of the `CheckpointStore` interface that will
 * store the checkpoints and partition ownerships to a durable store instead.
 *
 * @class
 * @internal
 * @ignore
 */
class InMemoryCheckpointStore {
    constructor() {
        this._partitionOwnershipMap = new Map();
        this._committedCheckpoints = new Map();
    }
    /**
     * Get the list of all existing partition ownership from the underlying data store. Could return empty
     * results if there are is no existing ownership information.
     *
     * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net.
     * @param eventHubName The event hub name.
     * @param consumerGroup The consumer group name.
     * @return Partition ownership details of all the partitions that have/had an owner..
     */
    listOwnership(fullyQualifiedNamespace, eventHubName, consumerGroup) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const ownerships = [];
            for (const value of this._partitionOwnershipMap.values()) {
                ownerships.push(Object.assign({}, value));
            }
            return ownerships;
        });
    }
    /**
     * Claim ownership of a list of partitions. This will return the list of partitions that were owned
     * successfully.
     *
     * @param partitionOwnership The list of partition ownership this instance is claiming to own.
     * @return A list partitions this instance successfully claimed ownership.
     */
    claimOwnership(partitionOwnership) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const claimedOwnerships = [];
            for (const ownership of partitionOwnership) {
                if (!this._partitionOwnershipMap.has(ownership.partitionId) ||
                    this._partitionOwnershipMap.get(ownership.partitionId).etag === ownership.etag) {
                    var date = new Date();
                    const newOwnership = Object.assign(Object.assign({}, ownership), { etag: rheaPromise.generate_uuid(), lastModifiedTimeInMs: date.getTime() });
                    this._partitionOwnershipMap.set(newOwnership.partitionId, newOwnership);
                    claimedOwnerships.push(newOwnership);
                }
            }
            return claimedOwnerships;
        });
    }
    /**
     * Updates the checkpoint in the data store for a partition.
     *
     * @param checkpoint The checkpoint.
     */
    updateCheckpoint(checkpoint) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwTypeErrorIfParameterMissing("", "updateCheckpoint", "sequenceNumber", checkpoint.sequenceNumber);
            throwTypeErrorIfParameterMissing("", "updateCheckpoint", "offset", checkpoint.offset);
            checkpoint = Object.assign({}, checkpoint);
            const partitionOwnership = this._partitionOwnershipMap.get(checkpoint.partitionId);
            if (partitionOwnership) {
                partitionOwnership.etag = rheaPromise.generate_uuid();
                const key = `${checkpoint.fullyQualifiedNamespace}:${checkpoint.eventHubName}:${checkpoint.consumerGroup}`;
                let partitionMap = this._committedCheckpoints.get(key);
                if (partitionMap == null) {
                    partitionMap = new Map();
                    this._committedCheckpoints.set(key, partitionMap);
                }
                partitionMap.set(checkpoint.partitionId, checkpoint);
            }
        });
    }
    listCheckpoints(fullyQualifiedNamespace, eventHubName, consumerGroup) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const key = `${fullyQualifiedNamespace}:${eventHubName}:${consumerGroup}`;
            const partitionMap = this._committedCheckpoints.get(key);
            if (partitionMap == null) {
                return [];
            }
            const checkpoints = [];
            for (const value of partitionMap.values()) {
                checkpoints.push(Object.assign({}, value));
            }
            return checkpoints;
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (CloseReason) {
    /**
     * Ownership of the partition was lost or transitioned to a new processor instance.
     */
    CloseReason["OwnershipLost"] = "OwnershipLost";
    /**
     * The EventProcessor was shutdown.
     */
    CloseReason["Shutdown"] = "Shutdown";
})(exports.CloseReason || (exports.CloseReason = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 * @internal
 */
class PartitionPump {
    constructor(eventHubClient, partitionProcessor, _startPosition, options) {
        this._startPosition = _startPosition;
        this._isReceiving = false;
        this._isStopped = false;
        this._eventHubClient = eventHubClient;
        this._partitionProcessor = partitionProcessor;
        this._processorOptions = options;
        this._abortController = new abortController.AbortController();
    }
    get isReceiving() {
        return this._isReceiving;
    }
    start() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._isReceiving = true;
            try {
                yield this._partitionProcessor.initialize();
            }
            catch (err) {
                // swallow the error from the user-defined code
                this._partitionProcessor.processError(err);
            }
            // this is intentionally not await'd - the _receiveEvents loop will continue to
            // execute and can be stopped by calling .stop()
            this._receiveEvents(this._partitionProcessor.partitionId);
            logger.info(`Successfully started the receiver for partition "${this._partitionProcessor.partitionId}".`);
        });
    }
    _receiveEvents(partitionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._receiver = this._eventHubClient.createConsumer(this._partitionProcessor.consumerGroup, partitionId, this._startPosition, {
                ownerLevel: this._processorOptions.ownerLevel,
                trackLastEnqueuedEventProperties: this._processorOptions.trackLastEnqueuedEventProperties
            });
            while (this._isReceiving) {
                try {
                    const receivedEvents = yield this._receiver.receiveBatch(this._processorOptions.maxBatchSize, this._processorOptions.maxWaitTimeInSeconds, this._abortController.signal);
                    if (this._processorOptions.trackLastEnqueuedEventProperties &&
                        this._receiver.lastEnqueuedEventProperties) {
                        this._partitionProcessor.lastEnqueuedEventProperties = this._receiver.lastEnqueuedEventProperties;
                    }
                    // avoid calling user's processEvents handler if the pump was stopped while receiving events
                    if (!this._isReceiving) {
                        return;
                    }
                    const span = createProcessingSpan(receivedEvents, this._eventHubClient, this._processorOptions);
                    yield trace(() => this._partitionProcessor.processEvents(receivedEvents), span);
                }
                catch (err) {
                    // check if this pump is still receiving
                    // it may not be if the EventProcessor was stopped during processEvents
                    if (!this._isReceiving) {
                        // no longer receiving, so close was called from somewhere else
                        return;
                    }
                    logger.warning(`An error was thrown while receiving or processing events on partition "${this._partitionProcessor.partitionId}"`);
                    logErrorStackTrace(err);
                    // forward error to user's processError and swallow errors they may throw
                    try {
                        yield this._partitionProcessor.processError(err);
                    }
                    catch (err) {
                        // Using verbose over warning because this error is swallowed.
                        logger.verbose("An error was thrown by user's processError method: ", err);
                    }
                    // close the partition processor if a non-retryable error was encountered
                    if (typeof err !== "object" || !err.retryable) {
                        try {
                            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel
                            // started consuming the partition), update the closeReason
                            if (err.code === "ReceiverDisconnectedError") {
                                return yield this.stop(exports.CloseReason.OwnershipLost);
                            }
                            // this will close the pump and will break us out of the while loop
                            return yield this.stop(exports.CloseReason.Shutdown);
                        }
                        catch (err) {
                            // Using verbose over warning because this error is swallowed.
                            logger.verbose(`An error occurred while closing the receiver with reason ${exports.CloseReason.Shutdown}: `, err);
                        }
                    }
                }
            }
        });
    }
    stop(reason) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._isStopped) {
                return;
            }
            this._isStopped = true;
            this._isReceiving = false;
            try {
                if (this._receiver) {
                    yield this._receiver.close();
                }
                this._abortController.abort();
                yield this._partitionProcessor.close(reason);
            }
            catch (err) {
                logger.warning("An error occurred while closing the receiver.", err);
                logErrorStackTrace(err);
                this._partitionProcessor.processError(err);
                throw err;
            }
        });
    }
}
/**
 * @internal
 * @ignore
 */
function createProcessingSpan(receivedEvents, eventHubProperties, tracingOptions) {
    const links = [];
    for (const receivedEvent of receivedEvents) {
        const spanContext = extractSpanContextFromEventData(receivedEvent);
        if (spanContext == null) {
            continue;
        }
        links.push({
            spanContext
        });
    }
    const span = coreTracing.getTracer().startSpan("Azure.EventHubs.process", {
        kind: types.SpanKind.CONSUMER,
        links,
        parent: getParentSpan(tracingOptions)
    });
    span.setAttributes({
        "az.namespace": "Microsoft.EventHub",
        "message_bus.destination": eventHubProperties.eventHubName,
        "peer.address": eventHubProperties.endpoint
    });
    return span;
}
/**
 * @ignore
 * @internal
 */
function trace(fn, span) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        try {
            yield fn();
            span.setStatus({ code: types.CanonicalCode.OK });
        }
        catch (err) {
            span.setStatus({
                code: types.CanonicalCode.UNKNOWN,
                message: err.message
            });
            throw err;
        }
        finally {
            span.end();
        }
    });
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The PumpManager handles the creation and removal of PartitionPumps.
 * It also starts a PartitionPump when it is created, and stops a
 * PartitionPump when it is removed.
 * @ignore
 * @internal
 */
class PumpManagerImpl {
    /**
     * @ignore
     */
    constructor(eventProcessorName, eventProcessorOptions) {
        this._partitionIdToPumps = {};
        this._eventProcessorName = eventProcessorName;
        this._options = eventProcessorOptions;
    }
    /**
     * Returns a list of partitionIds that are actively receiving messages.
     * @ignore
     */
    receivingFromPartitions() {
        return Object.keys(this._partitionIdToPumps).filter((id) => {
            const pump = this._partitionIdToPumps[id];
            return Boolean(pump && pump.isReceiving);
        });
    }
    /**
     * Indicates whether the pump manager is actively receiving events from a given partition.
     * @param partitionId
     * @ignore
     * @internal
     */
    isReceivingFromPartition(partitionId) {
        const pump = this._partitionIdToPumps[partitionId];
        return Boolean(pump && pump.isReceiving);
    }
    /**
     * Creates and starts a PartitionPump.
     * @param startPosition The position in the partition to start reading from.
     * @param eventHubClient The EventHubClient to forward to the PartitionPump.
     * @param partitionProcessor The PartitionProcessor to forward to the PartitionPump.
     * @ignore
     */
    createPump(startPosition, eventHubClient, partitionProcessor, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const partitionId = partitionProcessor.partitionId;
            if (abortSignal.aborted) {
                logger.verbose(`${this._eventProcessorName}] The subscription was closed before creating the pump for partition ${partitionId}.`);
                return;
            }
            // attempt to get an existing pump
            const existingPump = this._partitionIdToPumps[partitionId];
            if (existingPump) {
                if (existingPump.isReceiving) {
                    logger.verbose(`[${this._eventProcessorName}] [${partitionId}] The existing pump is running.`);
                    return;
                }
                logger.verbose(`[${this._eventProcessorName}] [${partitionId}] The existing pump is not running.`);
                yield this.removePump(partitionId, exports.CloseReason.OwnershipLost);
            }
            logger.verbose(`[${this._eventProcessorName}] [${partitionId}] Creating a new pump.`);
            const pump = new PartitionPump(eventHubClient, partitionProcessor, startPosition, this._options);
            try {
                yield pump.start();
                this._partitionIdToPumps[partitionId] = pump;
            }
            catch (err) {
                logger.verbose(`[${this._eventProcessorName}] [${partitionId}] An error occured while adding/updating a pump: ${err}`);
                logErrorStackTrace(err);
            }
        });
    }
    /**
     * Stop a PartitionPump and removes it from the internal map.
     * @param partitionId The partitionId to remove the associated PartitionPump from.
     * @param reason The reason for removing the pump.
     * @ignore
     */
    removePump(partitionId, reason) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const pump = this._partitionIdToPumps[partitionId];
                if (pump) {
                    delete this._partitionIdToPumps[partitionId];
                    logger.verbose(`[${this._eventProcessorName}] [${partitionId}] Stopping the pump.`);
                    yield pump.stop(reason);
                }
                else {
                    logger.verbose(`[${this._eventProcessorName}] [${partitionId}] No pump was found to remove.`);
                }
            }
            catch (err) {
                logger.verbose(`[${this._eventProcessorName}] [${partitionId}] An error occured while removing a pump: ${err}`);
                logErrorStackTrace(err);
            }
        });
    }
    /**
     * Stops all PartitionPumps and removes them from the internal map.
     * @param reason The reason for removing the pump.
     * @ignore
     */
    removeAllPumps(reason) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const partitionIds = Object.keys(this._partitionIdToPumps);
            logger.verbose(`[${this._eventProcessorName}] Removing all pumps due to reason ${reason}.`);
            const tasks = [];
            for (const partitionId of partitionIds) {
                const pump = this._partitionIdToPumps[partitionId];
                if (pump) {
                    tasks.push(pump.stop(reason));
                }
            }
            try {
                yield Promise.all(tasks);
            }
            catch (err) {
                logger.verbose(`[${this._eventProcessorName}] An error occured while removing all pumps: ${err}`);
                logErrorStackTrace(err);
            }
            finally {
                this._partitionIdToPumps = {};
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * This class does no load balancing - it's intended to be used when
 * you want to avoid load balancing and consume a set of partitions (or all
 * available partitions)
 * @internal
 * @ignore
 */
class GreedyPartitionLoadBalancer {
    /**
     * @param partitionIds An optional set of partition IDs. undefined means all partitions.
     */
    constructor(partitionIds) {
        logger.verbose(`GreedyPartitionLoadBalancer created. Watching ${partitionIds ? "(" + partitionIds.join(",") + ")" : "all"}.`);
        this.partitionsToClaim = partitionIds && new Set(partitionIds);
    }
    loadBalance(ownerId, partitionOwnershipMap, partitionsToAdd) {
        let potential = partitionsToAdd;
        if (this.partitionsToClaim) {
            const partitionsToClaim = this.partitionsToClaim;
            potential = partitionsToAdd.filter((part) => partitionsToClaim.has(part));
        }
        return potential;
    }
}
/**
 * This class is responsible for balancing the load of processing events from all partitions of an Event Hub by
 * distributing the number of partitions uniformly among all the active EventProcessors.
 *
 * This load balancer will retrieve partition ownership details from the CheckpointStore to find the number of
 * active EventProcessor. It uses the last modified time to decide if an EventProcessor is active. If a
 * partition ownership entry has not be updated for a specified duration of time, the owner of that partition is
 * considered inactive and the partition is available for other EventProcessors to own.
 * @class PartitionLoadBalancer
 * @internal
 * @ignore
 */
class FairPartitionLoadBalancer {
    /**
     * Creates an instance of PartitionBasedLoadBalancer.
     *
     * @param ownerId The identifier of the Event Processor that owns this load balancer.
     * @param inactiveTimeLimitInMS The time to wait for an update on an ownership record before
     * assuming the owner of the partition is inactive.
     * */
    constructor(inactiveTimeLimitInMS) {
        logger.verbose(`FairPartitionLoadBalancer created inactive time limit: ${inactiveTimeLimitInMS}ms`);
        this._inactiveTimeLimitInMS = inactiveTimeLimitInMS;
    }
    /*
     * Find the event processor that owns the maximum number of partitions and steal a random partition
     * from it.
     */
    _findPartitionToSteal(ourOwnerId, ownerPartitionMap) {
        let maxList = [];
        let maxPartitionsOwnedByAnyEventProcessor = Number.MIN_VALUE;
        let ownerId;
        ownerPartitionMap.forEach((ownershipList, ownerId) => {
            if (ownershipList.length > maxPartitionsOwnedByAnyEventProcessor) {
                maxPartitionsOwnedByAnyEventProcessor = ownershipList.length;
                maxList = ownershipList;
            }
        });
        logger.verbose(`[${ourOwnerId}] Owner id ${ownerId} owns ${maxList.length} partitions, stealing a partition from it.`);
        return maxList[Math.floor(Math.random() * maxList.length)].partitionId;
    }
    /**
     * Whether we should attempt to claim more partitions for this particular processor.
     *
     * @param minRequired The minimum required number of partitions.
     * @param numEventProcessorsWithAdditionalPartition The current number of processors that have an additional partition.
     * @param numPartitionsOwnedByUs The number of partitions we currently own.
     * @param processorCounts Processors, grouped by criteria.
     */
    _shouldOwnMorePartitions(minRequired, numEventProcessorsWithAdditionalPartition, numPartitionsOwnedByUs, processorCounts) {
        let actualRequired = minRequired;
        if (numEventProcessorsWithAdditionalPartition > 0 &&
            // eventually the `haveTooManyPartitions` will get decay into `haveAdditionalPartition`
            // processors as partitions are balanced to consumers that aren't at par. We can
            // consider them to be `haveAdditionalPartition` processors for our purposes.
            processorCounts.haveAdditionalPartition + processorCounts.haveTooManyPartitions <
                numEventProcessorsWithAdditionalPartition) {
            // overall we don't have enough processors that are taking on an additional partition
            // so we should attempt to.
            actualRequired = minRequired + 1;
        }
        return numPartitionsOwnedByUs < actualRequired;
    }
    /**
     * Validates that we are currently in a balanced state - all processors own the
     * minimum required number of partitions (and additional partitions, if the # of partitions
     * is not evenly divisible by the # of processors).
     *
     * @param requiredNumberOfEventProcessorsWithAdditionalPartition The # of processors that process an additional partition, in addition to the required minimum.
     * @param totalExpectedProcessors The total # of processors we expect.
     * @param processorCounts Processors, grouped by criteria.
     */
    _isLoadBalanced(requiredNumberOfEventProcessorsWithAdditionalPartition, totalExpectedProcessors, processorCounts) {
        return (processorCounts.haveAdditionalPartition ===
            requiredNumberOfEventProcessorsWithAdditionalPartition &&
            processorCounts.haveRequiredPartitions + processorCounts.haveAdditionalPartition ===
                totalExpectedProcessors);
    }
    /**
     * Counts the processors and tallying them by type.
     *
     * To be in balance we need to make sure that each processor is only consuming
     * their fair share.
     *
     * When the partitions are divvied up we will sometimes end up with some processors
     * that will have 1 more partition than others. This can happen if the number of
     * partitions is not evenly divisible by the number of processors.
     *
     * So this function largely exists to support _isLoadBalanced() and
     * _shouldOwnMorePartitions(), both of which depend on knowing if our current list
     * of processors is actually in the proper state.
     *
     * @param numPartitionsRequired The number of required partitions per processor.
     * @param ownerPartitionMap The current ownerships for partitions.
     */
    _getProcessorCounts(numPartitionsRequired, ownerPartitionMap) {
        const counts = {
            haveRequiredPartitions: 0,
            haveAdditionalPartition: 0,
            haveTooManyPartitions: 0
        };
        for (const ownershipList of ownerPartitionMap.values()) {
            const numberOfPartitions = ownershipList.length;
            // there are basically three kinds of partition counts
            // for a processor:
            // 1. Has _exactly_ the required number of partitions
            if (numberOfPartitions === numPartitionsRequired) {
                counts.haveRequiredPartitions++;
            }
            // 2. Has the required number plus one extra (correct in cases)
            // where the # of partitions is not evenly divisible by the
            // number of processors.
            if (numberOfPartitions === numPartitionsRequired + 1) {
                counts.haveAdditionalPartition++;
            }
            // 3. has more than the possible # of partitions required
            if (numberOfPartitions > numPartitionsRequired + 1) {
                counts.haveTooManyPartitions++;
            }
        }
        return counts;
    }
    /*
     * This method will create a new map of partition id and PartitionOwnership containing only those partitions
     * that are actively owned. All entries in the original map returned by CheckpointStore that haven't been
     * modified for a duration of time greater than the allowed inactivity time limit are assumed to be owned by
     * dead event processors. These will not be included in the map returned by this method.
     */
    _removeInactivePartitionOwnerships(partitionOwnershipMap) {
        const activePartitionOwnershipMap = new Map();
        partitionOwnershipMap.forEach((partitionOwnership, partitionId) => {
            var date = new Date();
            if (partitionOwnership.lastModifiedTimeInMs &&
                date.getTime() - partitionOwnership.lastModifiedTimeInMs < this._inactiveTimeLimitInMS &&
                partitionOwnership.ownerId) {
                activePartitionOwnershipMap.set(partitionId, partitionOwnership);
            }
        });
        return activePartitionOwnershipMap;
    }
    /*
     * This method works with the given partition ownership details and Event Hub partitions to evaluate whether the
     * current Event Processor should take on the responsibility of processing more partitions.
     */
    loadBalance(ourOwnerId, partitionOwnershipMap, partitionsToAdd) {
        //  Remove all partitions ownership that have not been modified within the configured period of time. This means that the previous
        //  event processor that owned the partition is probably down and the partition is now eligible to be
        //  claimed by other event processors.
        const activePartitionOwnershipMap = this._removeInactivePartitionOwnerships(partitionOwnershipMap);
        logger.verbose(`[${ourOwnerId}] Number of active ownership records: ${activePartitionOwnershipMap.size}.`);
        if (activePartitionOwnershipMap.size === 0) {
            // If the active partition ownership map is empty, this is the first time an event processor is
            // running or all Event Processors are down for this Event Hub, consumer group combination. All
            // partitions in this Event Hub are available to claim. Choose a random partition to claim ownership.
            return [partitionsToAdd[Math.floor(Math.random() * partitionsToAdd.length)]];
        }
        // Create a map of owner id and a list of partitions it owns
        const ownerPartitionMap = new Map();
        for (const activePartitionOwnership of activePartitionOwnershipMap.values()) {
            const partitionOwnershipArray = ownerPartitionMap.get(activePartitionOwnership.ownerId) || [];
            partitionOwnershipArray.push(activePartitionOwnership);
            ownerPartitionMap.set(activePartitionOwnership.ownerId, partitionOwnershipArray);
        }
        // add the current event processor to the map if it doesn't exist
        if (!ownerPartitionMap.has(ourOwnerId)) {
            ownerPartitionMap.set(ourOwnerId, []);
        }
        logger.info(`[${ourOwnerId}] Number of active event processors: ${ownerPartitionMap.size}.`);
        // Include any partitions this entity already owns in the list of partitions to claim.
        const partitionsToClaim = (ownerPartitionMap.get(ourOwnerId) || []).map((ownership) => ownership.partitionId);
        // Find the minimum number of partitions every event processor should own when the load is
        // evenly distributed.
        const minPartitionsPerEventProcessor = Math.floor(partitionsToAdd.length / ownerPartitionMap.size);
        // If the number of partitions in Event Hub is not evenly divisible by number of active event processors,
        // a few Event Processors may own 1 additional partition than the minimum when the load is balanced. Calculate
        // the number of event processors that can own an additional partition.
        const requiredNumberOfEventProcessorsWithAdditionalPartition = partitionsToAdd.length % ownerPartitionMap.size;
        logger.verbose(`[${ourOwnerId}] Expected minimum number of partitions per event processor: ${minPartitionsPerEventProcessor}, 
      expected number of event processors with additional partition: ${requiredNumberOfEventProcessorsWithAdditionalPartition}.`);
        const processorCounts = this._getProcessorCounts(minPartitionsPerEventProcessor, ownerPartitionMap);
        if (this._isLoadBalanced(requiredNumberOfEventProcessorsWithAdditionalPartition, ownerPartitionMap.size, processorCounts)) {
            logger.info(`[${ourOwnerId}] Load is balanced.`);
            // If the partitions are evenly distributed among all active event processors, no change required.
            return partitionsToClaim;
        }
        if (!this._shouldOwnMorePartitions(minPartitionsPerEventProcessor, requiredNumberOfEventProcessorsWithAdditionalPartition, ownerPartitionMap.get(ourOwnerId).length, processorCounts)) {
            logger.verbose(`[${ourOwnerId}] This event processor owns ${ownerPartitionMap.get(ourOwnerId).length} partitions and shouldn't own more.`);
            // This event processor already has enough partitions and shouldn't own more yet
            return partitionsToClaim;
        }
        logger.info(`[${ourOwnerId}] Load is unbalanced and this event processor should own more partitions.`);
        // If we have reached this stage, this event processor has to claim/steal ownership of at least 1 more partition
        //  If some partitions are unclaimed, this could be because an event processor is down and
        //  it's partitions are now available for others to own or because event processors are just
        //  starting up and gradually claiming partitions to own or new partitions were added to Event Hub.
        //  Find any partition that is not actively owned and claim it.
        //   OR
        //  Find a partition to steal from another event processor. Pick the event processor that owns the highest
        //  number of partitions.
        const unOwnedPartitionIds = [];
        for (const partitionId of partitionsToAdd) {
            if (!activePartitionOwnershipMap.has(partitionId)) {
                unOwnedPartitionIds.push(partitionId);
            }
        }
        if (unOwnedPartitionIds.length === 0) {
            logger.info(`[${ourOwnerId}] No unclaimed partitions, stealing from another event processor.`);
            partitionsToClaim.push(this._findPartitionToSteal(ourOwnerId, ownerPartitionMap));
        }
        else {
            partitionsToClaim.push(unOwnedPartitionIds[Math.floor(Math.random() * unOwnedPartitionIds.length)]);
        }
        return partitionsToClaim;
    }
}

/**
 * The `PartitionProcessor` is responsible for processing events received from Event Hubs when using `EventProcessor`
 *
 * The EventProcessor creates a new instance of the PartitionProcessor for each partition of the event hub it starts processing. When you extend the `PartitionProcessor` in order to customize it as you see fit,
 * - Override the `processEvents()` method to add the code to process the received events. This is also a good place to update the checkpoints using the `updateCheckpoint()` method
 * - Optionally override the `processError()` method to handle any error that might have occurred when processing the events.
 * - Optionally override the `initialize()` method to implement any set up related tasks you would want to carry out before starting to receive events from the partition
 * - Optionally override the `close()` method to implement any tear down or clean up tasks you would want to carry out.
 * @internal
 * @ignore
 */
class PartitionProcessor {
    constructor(_eventHandlers, _checkpointStore, _context) {
        this._eventHandlers = _eventHandlers;
        this._checkpointStore = _checkpointStore;
        this._context = _context;
    }
    /**
     * @property Information on the last enqueued event in the partition that is being processed.
     * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true
     * when creating an instance of EventProcessor
     * @readonly
     */
    get lastEnqueuedEventProperties() {
        return this._lastEnqueuedEventProperties;
    }
    /**
     * @property Information on the last enqueued event in the partition that is being processed.
     * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true
     * when creating an instance of EventProcessor
     */
    set lastEnqueuedEventProperties(properties) {
        this._lastEnqueuedEventProperties = properties;
    }
    /**
     * @property The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    get fullyQualifiedNamespace() {
        return this._context.fullyQualifiedNamespace;
    }
    /**
     * @property The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    get consumerGroup() {
        return this._context.consumerGroup;
    }
    /**
     * @property The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`
     * @readonly
     */
    get eventHubName() {
        return this._context.eventHubName;
    }
    /**
     * @property The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    get partitionId() {
        return this._context.partitionId;
    }
    /**
     * @property The unique identifier of the `EventProcessor` that has spawned the current instance of `PartitionProcessor`. This is set by the `EventProcessor`
     */
    get eventProcessorId() {
        return this._context.eventProcessorId;
    }
    /**
     * This method is called when the `EventProcessor` takes ownership of a new partition and before any
     * events are received.
     *
     * @return {Promise<EventPosition>}
     */
    initialize() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._eventHandlers.processInitialize) {
                yield this._eventHandlers.processInitialize(this);
            }
        });
    }
    /**
     * This method is called before the partition processor is closed by the EventProcessor.
     *
     * @param reason The reason for closing this partition processor.
     * @return {Promise<void>}
     */
    close(reason) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._eventHandlers.processClose) {
                yield this._eventHandlers.processClose(reason, this);
            }
        });
    }
    /**
     * This method is called when new events are received.
     *
     * This is also a good place to update checkpoints as appropriate.
     *
     * @param event The received events to be processed.
     * @return {Promise<void>}
     */
    processEvents(events) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            yield this._eventHandlers.processEvents(events, this);
        });
    }
    /**
     * This method is called when an error occurs while receiving events from Event Hubs.
     *
     * @param error The error to be processed.
     * @return {Promise<void>}
     */
    processError(error) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._eventHandlers.processError) {
                try {
                    yield this._eventHandlers.processError(error, this);
                }
                catch (err) {
                    logger.verbose(`Error thrown from user's processError handler : ${err}`);
                }
            }
        });
    }
    /**
     * Updates the checkpoint using the event data.
     *
     * A checkpoint is meant to represent the last successfully processed event by the user from a particular
     * partition of a consumer group in an Event Hub instance.
     *
     * @param eventData The event that you want to update the checkpoint with.
     * @return Promise<void>
     */
    updateCheckpoint(eventData) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const checkpoint = {
                fullyQualifiedNamespace: this._context.fullyQualifiedNamespace,
                eventHubName: this._context.eventHubName,
                consumerGroup: this._context.consumerGroup,
                partitionId: this._context.partitionId,
                sequenceNumber: eventData.sequenceNumber,
                offset: eventData.offset
            };
            yield this._checkpointStore.updateCheckpoint(checkpoint);
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @param delayInMs The number of milliseconds to be delayed.
 * @param abortSignal The abortSignal associated with the containing operation.
 * @internal
 * @ignore
 */
function delayWithoutThrow(delayInMs, abortSignal) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        try {
            yield coreAmqp.delay(delayInMs, abortSignal);
        }
        catch (_a) { } // swallow AbortError
    });
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Event Processor based applications consist of one or more instances of EventProcessor which have been
 * configured to consume events from the same Event Hub and consumer group. They balance the
 * workload across different instances by distributing the partitions to be processed among themselves.
 * They also allow the user to track progress when events are processed using checkpoints.
 *
 * A checkpoint is meant to represent the last successfully processed event by the user from a particular
 * partition of a consumer group in an Event Hub instance.
 *
 * You need the below to create an instance of `EventProcessor`
 * - The name of the consumer group from which you want to process events
 * - An instance of `EventHubClient` class that was created for the Event Hub instance.
 * - A user implemented class that extends the `PartitionProcessor` class. To get started, you can use the
 * base class `PartitionProcessor` which simply logs the incoming events. To provide your code to process incoming
 * events, extend this class and override the `processEvents()` method. For example:
 * ```js
 * class SamplePartitionProcessor extends PartitionProcessor {
 *     async processEvents(events) {
 *        // user code to process events here
 *        // Information on the partition being processed is available as properties on the `SamplePartitionProcessor` class
 *        // use `this.updateCheckpoint()` method to update checkpoints as needed
 *     }
 * }
 * ```
 * - An instance of `CheckpointStore`. See &commat;azure/eventhubs-checkpointstore-blob for an implementation.
 * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.
 * Implementations of `CheckpointStore` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.
 *
 * @class EventProcessor
 * @internal
 * @ignore
 */
class EventProcessor {
    /**
     * @param consumerGroup The name of the consumer group from which you want to process events.
     * @param eventHubClient An instance of `EventHubClient` that was created for the Event Hub instance.
     * @param PartitionProcessorClass A user-provided class that extends the `PartitionProcessor` class.
     * This class will be responsible for processing and checkpointing events.
     * @param checkpointStore An instance of `CheckpointStore`. See &commat;azure/eventhubs-checkpointstore-blob for an implementation.
     * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.
     * @param options A set of options to configure the Event Processor
     * - `maxBatchSize`         : The max size of the batch of events passed each time to user code for processing.
     * - `maxWaitTimeInSeconds` : The maximum amount of time to wait to build up the requested message count before
     * passing the data to user code for processing. If not provided, it defaults to 60 seconds.
     */
    constructor(consumerGroup, _eventHubClient, _subscriptionEventHandlers, _checkpointStore, options) {
        this._eventHubClient = _eventHubClient;
        this._subscriptionEventHandlers = _subscriptionEventHandlers;
        this._checkpointStore = _checkpointStore;
        this._isRunning = false;
        this._loopIntervalInMs = 10000;
        this._inactiveTimeLimitInMs = 60000;
        if (options.ownerId) {
            this._id = options.ownerId;
            logger.verbose(`Starting event processor with ID ${this._id}`);
        }
        else {
            this._id = v4_1();
            logger.verbose(`Starting event processor with autogenerated ID ${this._id}`);
        }
        this._consumerGroup = consumerGroup;
        this._processorOptions = options;
        this._pumpManager =
            options.pumpManager || new PumpManagerImpl(this._id, this._processorOptions);
        const inactiveTimeLimitInMS = options.inactiveTimeLimitInMs || this._inactiveTimeLimitInMs;
        this._processingTarget =
            options.processingTarget || new FairPartitionLoadBalancer(inactiveTimeLimitInMS);
        if (options.loopIntervalInMs) {
            this._loopIntervalInMs = options.loopIntervalInMs;
        }
    }
    /**
     * The unique identifier for the EventProcessor.
     *
     * @return {string}
     */
    get id() {
        return this._id;
    }
    _createPartitionOwnershipRequest(partitionOwnershipMap, partitionIdToClaim) {
        const previousPartitionOwnership = partitionOwnershipMap.get(partitionIdToClaim);
        const partitionOwnership = {
            ownerId: this._id,
            partitionId: partitionIdToClaim,
            fullyQualifiedNamespace: this._eventHubClient.fullyQualifiedNamespace,
            consumerGroup: this._consumerGroup,
            eventHubName: this._eventHubClient.eventHubName,
            etag: previousPartitionOwnership ? previousPartitionOwnership.etag : undefined
        };
        return partitionOwnership;
    }
    /*
     * Claim ownership of the given partition if it's available
     */
    _claimOwnership(ownershipRequest, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (abortSignal.aborted) {
                logger.verbose(`[${this._id}] Subscription was closed before claiming ownership of ${ownershipRequest.partitionId}.`);
                return;
            }
            logger.info(`[${this._id}] Attempting to claim ownership of partition ${ownershipRequest.partitionId}.`);
            try {
                const claimedOwnerships = yield this._checkpointStore.claimOwnership([ownershipRequest]);
                // can happen if the partition was claimed out from underneath us - we shouldn't
                // attempt to spin up a processor.
                if (!claimedOwnerships.length) {
                    return;
                }
                logger.info(`[${this._id}] Successfully claimed ownership of partition ${ownershipRequest.partitionId}.`);
                yield this._startPump(ownershipRequest.partitionId, abortSignal);
            }
            catch (err) {
                logger.warning(`[${this.id}] Failed to claim ownership of partition ${ownershipRequest.partitionId}`);
                logErrorStackTrace(err);
                yield this._handleSubscriptionError(err);
            }
        });
    }
    _startPump(partitionId, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (abortSignal.aborted) {
                logger.verbose(`[${this._id}] The subscription was closed before starting to read from ${partitionId}.`);
                return;
            }
            if (this._pumpManager.isReceivingFromPartition(partitionId)) {
                logger.verbose(`[${this._id}] There is already an active partitionPump for partition "${partitionId}", skipping pump creation.`);
                return;
            }
            logger.verbose(`[${this._id}] [${partitionId}] Calling user-provided PartitionProcessorFactory.`);
            const partitionProcessor = new PartitionProcessor(this._subscriptionEventHandlers, this._checkpointStore, {
                fullyQualifiedNamespace: this._eventHubClient.fullyQualifiedNamespace,
                eventHubName: this._eventHubClient.eventHubName,
                consumerGroup: this._consumerGroup,
                partitionId: partitionId,
                eventProcessorId: this.id
            });
            const eventPosition = yield this._getStartingPosition(partitionId);
            yield this._pumpManager.createPump(eventPosition, this._eventHubClient, partitionProcessor, abortSignal);
            logger.verbose(`[${this._id}] PartitionPump created successfully.`);
        });
    }
    _getStartingPosition(partitionIdToClaim) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const availableCheckpoints = yield this._checkpointStore.listCheckpoints(this._eventHubClient.fullyQualifiedNamespace, this._eventHubClient.eventHubName, this._consumerGroup);
            const validCheckpoints = availableCheckpoints.filter((chk) => chk.partitionId === partitionIdToClaim);
            if (validCheckpoints.length > 0) {
                return { offset: validCheckpoints[0].offset };
            }
            logger.verbose(`No checkpoint found for partition ${partitionIdToClaim}. Looking for fallback.`);
            return getStartPosition(partitionIdToClaim, this._processorOptions.startPosition);
        });
    }
    _runLoopForSinglePartition(partitionId, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            while (!abortSignal.aborted) {
                try {
                    yield this._startPump(partitionId, abortSignal);
                }
                catch (err) {
                    logger.warning(`[${this._id}] An error occured within the EventProcessor loop: ${err}`);
                    logErrorStackTrace(err);
                    yield this._handleSubscriptionError(err);
                }
                finally {
                    // sleep for some time after which we can attempt to create a pump again.
                    logger.verbose(`[${this._id}] Pausing the EventProcessor loop for ${this._loopIntervalInMs} ms.`);
                    // swallow errors from delay since it's fine for delay to exit early
                    yield delayWithoutThrow(this._loopIntervalInMs, abortSignal);
                }
            }
            this._isRunning = false;
        });
    }
    /**
     * Every loop to this method will result in this EventProcessor owning at most one new partition.
     *
     * The load is considered balanced when no active EventProcessor owns 2 partitions more than any other active
     * EventProcessor. Given that each invocation to this method results in ownership claim of at most one partition,
     * this algorithm converges gradually towards a steady state.
     *
     * When a new partition is claimed, this method is also responsible for starting a partition pump that creates an
     * EventHubConsumer for processing events from that partition.
     */
    _runLoopWithLoadBalancing(loadBalancer, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // periodically check if there is any partition not being processed and process it
            while (!abortSignal.aborted) {
                try {
                    const partitionOwnershipMap = new Map();
                    // Retrieve current partition ownership details from the datastore.
                    const partitionOwnership = yield this._checkpointStore.listOwnership(this._eventHubClient.fullyQualifiedNamespace, this._eventHubClient.eventHubName, this._consumerGroup);
                    const abandonedMap = new Map();
                    for (const ownership of partitionOwnership) {
                        if (isAbandoned(ownership)) {
                            abandonedMap.set(ownership.partitionId, ownership);
                            continue;
                        }
                        partitionOwnershipMap.set(ownership.partitionId, ownership);
                    }
                    const partitionIds = yield this._eventHubClient.getPartitionIds({
                        abortSignal: abortSignal
                    });
                    if (abortSignal.aborted) {
                        return;
                    }
                    if (partitionIds.length > 0) {
                        const partitionsToClaim = loadBalancer.loadBalance(this._id, partitionOwnershipMap, partitionIds);
                        if (partitionsToClaim) {
                            for (const partitionToClaim of partitionsToClaim) {
                                let ownershipRequest;
                                if (abandonedMap.has(partitionToClaim)) {
                                    ownershipRequest = this._createPartitionOwnershipRequest(abandonedMap, partitionToClaim);
                                }
                                else {
                                    ownershipRequest = this._createPartitionOwnershipRequest(partitionOwnershipMap, partitionToClaim);
                                }
                                yield this._claimOwnership(ownershipRequest, abortSignal);
                            }
                        }
                    }
                }
                catch (err) {
                    logger.warning(`[${this._id}] An error occured within the EventProcessor loop: ${err}`);
                    logErrorStackTrace(err);
                    yield this._handleSubscriptionError(err);
                }
                finally {
                    // sleep for some time, then continue the loop again.
                    logger.verbose(`[${this._id}] Pausing the EventProcessor loop for ${this._loopIntervalInMs} ms.`);
                    // swallow the error since it's fine to exit early from delay
                    yield delayWithoutThrow(this._loopIntervalInMs, abortSignal);
                }
            }
            this._isRunning = false;
        });
    }
    /**
     * This is called when there are errors that are not specific to a partition (ex: load balancing)
     */
    _handleSubscriptionError(err) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // filter out any internal "expected" errors
            if (err.name === "AbortError") {
                return;
            }
            if (this._subscriptionEventHandlers.processError) {
                try {
                    yield this._subscriptionEventHandlers.processError(err, {
                        fullyQualifiedNamespace: this._eventHubClient.fullyQualifiedNamespace,
                        eventHubName: this._eventHubClient.eventHubName,
                        consumerGroup: this._consumerGroup,
                        partitionId: "",
                        updateCheckpoint: () => tslib.__awaiter(this, void 0, void 0, function* () { })
                    });
                }
                catch (err) {
                    logger.verbose(`[${this._id}] An error was thrown from the user's processError handler: ${err}`);
                }
            }
        });
    }
    /**
     * Starts the `EventProcessor`. Based on the number of instances of `EventProcessor` that are running for the
     * same consumer group, the partitions are distributed among these instances to process events.
     *
     * For each partition, the user provided `PartitionProcessor` is instantiated.
     *
     * Subsequent calls to start will be ignored if this event processor is already running.
     * Calling `start()` after `stop()` is called will restart this event processor.
     *
     * @return {void}
     */
    start() {
        if (this._isRunning) {
            logger.verbose(`[${this._id}] Attempted to start an already running EventProcessor.`);
            return;
        }
        this._isRunning = true;
        this._abortController = new abortController.AbortController();
        logger.verbose(`[${this._id}] Starting an EventProcessor.`);
        if (targetWithoutOwnership(this._processingTarget)) {
            logger.verbose(`[${this._id}] Single partition target: ${this._processingTarget}`);
            this._loopTask = this._runLoopForSinglePartition(this._processingTarget, this._abortController.signal);
        }
        else {
            logger.verbose(`[${this._id}] Multiple partitions, using load balancer`);
            this._loopTask = this._runLoopWithLoadBalancing(this._processingTarget, this._abortController.signal);
        }
    }
    isRunning() {
        return this._isRunning;
    }
    /**
     * Stops processing events for all partitions owned by this event processor.
     * All `PartitionProcessor` will be shutdown and any open resources will be closed.
     *
     * Subsequent calls to stop will be ignored if the event processor is not running.
     *
     */
    stop() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            logger.verbose(`[${this._id}] Stopping an EventProcessor.`);
            if (this._abortController) {
                // cancel the event processor loop
                this._abortController.abort();
            }
            try {
                // remove all existing pumps
                yield this._pumpManager.removeAllPumps(exports.CloseReason.Shutdown);
                // waits for the event processor loop to complete
                // will complete immediately if _loopTask is undefined
                if (this._loopTask) {
                    yield this._loopTask;
                }
            }
            catch (err) {
                logger.verbose(`[${this._id}] An error occured while stopping the EventProcessor: ${err}`);
            }
            finally {
                logger.verbose(`[${this._id}] EventProcessor stopped.`);
            }
            if (targetWithoutOwnership(this._processingTarget)) {
                logger.verbose(`[${this._id}] No partitions owned, skipping abandoning.`);
            }
            else {
                yield this.abandonPartitionOwnerships();
            }
        });
    }
    abandonPartitionOwnerships() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            logger.verbose(`[${this._id}] Abandoning owned partitions`);
            const allOwnerships = yield this._checkpointStore.listOwnership(this._eventHubClient.fullyQualifiedNamespace, this._eventHubClient.eventHubName, this._consumerGroup);
            const ourOwnerships = allOwnerships.filter((ownership) => ownership.ownerId === this._id);
            // unclaim any partitions that we currently own
            for (const ownership of ourOwnerships) {
                ownership.ownerId = "";
            }
            return this._checkpointStore.claimOwnership(ourOwnerships);
        });
    }
}
function isAbandoned(ownership) {
    return ownership.ownerId === "";
}
function getStartPosition(partitionIdToClaim, startPositions) {
    if (startPositions == null) {
        return latestEventPosition;
    }
    if (isEventPosition(startPositions)) {
        return startPositions;
    }
    const startPosition = startPositions[partitionIdToClaim];
    if (startPosition == null) {
        return latestEventPosition;
    }
    return startPosition;
}
function targetWithoutOwnership(target) {
    return typeof target === "string";
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * Used by EventHubConsumerClient to prevent accidentally spinning up multiple
 * subscriptions against the same set of partitions.
 *
 * This is needed now that EventHubConsumerClient only uses a single CheckpointStore
 * instance - otherwise users will see unpredictable results as their event processor
 * continually steals/overwrites checkpointing and ownership with itself.
 *
 * @internal
 * @ignore
 */
class PartitionGate {
    constructor() {
        this._partitions = new Set();
    }
    /**
     * Adds a partition, throwing an Error if there is a conflict with partitions (including "all")
     * that are already added.
     *
     * @param partitionId A partition ID or the constant "all"
     */
    add(partitionId) {
        this._validatePartitionId(partitionId);
        if ((partitionId === "all" && this._partitions.size > 0) ||
            this._partitions.has(partitionId) ||
            this._partitions.has("all")) {
            throw new Error(`Partition already has a subscriber.`);
        }
        this._partitions.add(partitionId);
    }
    /**
     * Removes a partition
     *
     * @param partitionId A partition ID or the constant "all"
     */
    remove(partitionId) {
        this._partitions.delete(partitionId);
    }
    _validatePartitionId(partitionId) {
        if (partitionId === "all") {
            return;
        }
        const partitionNumber = parseInt(partitionId, 10);
        if (isNaN(partitionNumber)) {
            throw new TypeError(`Invalid partition number ${partitionId}`);
        }
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
const defaultConsumerClientOptions = {
    // to support our current "process single event only" workflow we'll also purposefully
    // only request a single event at a time.
    maxBatchSize: 1,
    maxWaitTimeInSeconds: 60
};
/**
 * The `EventHubConsumerClient` class is used to consume events from an Event Hub.
 *
 * There are multiple ways to create an `EventHubConsumerClient`
 * - Use the connection string from the SAS policy created for your Event Hub instance.
 * - Use the connection string from the SAS policy created for your Event Hub namespace,
 * and the name of the Event Hub instance
 * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.
 *
 * Optionally, you can also pass:
 * - An options bag to configure the retry policy or proxy settings.
 * - A checkpoint store that is used by the client to read checkpoints to determine the position from where it should
 * resume receiving events when your application gets restarted. The checkpoint store is also used by the client
 * to load balance multiple instances of your application.
 */
class EventHubConsumerClient {
    constructor(_consumerGroup, connectionStringOrFullyQualifiedNamespace2, checkpointStoreOrEventHubNameOrOptions3, checkpointStoreOrCredentialOrOptions4, checkpointStoreOrOptions5, options6) {
        this._consumerGroup = _consumerGroup;
        this._partitionGate = new PartitionGate();
        this._id = v4_1();
        if (coreAmqp.isTokenCredential(checkpointStoreOrCredentialOrOptions4)) {
            // #3 or 3.1
            logger.info("Creating EventHubConsumerClient with TokenCredential.");
            let eventHubClientOptions;
            if (isCheckpointStore(checkpointStoreOrOptions5)) {
                // 3.1
                this._checkpointStore = checkpointStoreOrOptions5;
                this._userChoseCheckpointStore = true;
                eventHubClientOptions = options6;
            }
            else {
                this._checkpointStore = new InMemoryCheckpointStore();
                this._userChoseCheckpointStore = false;
                eventHubClientOptions = checkpointStoreOrOptions5;
            }
            this._eventHubClient = new EventHubClient(connectionStringOrFullyQualifiedNamespace2, checkpointStoreOrEventHubNameOrOptions3, checkpointStoreOrCredentialOrOptions4, eventHubClientOptions);
        }
        else if (typeof checkpointStoreOrEventHubNameOrOptions3 === "string") {
            // #2 or 2.1
            logger.info("Creating EventHubConsumerClient with connection string and event hub name.");
            let eventHubClientOptions;
            if (isCheckpointStore(checkpointStoreOrCredentialOrOptions4)) {
                // 2.1
                this._checkpointStore = checkpointStoreOrCredentialOrOptions4;
                this._userChoseCheckpointStore = true;
                eventHubClientOptions = checkpointStoreOrOptions5;
            }
            else {
                // 2
                this._checkpointStore = new InMemoryCheckpointStore();
                this._userChoseCheckpointStore = false;
                eventHubClientOptions = checkpointStoreOrCredentialOrOptions4;
            }
            this._eventHubClient = new EventHubClient(connectionStringOrFullyQualifiedNamespace2, checkpointStoreOrEventHubNameOrOptions3, eventHubClientOptions);
        }
        else {
            // #1 or 1.1
            logger.info("Creating EventHubConsumerClient with connection string.");
            let eventHubClientOptions;
            if (isCheckpointStore(checkpointStoreOrEventHubNameOrOptions3)) {
                // 1.1
                this._checkpointStore = checkpointStoreOrEventHubNameOrOptions3;
                this._userChoseCheckpointStore = true;
                eventHubClientOptions = checkpointStoreOrCredentialOrOptions4;
            }
            else {
                // 1
                this._checkpointStore = new InMemoryCheckpointStore();
                this._userChoseCheckpointStore = false;
                eventHubClientOptions = checkpointStoreOrEventHubNameOrOptions3;
            }
            this._eventHubClient = new EventHubClient(connectionStringOrFullyQualifiedNamespace2, eventHubClientOptions);
        }
    }
    /**
     * @property
     * @readonly
     * The name of the Event Hub instance for which this client is created.
     */
    get eventHubName() {
        return this._eventHubClient.eventHubName;
    }
    /**
     * @property
     * @readonly
     * The fully qualified namespace of the Event Hub instance for which this client is created.
     * This is likely to be similar to <yournamespace>.servicebus.windows.net.
     */
    get fullyQualifiedNamespace() {
        return this._eventHubClient.fullyQualifiedNamespace;
    }
    /**
     * Closes the AMQP connection to the Event Hub instance,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns Promise<void>
     * @throws Error if the underlying connection encounters an error while closing.
     */
    close() {
        return this._eventHubClient.close();
    }
    /**
     * Provides the id for each partition associated with the Event Hub.
     * @param options The set of options to apply to the operation call.
     * @returns A promise that resolves with an Array of strings representing the id for
     * each partition associated with the Event Hub.
     * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getPartitionIds(options = {}) {
        return this._eventHubClient.getPartitionIds(options);
    }
    /**
     * Provides information about the state of the specified partition.
     * @param partitionId The id of the partition for which information is required.
     * @param options The set of options to apply to the operation call.
     * @returns A promise that resolves with information about the state of the partition .
     * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getPartitionProperties(partitionId, options = {}) {
        return this._eventHubClient.getPartitionProperties(partitionId, options);
    }
    /**
     * Provides the Event Hub runtime information.
     * @param options The set of options to apply to the operation call.
     * @returns A promise that resolves with information about the Event Hub instance.
     * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getEventHubProperties(options = {}) {
        return this._eventHubClient.getProperties(options);
    }
    subscribe(handlersOrPartitionId1, optionsOrHandlers2, possibleOptions3) {
        let eventProcessor;
        let targetedPartitionId;
        if (isSubscriptionEventHandlers(handlersOrPartitionId1)) {
            // #1: subscribe overload - read from all partitions
            const options = optionsOrHandlers2;
            if (options && options.startPosition) {
                validateEventPositions(options.startPosition);
            }
            ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForAllPartitions(handlersOrPartitionId1, options));
        }
        else if (typeof handlersOrPartitionId1 === "string" &&
            isSubscriptionEventHandlers(optionsOrHandlers2)) {
            // #2: subscribe overload (read from specific partition IDs), don't coordinate
            const options = possibleOptions3;
            if (options && options.startPosition) {
                validateEventPositions(options.startPosition);
            }
            ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForSinglePartition(handlersOrPartitionId1, optionsOrHandlers2, possibleOptions3));
        }
        else {
            throw new TypeError("Unhandled subscribe() overload");
        }
        eventProcessor.start();
        return {
            get isRunning() {
                return eventProcessor.isRunning();
            },
            close: () => {
                this._partitionGate.remove(targetedPartitionId);
                return eventProcessor.stop();
            }
        };
    }
    createEventProcessorForAllPartitions(subscriptionEventHandlers, options) {
        this._partitionGate.add("all");
        if (this._userChoseCheckpointStore) {
            logger.verbose("EventHubConsumerClient subscribing to all partitions, using a checkpoint store.");
        }
        else {
            logger.verbose("EventHubConsumerClient subscribing to all partitions, no checkpoint store.");
        }
        const eventProcessor = this._createEventProcessor(this._consumerGroup, this._eventHubClient, subscriptionEventHandlers, this._checkpointStore, Object.assign(Object.assign(Object.assign({}, defaultConsumerClientOptions), options), { ownerLevel: getOwnerLevel(options, this._userChoseCheckpointStore), processingTarget: this._userChoseCheckpointStore
                ? undefined
                : new GreedyPartitionLoadBalancer(), 
            // make it so all the event processors process work with the same overarching owner ID
            // this allows the EventHubConsumer to unify all the work for any processors that it spawns
            ownerId: this._id }));
        return { targetedPartitionId: "all", eventProcessor };
    }
    createEventProcessorForSinglePartition(partitionId, eventHandlers, options) {
        this._partitionGate.add(partitionId);
        const subscribeOptions = options;
        if (this._userChoseCheckpointStore) {
            logger.verbose(`EventHubConsumerClient subscribing to specific partition (${partitionId}), using a checkpoint store.`);
        }
        else {
            logger.verbose(`EventHubConsumerClient subscribing to specific partition (${partitionId}), no checkpoint store.`);
        }
        const eventProcessor = this._createEventProcessor(this._consumerGroup, this._eventHubClient, eventHandlers, this._checkpointStore, Object.assign(Object.assign(Object.assign({}, defaultConsumerClientOptions), options), { processingTarget: partitionId, ownerLevel: getOwnerLevel(subscribeOptions, this._userChoseCheckpointStore) }));
        return { targetedPartitionId: partitionId, eventProcessor };
    }
    _createEventProcessor(consumerGroup, eventHubClient, subscriptionEventHandlers, checkpointStore, options) {
        return new EventProcessor(consumerGroup, eventHubClient, subscriptionEventHandlers, checkpointStore, options);
    }
}
/**
 * @property
 * The name of the default consumer group in the Event Hubs service.
 */
EventHubConsumerClient.defaultConsumerGroupName = coreAmqp.Constants.defaultConsumerGroup;
/**
 * @internal
 * @ignore
 */
function isCheckpointStore(possible) {
    if (!possible) {
        return false;
    }
    const checkpointStore = possible;
    return (typeof checkpointStore.claimOwnership === "function" &&
        typeof checkpointStore.listCheckpoints === "function" &&
        typeof checkpointStore.listOwnership === "function" &&
        typeof checkpointStore.updateCheckpoint === "function");
}
/**
 * @internal
 * @ignore
 */
function isSubscriptionEventHandlers(possible) {
    return typeof possible.processEvents === "function";
}
function getOwnerLevel(options, userChoseCheckpointStore) {
    if (options && options.ownerLevel) {
        return options.ownerLevel;
    }
    if (userChoseCheckpointStore) {
        return 0;
    }
    else {
        return undefined;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The `EventHubProducerClient` class is used to send events to an Event Hub.
 *
 * There are multiple ways to create an `EventHubProducerClient`
 * - Use the connection string from the SAS policy created for your Event Hub instance.
 * - Use the connection string from the SAS policy created for your Event Hub namespace,
 * and the name of the Event Hub instance
 * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.
 *
 * Optionally, you can also pass an options bag to configure the retry policy or proxy settings.
 *
 */
class EventHubProducerClient {
    constructor(fullyQualifiedNamespaceOrConnectionString1, eventHubNameOrOptions2, credentialOrOptions3, options4) {
        if (typeof eventHubNameOrOptions2 !== "string") {
            this._client = new EventHubClient(fullyQualifiedNamespaceOrConnectionString1, eventHubNameOrOptions2);
        }
        else if (!coreAmqp.isTokenCredential(credentialOrOptions3)) {
            this._client = new EventHubClient(fullyQualifiedNamespaceOrConnectionString1, eventHubNameOrOptions2, credentialOrOptions3);
        }
        else {
            this._client = new EventHubClient(fullyQualifiedNamespaceOrConnectionString1, eventHubNameOrOptions2, credentialOrOptions3, options4);
        }
        this._producersMap = new Map();
    }
    /**
     * @property
     * @readonly
     * The name of the Event Hub instance for which this client is created.
     */
    get eventHubName() {
        return this._client.eventHubName;
    }
    /**
     * @property
     * @readonly
     * The fully qualified namespace of the Event Hub instance for which this client is created.
     * This is likely to be similar to <yournamespace>.servicebus.windows.net.
     */
    get fullyQualifiedNamespace() {
        return this._client.fullyQualifiedNamespace;
    }
    /**
     * Creates an instance of `EventDataBatch` to which one can add events until the maximum supported size is reached.
     * The batch can be passed to the {@link sendBatch} method of the `EventHubProducerClient` to be sent to Azure Event Hubs.
     * @param options  Configures the behavior of the batch.
     * - `partitionKey`  : A value that is hashed and used by the Azure Event Hubs service to determine the partition to which
     * the events need to be sent.
     * - `partitionId`   : Id of the partition to which the batch of events need to be sent.
     * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.
     * - `abortSignal`   : A signal the request to cancel the operation.
     * @returns Promise<EventDataBatch>
     * @throws Error if both `partitionId` and `partitionKey` are set in the options.
     * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.
     * @throws AbortError if the operation is cancelled via the abortSignal in the options.
     */
    createBatch(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (options && options.partitionId && options.partitionKey) {
                throw new Error("partitionId and partitionKey cannot both be set when creating a batch");
            }
            let producer = this._producersMap.get("");
            if (!producer) {
                producer = this._client.createProducer();
                this._producersMap.set("", producer);
            }
            return producer.createBatch(options);
        });
    }
    /**
     * Sends a batch of events to the associated Event Hub.
     *
     * @param batch A batch of events that you can create using the {@link createBatch} method.
     * @param options A set of options that can be specified to influence the way in which
     * events are sent to the associated Event Hub.
     * - `abortSignal`  : A signal the request to cancel the send operation.
     *
     * @returns Promise<void>
     * @throws AbortError if the operation is cancelled via the abortSignal.
     * @throws MessagingError if an error is encountered while sending a message.
     * @throws Error if the underlying connection or sender has been closed.
     */
    sendBatch(batch, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let partitionId = "";
            if (batch.partitionId) {
                partitionId = batch.partitionId;
            }
            let producer = this._producersMap.get(partitionId);
            if (!producer) {
                producer = this._client.createProducer({
                    partitionId: partitionId === "" ? undefined : partitionId
                });
                this._producersMap.set(partitionId, producer);
            }
            return producer.send(batch, options);
        });
    }
    /**
     * Closes the AMQP connection to the Event Hub instance,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns Promise<void>
     * @throws Error if the underlying connection encounters an error while closing.
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            yield this._client.close();
            for (const pair of this._producersMap) {
                yield pair[1].close();
            }
            this._producersMap.clear();
        });
    }
    /**
     * Provides the Event Hub runtime information.
     * @param options The set of options to apply to the operation call.
     * @returns A promise that resolves with information about the Event Hub instance.
     * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getEventHubProperties(options = {}) {
        return this._client.getProperties(options);
    }
    /**
     * Provides the id for each partition associated with the Event Hub.
     * @param options The set of options to apply to the operation call.
     * @returns A promise that resolves with an Array of strings representing the id for
     * each partition associated with the Event Hub.
     * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getPartitionIds(options = {}) {
        return this._client.getPartitionIds(options);
    }
    /**
     * Provides information about the state of the specified partition.
     * @param partitionId The id of the partition for which information is required.
     * @param options The set of options to apply to the operation call.
     * @returns A promise that resolves with information about the state of the partition .
     * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getPartitionProperties(partitionId, options = {}) {
        return this._client.getPartitionProperties(partitionId, options);
    }
}

Object.defineProperty(exports, 'MessagingError', {
    enumerable: true,
    get: function () {
        return coreAmqp.MessagingError;
    }
});
exports.EventHubConsumerClient = EventHubConsumerClient;
exports.EventHubProducerClient = EventHubProducerClient;
exports.earliestEventPosition = earliestEventPosition;
exports.latestEventPosition = latestEventPosition;
exports.logger = logger;
//# sourceMappingURL=index.js.map
