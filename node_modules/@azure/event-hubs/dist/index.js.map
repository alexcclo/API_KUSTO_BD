{"version":3,"file":"index.js","sources":["../src/log.ts","../src/util/runtimeInfo.ts","../src/util/constants.ts","../../../../common/temp/node_modules/.pnpm/registry.npmjs.org/uuid/3.4.0/node_modules/uuid/lib/rng.js","../../../../common/temp/node_modules/.pnpm/registry.npmjs.org/uuid/3.4.0/node_modules/uuid/lib/bytesToUuid.js","../../../../common/temp/node_modules/.pnpm/registry.npmjs.org/uuid/3.4.0/node_modules/uuid/v4.js","../src/linkEntity.ts","../src/util/retries.ts","../src/managementClient.ts","../src/connectionContext.ts","../src/eventData.ts","../src/util/error.ts","../src/diagnostics/instrumentEventData.ts","../src/diagnostics/messageSpan.ts","../src/eventDataBatch.ts","../src/eventHubSender.ts","../src/util/operationOptions.ts","../src/sender.ts","../src/eventPosition.ts","../src/eventHubReceiver.ts","../src/receiveHandler.ts","../src/receiver.ts","../src/impl/eventHubClient.ts","../src/inMemoryCheckpointStore.ts","../src/models/public.ts","../src/partitionPump.ts","../src/pumpManager.ts","../src/partitionLoadBalancer.ts","../src/partitionProcessor.ts","../src/util/delayWithoutThrow.ts","../src/eventProcessor.ts","../src/impl/partitionGate.ts","../src/eventHubConsumerClient.ts","../src/eventHubProducerClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The @azure/logger configuration for this package.\n * This will output logs using the `azure:event-hubs` namespace prefix.\n */\nexport const logger = createClientLogger(\"event-hubs\");\n\n/**\n * Logs the error's stack trace to \"verbose\" if a stack trace is available.\n * @param error Error containing a stack trace.\n * @ignore\n */\nexport function logErrorStackTrace(error: any) {\n  if (error && error.stack) {\n    logger.verbose(error.stack);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport * as os from \"os\";\n\n/**\n * Returns information about the platform this function is being run on.\n * @ignore\n * @internal\n */\nexport function getRuntimeInfo(): string {\n  return `NODE-VERSION ${process.version}; ${os.type()} ${os.release()}`;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * @ignore\n */\nexport const packageJsonInfo = {\n  name: \"@azure/event-hubs\",\n  version: \"5.1.0\"\n};\n","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport {\n  defaultLock,\n  SharedKeyCredential,\n  AccessToken,\n  Constants,\n  TokenType\n} from \"@azure/core-amqp\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { AwaitableSender, Receiver } from \"rhea-promise\";\nimport { logger } from \"./log\";\n\n/**\n * @ignore\n */\nexport interface LinkEntityOptions {\n  /**\n   * @property [name] The unique name for the entity. If not provided then a guid will be\n   * assigned.\n   */\n  name?: string;\n  /**\n   * @property [partitionId] The partitionId associated with the link entity.\n   */\n  partitionId?: string;\n  /**\n   * @property address The link entity address in one of the following forms:\n   */\n  address?: string;\n  /**\n   * @property audience The link entity token audience in one of the following forms:\n   */\n  audience?: string;\n}\n\n/**\n * Describes the base class for entities like EventHub Sender, Receiver and Management link.\n * @internal\n * @ignore\n * @class LinkEntity\n */\nexport class LinkEntity {\n  /**\n   * @property [name] The unique name for the entity (mostly a guid).\n   */\n  name: string;\n  /**\n   * @property address The link entity address in one of the following forms:\n   *\n   * **Sender**\n   * - `\"<hubName>\"`\n   * - `\"<hubName>/Partitions/<partitionId>\"`.\n   *\n   * **Receiver**\n   * - `\"<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`.\n   *\n   * **ManagementClient**\n   * -`\"$management\"`.\n   */\n  address: string;\n  /**\n   * @property audience The link entity token audience in one of the following forms:\n   *\n   * **Sender**\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>\"`.\n   *\n   * **Receiver**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`.\n   *\n   * **ManagementClient**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management\"`.\n   */\n  audience: string;\n  /**\n   * @property [partitionId] The partitionId associated with the link entity.\n   */\n  partitionId?: string;\n  /**\n   * @property isConnecting Indicates whether the link is in the process of connecting\n   * (establishing) itself. Default value: `false`.\n   */\n  isConnecting: boolean = false;\n  /**\n   * @property _context Provides relevant information about the amqp connection,\n   * cbs and $management sessions, token provider, sender and receivers.\n   * @protected\n   */\n  protected _context: ConnectionContext;\n  /**\n   * @property _tokenRenewalTimer The token renewal timer that keeps track of when\n   * the Link Entity is due for token renewal.\n   * @protected\n   */\n  protected _tokenRenewalTimer?: NodeJS.Timer;\n  /**\n   * @property _tokenTimeout Indicates token timeout in milliseconds\n   * @protected\n   */\n  protected _tokenTimeoutInMs?: number;\n  /**\n   * Creates a new LinkEntity instance.\n   * @ignore\n   * @constructor\n   * @param context The connection context.\n   * @param [options] Options that can be provided while creating the LinkEntity.\n   */\n  constructor(context: ConnectionContext, options?: LinkEntityOptions) {\n    if (!options) options = {};\n    this._context = context;\n    this.address = options.address || \"\";\n    this.audience = options.audience || \"\";\n    this.name = `${options.name}-${uuid()}`;\n    this.partitionId = options.partitionId;\n  }\n\n  /**\n   * Negotiates cbs claim for the LinkEntity.\n   * @ignore\n   * @protected\n   * @param [setTokenRenewal] Set the token renewal timer. Default false.\n   * @returns Promise<void>\n   */\n  protected async _negotiateClaim(setTokenRenewal?: boolean): Promise<void> {\n    // Acquire the lock and establish a cbs session if it does not exist on the connection.\n    // Although node.js is single threaded, we need a locking mechanism to ensure that a\n    // race condition does not happen while creating a shared resource (in this case the\n    // cbs session, since we want to have exactly 1 cbs session per connection).\n    logger.verbose(\n      \"[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: \" +\n        \"'%s' with address: '%s'.\",\n      this._context.connectionId,\n      this._context.cbsSession.cbsLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    await defaultLock.acquire(this._context.cbsSession.cbsLock, () => {\n      return this._context.cbsSession.init();\n    });\n    let tokenObject: AccessToken;\n    let tokenType: TokenType;\n    if (this._context.tokenCredential instanceof SharedKeyCredential) {\n      tokenObject = this._context.tokenCredential.getToken(this.audience);\n      tokenType = TokenType.CbsTokenTypeSas;\n      // renew sas token in every 45 minutess\n      this._tokenTimeoutInMs = (3600 - 900) * 1000;\n    } else {\n      const aadToken = await this._context.tokenCredential.getToken(Constants.aadEventHubsScope);\n      if (!aadToken) {\n        throw new Error(`Failed to get token from the provided \"TokenCredential\" object`);\n      }\n      tokenObject = aadToken;\n      tokenType = TokenType.CbsTokenTypeJwt;\n      this._tokenTimeoutInMs = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;\n    }\n\n    logger.verbose(\n      \"[%s] %s: calling negotiateClaim for audience '%s'.\",\n      this._context.connectionId,\n      this._type,\n      this.audience\n    );\n    // Acquire the lock to negotiate the CBS claim.\n    logger.verbose(\n      \"[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.\",\n      this._context.connectionId,\n      this._context.negotiateClaimLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    await defaultLock.acquire(this._context.negotiateClaimLock, () => {\n      return this._context.cbsSession.negotiateClaim(this.audience, tokenObject, tokenType);\n    });\n    logger.verbose(\n      \"[%s] Negotiated claim for %s '%s' with with address: %s\",\n      this._context.connectionId,\n      this._type,\n      this.name,\n      this.address\n    );\n    if (setTokenRenewal) {\n      await this._ensureTokenRenewal();\n    }\n  }\n\n  /**\n   * Ensures that the token is renewed within the predefined renewal margin.\n   * @ignore\n   * @protected\n   * @returns\n   */\n  protected async _ensureTokenRenewal(): Promise<void> {\n    if (!this._tokenTimeoutInMs) {\n      return;\n    }\n    this._tokenRenewalTimer = setTimeout(async () => {\n      try {\n        await this._negotiateClaim(true);\n      } catch (err) {\n        logger.verbose(\n          \"[%s] %s '%s' with address %s, an error occurred while renewing the token: %O\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address,\n          err\n        );\n      }\n    }, this._tokenTimeoutInMs);\n    logger.verbose(\n      \"[%s] %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).\",\n      this._context.connectionId,\n      this._type,\n      this.name,\n      this.address,\n      this._tokenTimeoutInMs,\n      new Date(Date.now() + this._tokenTimeoutInMs).toString()\n    );\n  }\n\n  /**\n   * Closes the Sender|Receiver link and it's underlying session and also removes it from the\n   * internal map.\n   * @ignore\n   * @param [link] The Sender or Receiver link that needs to be closed and\n   * removed.\n   */\n  protected async _closeLink(link?: AwaitableSender | Receiver): Promise<void> {\n    clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n    if (link) {\n      try {\n        // Closing the link and its underlying session if the link is open. This should also\n        // remove them from the internal map.\n        await link.close();\n        logger.verbose(\n          \"[%s] %s '%s' with address '%s' closed.\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address\n        );\n      } catch (err) {\n        logger.verbose(\n          \"[%s] An error occurred while closing the %s '%s' with address '%s': %O\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address,\n          err\n        );\n      }\n    }\n  }\n\n  /**\n   * Provides the current type of the LinkEntity.\n   * @returns The entity type.\n   */\n  private get _type(): string {\n    let result = \"LinkEntity\";\n    if ((this as any).constructor && (this as any).constructor.name) {\n      result = (this as any).constructor.name;\n    }\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Constants, RetryOptions } from \"@azure/core-amqp\";\n\n/**\n * @internal\n * @ignore\n */\nexport function getRetryAttemptTimeoutInMs(retryOptions: RetryOptions | undefined): number {\n  const timeoutInMs =\n    retryOptions == undefined ||\n    typeof retryOptions.timeoutInMs !== \"number\" ||\n    !isFinite(retryOptions.timeoutInMs) ||\n    retryOptions.timeoutInMs < Constants.defaultOperationTimeoutInMs\n      ? Constants.defaultOperationTimeoutInMs\n      : retryOptions.timeoutInMs;\n  return timeoutInMs;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport {\n  RequestResponseLink,\n  defaultLock,\n  translate,\n  Constants,\n  SendRequestOptions,\n  retry,\n  RetryConfig,\n  RetryOptions,\n  RetryOperationType,\n  SharedKeyCredential\n} from \"@azure/core-amqp\";\nimport {\n  Message,\n  EventContext,\n  SenderEvents,\n  ReceiverEvents,\n  SenderOptions,\n  ReceiverOptions,\n  generate_uuid\n} from \"rhea-promise\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { logger, logErrorStackTrace } from \"./log\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { AbortSignalLike, AbortError } from \"@azure/abort-controller\";\n/**\n * Describes the runtime information of an Event Hub.\n * @interface HubRuntimeInformation\n */\nexport interface EventHubProperties {\n  /**\n   * @property The name of the event hub.\n   */\n  name: string;\n  /**\n   * @property The date and time the hub was created in UTC.\n   */\n  createdOn: Date;\n  /**\n   * @property The slice of string partition identifiers.\n   */\n  partitionIds: string[];\n}\n\n/**\n * Describes the runtime information of an EventHub Partition.\n * @interface PartitionProperties\n */\nexport interface PartitionProperties {\n  /**\n   * @property The name of the Event Hub.\n   */\n  eventHubName: string;\n  /**\n   * @property Identifier of the partition within the Event Hub.\n   */\n  partitionId: string;\n  /**\n   * @property The starting sequence number of the partition's message log.\n   */\n  beginningSequenceNumber: number;\n  /**\n   * @property The last sequence number of the partition's message log.\n   */\n  lastEnqueuedSequenceNumber: number;\n  /**\n   * @property The offset of the last enqueued message in the partition's message log.\n   */\n  lastEnqueuedOffset: number;\n  /**\n   * @property The time of the last enqueued message in the partition's message log in UTC.\n   */\n  lastEnqueuedOnUtc: Date;\n  /**\n   * @property Indicates whether the partition is empty.\n   */\n  isEmpty: boolean;\n}\n\n/**\n * @internal\n * @ignore\n */\nexport interface ManagementClientOptions {\n  address?: string;\n  audience?: string;\n}\n\n/**\n * @class ManagementClient\n * @internal\n * @ignore\n * Descibes the EventHubs Management Client that talks\n * to the $management endpoint over AMQP connection.\n */\nexport class ManagementClient extends LinkEntity {\n  readonly managementLock: string = `${Constants.managementRequestKey}-${uuid()}`;\n  /**\n   * @property entityPath - The name/path of the entity (hub name) for which the management\n   * request needs to be made.\n   */\n  entityPath: string;\n  /**\n   * @property replyTo The reply to Guid for the management client.\n   */\n  replyTo: string = uuid();\n  /**\n   * $management sender, receiver on the same session.\n   * @private\n   */\n  private _mgmtReqResLink?: RequestResponseLink;\n\n  /**\n   * Instantiates the management client.\n   * @constructor\n   * @ignore\n   * @param context The connection context.\n   * @param [address] The address for the management endpoint. For IotHub it will be\n   * `/messages/events/$management`.\n   */\n  constructor(context: ConnectionContext, options?: ManagementClientOptions) {\n    super(context, {\n      address: options && options.address ? options.address : Constants.management,\n      audience:\n        options && options.audience ? options.audience : context.config.getManagementAudience()\n    });\n    this._context = context;\n    this.entityPath = context.config.entityPath as string;\n  }\n\n  /**\n   * Gets the security token for the management application properties.\n   * @ignore\n   * @internal\n   */\n  async getSecurityToken() {\n    if (this._context.tokenCredential instanceof SharedKeyCredential) {\n      // the security_token has the $management address removed from the end of the audience\n      // expected audience: sb://fully.qualified.namespace/event-hub-name/$management\n      const audienceParts = this.audience.split(\"/\");\n      // for management links, address should be '$management'\n      if (audienceParts[audienceParts.length - 1] === this.address) {\n        audienceParts.pop();\n      }\n      const audience = audienceParts.join(\"/\");\n      return this._context.tokenCredential.getToken(audience);\n    }\n\n    // aad credentials use the aad scope\n    return this._context.tokenCredential.getToken(Constants.aadEventHubsScope);\n  }\n\n  /**\n   * Provides the eventhub runtime information.\n   * @ignore\n   * @param connection - The established amqp connection\n   * @returns\n   */\n  async getHubRuntimeInformation(options?: {\n    retryOptions?: RetryOptions;\n    abortSignal?: AbortSignalLike;\n  }): Promise<EventHubProperties> {\n    if (!options) {\n      options = {};\n    }\n    const securityToken = await this.getSecurityToken();\n    const request: Message = {\n      body: Buffer.from(JSON.stringify([])),\n      message_id: uuid(),\n      reply_to: this.replyTo,\n      application_properties: {\n        operation: Constants.readOperation,\n        name: this.entityPath as string,\n        type: `${Constants.vendorString}:${Constants.eventHub}`,\n        security_token: securityToken?.token\n      }\n    };\n\n    const info: any = await this._makeManagementRequest(request, {\n      ...options,\n      requestName: \"getHubRuntimeInformation\"\n    });\n    const runtimeInfo: EventHubProperties = {\n      name: info.name,\n      createdOn: new Date(info.created_at),\n      partitionIds: info.partition_ids\n    };\n    logger.verbose(\"[%s] The hub runtime info is: %O\", this._context.connectionId, runtimeInfo);\n    return runtimeInfo;\n  }\n\n  /**\n   * Provides an array of partitionIds.\n   * @ignore\n   * @param connection - The established amqp connection\n   * @returns\n   */\n  async getPartitionIds(): Promise<Array<string>> {\n    const runtimeInfo = await this.getHubRuntimeInformation();\n    return runtimeInfo.partitionIds;\n  }\n\n  /**\n   * Provides information about the specified partition.\n   * @ignore\n   * @param connection - The established amqp connection\n   * @param partitionId Partition ID for which partition information is required.\n   */\n  async getPartitionProperties(\n    partitionId: string,\n    options?: { retryOptions?: RetryOptions; abortSignal?: AbortSignalLike }\n  ): Promise<PartitionProperties> {\n    if (!options) {\n      options = {};\n    }\n    const securityToken = await this.getSecurityToken();\n    const request: Message = {\n      body: Buffer.from(JSON.stringify([])),\n      message_id: uuid(),\n      reply_to: this.replyTo,\n      application_properties: {\n        operation: Constants.readOperation,\n        name: this.entityPath as string,\n        type: `${Constants.vendorString}:${Constants.partition}`,\n        partition: `${partitionId}`,\n        security_token: securityToken?.token\n      }\n    };\n\n    const info: any = await this._makeManagementRequest(request, {\n      ...options,\n      requestName: \"getPartitionInformation\"\n    });\n\n    const partitionInfo: PartitionProperties = {\n      beginningSequenceNumber: info.begin_sequence_number,\n      eventHubName: info.name,\n      lastEnqueuedOffset: info.last_enqueued_offset,\n      lastEnqueuedOnUtc: new Date(info.last_enqueued_time_utc),\n      lastEnqueuedSequenceNumber: info.last_enqueued_sequence_number,\n      partitionId: info.partition,\n      isEmpty: info.is_partition_empty\n    };\n    logger.verbose(\"[%s] The partition info is: %O.\", this._context.connectionId, partitionInfo);\n    return partitionInfo;\n  }\n\n  /**\n   * Closes the AMQP management session to the Event Hub for this client,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @ignore\n   * @returns\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._isMgmtRequestResponseLinkOpen()) {\n        const mgmtLink = this._mgmtReqResLink;\n        this._mgmtReqResLink = undefined;\n        clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n        await mgmtLink!.close();\n        logger.info(\"Successfully closed the management session.\");\n      }\n    } catch (err) {\n      const msg = `An error occurred while closing the management session: ${err}`;\n      logger.warning(msg);\n      logErrorStackTrace(err);\n      throw new Error(msg);\n    }\n  }\n\n  private async _init(): Promise<void> {\n    try {\n      if (!this._isMgmtRequestResponseLinkOpen()) {\n        await this._negotiateClaim();\n        const rxopt: ReceiverOptions = {\n          source: { address: this.address },\n          name: this.replyTo,\n          target: { address: this.replyTo },\n          onSessionError: (context: EventContext) => {\n            const id = context.connection.options.id;\n            const ehError = translate(context.session!.error!);\n            logger.verbose(\n              \"[%s] An error occurred on the session for request/response links for \" +\n                \"$management: %O\",\n              id,\n              ehError\n            );\n          }\n        };\n        const sropt: SenderOptions = { target: { address: this.address } };\n        logger.verbose(\n          \"[%s] Creating sender/receiver links on a session for $management endpoint with \" +\n            \"srOpts: %o, receiverOpts: %O.\",\n          this._context.connectionId,\n          sropt,\n          rxopt\n        );\n        this._mgmtReqResLink = await RequestResponseLink.create(\n          this._context.connection,\n          sropt,\n          rxopt\n        );\n        this._mgmtReqResLink.sender.on(SenderEvents.senderError, (context: EventContext) => {\n          const id = context.connection.options.id;\n          const ehError = translate(context.sender!.error!);\n          logger.verbose(\"[%s] An error occurred on the $management sender link.. %O\", id, ehError);\n        });\n        this._mgmtReqResLink.receiver.on(ReceiverEvents.receiverError, (context: EventContext) => {\n          const id = context.connection.options.id;\n          const ehError = translate(context.receiver!.error!);\n          logger.verbose(\n            \"[%s] An error occurred on the $management receiver link.. %O\",\n            id,\n            ehError\n          );\n        });\n        logger.verbose(\n          \"[%s] Created sender '%s' and receiver '%s' links for $management endpoint.\",\n          this._context.connectionId,\n          this._mgmtReqResLink.sender.name,\n          this._mgmtReqResLink.receiver.name\n        );\n        await this._ensureTokenRenewal();\n      }\n    } catch (err) {\n      err = translate(err);\n      logger.warning(\n        \"[%s] An error occured while establishing the $management links: %O\",\n        this._context.connectionId,\n        err\n      );\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  /**\n   * @private\n   * Helper method to make the management request\n   * @param request The AMQP message to send\n   * @param options The options to use when sending a request over a $management link\n   */\n  private async _makeManagementRequest(\n    request: Message,\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n      requestName?: string;\n    } = {}\n  ): Promise<any> {\n    const retryOptions = options.retryOptions || {};\n    try {\n      const abortSignal: AbortSignalLike | undefined = options && options.abortSignal;\n\n      const sendOperationPromise = () =>\n        new Promise<Message>(async (resolve, reject) => {\n          let count = 0;\n\n          const retryTimeoutInMs = getRetryAttemptTimeoutInMs(options.retryOptions);\n          let timeTakenByInit = 0;\n\n          const rejectOnAbort = () => {\n            const requestName = options.requestName;\n            const desc: string =\n              `[${this._context.connectionId}] The request \"${requestName}\" ` +\n              `to has been cancelled by the user.`;\n            // Cancellation is user-intended behavior, so log to info instead of warning.\n            logger.info(desc);\n            const error = new AbortError(\n              `The ${requestName ? requestName + \" \" : \"\"}operation has been cancelled by the user.`\n            );\n\n            reject(error);\n          };\n\n          if (abortSignal) {\n            if (abortSignal.aborted) {\n              return rejectOnAbort();\n            }\n          }\n\n          if (!this._isMgmtRequestResponseLinkOpen()) {\n            logger.verbose(\n              \"[%s] Acquiring lock to get the management req res link.\",\n              this._context.connectionId\n            );\n\n            const initOperationStartTime = Date.now();\n\n            const actionAfterTimeout = () => {\n              const desc: string = `The request with message_id \"${request.message_id}\" timed out. Please try again later.`;\n              const e: Error = {\n                name: \"OperationTimeoutError\",\n                message: desc\n              };\n\n              return reject(translate(e));\n            };\n\n            const waitTimer = setTimeout(actionAfterTimeout, retryTimeoutInMs);\n\n            try {\n              await defaultLock.acquire(this.managementLock, () => {\n                return this._init();\n              });\n            } catch (err) {\n              return reject(translate(err));\n            } finally {\n              clearTimeout(waitTimer);\n            }\n            timeTakenByInit = Date.now() - initOperationStartTime;\n          }\n\n          const remainingOperationTimeoutInMs = retryTimeoutInMs - timeTakenByInit;\n\n          const sendRequestOptions: SendRequestOptions = {\n            abortSignal: options.abortSignal,\n            requestName: options.requestName,\n            timeoutInMs: remainingOperationTimeoutInMs\n          };\n\n          count++;\n          if (count !== 1) {\n            // Generate a new message_id every time after the first attempt\n            request.message_id = generate_uuid();\n          } else if (!request.message_id) {\n            // Set the message_id in the first attempt only if it is not set\n            request.message_id = generate_uuid();\n          }\n\n          try {\n            const result = await this._mgmtReqResLink!.sendRequest(request, sendRequestOptions);\n            resolve(result);\n          } catch (err) {\n            err = translate(err);\n            logger.warning(\n              \"[%s] An error occurred during send on management request-response link with address \" +\n                \"'%s': %O\",\n              this._context.connectionId,\n              this.address,\n              err\n            );\n            logErrorStackTrace(err);\n            reject(err);\n          }\n        });\n\n      const config: RetryConfig<Message> = {\n        operation: sendOperationPromise,\n        connectionId: this._context.connectionId,\n        operationType: RetryOperationType.management,\n        abortSignal: abortSignal,\n        retryOptions: retryOptions\n      };\n      return (await retry<Message>(config)).body;\n    } catch (err) {\n      err = translate(err);\n      logger.warning(\"An error occurred while making the request to $management endpoint: %O\", err);\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  private _isMgmtRequestResponseLinkOpen(): boolean {\n    return this._mgmtReqResLink! && this._mgmtReqResLink!.isOpen();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { logger } from \"./log\";\nimport { getRuntimeInfo } from \"./util/runtimeInfo\";\nimport { packageJsonInfo } from \"./util/constants\";\nimport { EventHubReceiver } from \"./eventHubReceiver\";\nimport { EventHubSender } from \"./eventHubSender\";\nimport {\n  Constants,\n  ConnectionContextBase,\n  CreateConnectionContextBaseParameters,\n  EventHubConnectionConfig,\n  TokenCredential,\n  SharedKeyCredential\n} from \"@azure/core-amqp\";\nimport { ManagementClient, ManagementClientOptions } from \"./managementClient\";\nimport { EventHubClientOptions } from \"./models/public\";\nimport { Dictionary, OnAmqpEvent, EventContext, ConnectionEvents } from \"rhea-promise\";\n\n/**\n * @interface ConnectionContext\n * @internal\n * @ignore\n * Provides contextual information like the underlying amqp connection, cbs session, management session,\n * tokenProvider, senders, receivers, etc. about the EventHub client.\n */\nexport interface ConnectionContext extends ConnectionContextBase {\n  /**\n   * @property config The EventHub connection config that is created after\n   * parsing the connection string.\n   */\n  readonly config: EventHubConnectionConfig;\n  /**\n   * @property wasConnectionCloseCalled Indicates whether the close() method was\n   * called on theconnection object.\n   */\n  wasConnectionCloseCalled: boolean;\n  /**\n   * @property receivers A dictionary of the EventHub Receivers associated with this client.\n   */\n  receivers: Dictionary<EventHubReceiver>;\n  /**\n   * @property senders A dictionary of the EventHub Senders associated with this client.\n   */\n  senders: Dictionary<EventHubSender>;\n  /**\n   * @property managementSession A reference to the management session ($management endpoint) on\n   * the underlying amqp connection for the EventHub Client.\n   */\n  managementSession?: ManagementClient;\n}\n\n/**\n * @internal\n * @ignore\n */\nexport interface ConnectionContextOptions extends EventHubClientOptions {\n  managementSessionAddress?: string;\n  managementSessionAudience?: string;\n}\n\n/**\n * @internal\n * @ignore\n */\nexport namespace ConnectionContext {\n  /**\n   * @property userAgent The user agent string for the EventHubs client.\n   * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk\n   */\n  const userAgent: string = `azsdk-js-azureeventhubs/${\n    packageJsonInfo.version\n  } (${getRuntimeInfo()})`;\n\n  export function getUserAgent(options: ConnectionContextOptions): string {\n    const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;\n    if (finalUserAgent.length > Constants.maxUserAgentLength) {\n      throw new Error(\n        `The user-agent string cannot be more than ${Constants.maxUserAgentLength} characters in length.` +\n          `The given user-agent string is: ${finalUserAgent} with length: ${finalUserAgent.length}`\n      );\n    }\n    return finalUserAgent;\n  }\n\n  export function create(\n    config: EventHubConnectionConfig,\n    tokenCredential: SharedKeyCredential | TokenCredential,\n    options?: ConnectionContextOptions\n  ): ConnectionContext {\n    if (!options) options = {};\n\n    config.webSocket = options.webSocketOptions && options.webSocketOptions.webSocket;\n    config.webSocketEndpointPath = \"$servicebus/websocket\";\n    config.webSocketConstructorOptions =\n      options.webSocketOptions && options.webSocketOptions.webSocketConstructorOptions;\n\n    const parameters: CreateConnectionContextBaseParameters = {\n      config: config,\n      tokenCredential: tokenCredential,\n      // re-enabling this will be a post-GA discussion.\n      // dataTransformer: options.dataTransformer,\n      isEntityPathRequired: true,\n      connectionProperties: {\n        product: \"MSJSClient\",\n        userAgent: getUserAgent(options),\n        version: packageJsonInfo.version\n      }\n    };\n    // Let us create the base context and then add EventHub specific ConnectionContext properties.\n    const connectionContext = ConnectionContextBase.create(parameters) as ConnectionContext;\n    connectionContext.wasConnectionCloseCalled = false;\n    connectionContext.senders = {};\n    connectionContext.receivers = {};\n    const mOptions: ManagementClientOptions = {\n      address: options.managementSessionAddress,\n      audience: options.managementSessionAudience\n    };\n    connectionContext.managementSession = new ManagementClient(connectionContext, mOptions);\n\n    // Define listeners to be added to the connection object for\n    // \"connection_open\" and \"connection_error\" events.\n    const onConnectionOpen: OnAmqpEvent = (context: EventContext) => {\n      connectionContext.wasConnectionCloseCalled = false;\n      logger.verbose(\n        \"[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.\",\n        connectionContext.connection.id,\n        connectionContext.wasConnectionCloseCalled\n      );\n    };\n\n    const disconnected: OnAmqpEvent = async (context: EventContext) => {\n      logger.verbose(\n        \"[%s] 'disconnected' event occurred on the amqp connection.\",\n        connectionContext.connection.id\n      );\n\n      if (context.connection && context.connection.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context.connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n      const state: Readonly<{\n        wasConnectionCloseCalled: boolean;\n        numSenders: number;\n        numReceivers: number;\n      }> = {\n        wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,\n        numSenders: Object.keys(connectionContext.senders).length,\n        numReceivers: Object.keys(connectionContext.receivers).length\n      };\n      logger.verbose(\n        \"[%s] Closing all open senders and receivers in the state: %O\",\n        connectionContext.connection.id,\n        state\n      );\n\n      // Clear internal map maintained by rhea to avoid reconnecting of old links once the\n      // connection is back up.\n      connectionContext.connection.removeAllSessions();\n\n      // Close the cbs session to ensure all the event handlers are released.\n      await connectionContext.cbsSession.close();\n      // Close the management session to ensure all the event handlers are released.\n      await connectionContext.managementSession!.close();\n\n      // Close all senders and receivers to ensure clean up of timers & other resources.\n      if (state.numSenders || state.numReceivers) {\n        for (const senderName of Object.keys(connectionContext.senders)) {\n          const sender = connectionContext.senders[senderName];\n          if (!sender.isConnecting) {\n            await sender.close().catch((err) => {\n              logger.verbose(\n                \"[%s] Error when closing sender [%s] after disconnected event: %O\",\n                connectionContext.connection.id,\n                senderName,\n                err\n              );\n            });\n          }\n        }\n        for (const receiverName of Object.keys(connectionContext.receivers)) {\n          const receiver = connectionContext.receivers[receiverName];\n          if (!receiver.isConnecting) {\n            await receiver.close().catch((err) => {\n              logger.verbose(\n                \"[%s] Error when closing sender [%s] after disconnected event: %O\",\n                connectionContext.connection.id,\n                receiverName,\n                err\n              );\n            });\n          }\n        }\n      }\n    };\n\n    const protocolError: OnAmqpEvent = async (context: EventContext) => {\n      logger.verbose(\n        \"[%s] 'protocol_error' event occurred on the amqp connection.\",\n        connectionContext.connection.id\n      );\n\n      if (context.connection && context.connection.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context.connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    const error: OnAmqpEvent = async (context: EventContext) => {\n      logger.verbose(\n        \"[%s] 'error' event occurred on the amqp connection.\",\n        connectionContext.connection.id\n      );\n\n      if (context.connection && context.connection.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context.connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    // Add listeners on the connection object.\n    connectionContext.connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);\n    connectionContext.connection.on(ConnectionEvents.disconnected, disconnected);\n    connectionContext.connection.on(ConnectionEvents.protocolError, protocolError);\n    connectionContext.connection.on(ConnectionEvents.error, error);\n\n    logger.verbose(\"[%s] Created connection context successfully.\", connectionContext.connectionId);\n    return connectionContext;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Message, MessageAnnotations, DeliveryAnnotations } from \"rhea-promise\";\nimport { Constants } from \"@azure/core-amqp\";\n\n/**\n * Describes the delivery annotations.\n * @interface EventHubDeliveryAnnotations\n * @ignore\n */\nexport interface EventHubDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * @property [last_enqueued_offset] The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * @property [last_enqueued_sequence_number] The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * @property [last_enqueued_time_utc] The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * @property [runtime_info_retrieval_time_utc] The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * @property Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * Map containing message attributes that will be held in the message header.\n * @interface EventHubMessageAnnotations\n * @ignore\n */\nexport interface EventHubMessageAnnotations extends MessageAnnotations {\n  /**\n   * @property [x-opt-partition-key] Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * @property [x-opt-sequence-number] Annontation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * @property [x-opt-enqueued-time] Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * @property [x-opt-offset] Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * @property Any other annotation that can be added to the message.\n   */\n  [x: string]: any;\n}\n\n/**\n * Describes the structure of an event to be sent or received from the EventHub.\n * @interface\n * @ignore\n */\nexport interface EventDataInternal {\n  /**\n   * @property body - The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * @property [enqueuedTimeUtc] The enqueued time of the event.\n   */\n  enqueuedTimeUtc?: Date;\n  /**\n   * @property [partitionKey] If specified EventHub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey?: string | null;\n  /**\n   * @property [offset] The offset of the event.\n   */\n  offset?: number;\n  /**\n   * @property [sequenceNumber] The sequence number of the event.\n   */\n  sequenceNumber?: number;\n  /**\n   * @property [properties] The application specific properties.\n   */\n  properties?: { [property: string]: any };\n  /**\n   * @property [lastSequenceNumber] The last sequence number of the event within the partition stream of the Event Hub.\n   */\n  lastSequenceNumber?: number;\n  /**\n   * @property [lastEnqueuedOffset] The offset of the last enqueued event.\n   */\n  lastEnqueuedOffset?: string;\n  /**\n   * @property [lastEnqueuedTime] The enqueued UTC time of the last event.\n   */\n  lastEnqueuedTime?: Date;\n  /**\n   * @property [retrievalTime] The time when the runtime info was retrieved\n   */\n  retrievalTime?: Date;\n  /**\n   * @property [systemProperties] The properties set by the service.\n   */\n  systemProperties?: { [property: string]: any };\n}\n\nconst messagePropertiesMap = {\n  message_id: \"messageId\",\n  user_id: \"userId\",\n  to: \"to\",\n  subject: \"subject\",\n  reply_to: \"replyTo\",\n  correlation_id: \"correlationId\",\n  content_type: \"contentType\",\n  content_encoding: \"contentEncoding\",\n  absolute_expiry_time: \"absoluteExpiryTime\",\n  creation_time: \"creationTime\",\n  group_id: \"groupId\",\n  group_sequence: \"groupSequence\",\n  reply_to_group_id: \"replyToGroupId\"\n} as const;\n\n/**\n * Converts the AMQP message to an EventData.\n * @param msg The AMQP message that needs to be converted to EventData.\n * @ignore\n */\nexport function fromAmqpMessage(msg: Message): EventDataInternal {\n  const data: EventDataInternal = {\n    body: msg.body\n  };\n\n  if (msg.message_annotations) {\n    for (const annotationKey of Object.keys(msg.message_annotations)) {\n      switch (annotationKey) {\n        case Constants.partitionKey:\n          data.partitionKey = msg.message_annotations[annotationKey];\n          break;\n        case Constants.sequenceNumber:\n          data.sequenceNumber = msg.message_annotations[annotationKey];\n          break;\n        case Constants.enqueuedTime:\n          data.enqueuedTimeUtc = new Date(msg.message_annotations[annotationKey]);\n          break;\n        case Constants.offset:\n          data.offset = msg.message_annotations[annotationKey];\n          break;\n        default:\n          if (!data.systemProperties) {\n            data.systemProperties = {};\n          }\n          data.systemProperties[annotationKey] = msg.message_annotations[annotationKey];\n          break;\n      }\n    }\n  }\n  if (msg.application_properties) {\n    data.properties = msg.application_properties;\n  }\n  if (msg.delivery_annotations) {\n    data.lastEnqueuedOffset = msg.delivery_annotations.last_enqueued_offset;\n    data.lastSequenceNumber = msg.delivery_annotations.last_enqueued_sequence_number;\n    data.lastEnqueuedTime = new Date(msg.delivery_annotations.last_enqueued_time_utc as number);\n    data.retrievalTime = new Date(\n      msg.delivery_annotations.runtime_info_retrieval_time_utc as number\n    );\n  }\n\n  const messageProperties = Object.keys(messagePropertiesMap) as Array<\n    keyof typeof messagePropertiesMap\n  >;\n  for (const messageProperty of messageProperties) {\n    if (!data.systemProperties) {\n      data.systemProperties = {};\n    }\n    if (msg[messageProperty] != null) {\n      data.systemProperties[messagePropertiesMap[messageProperty]] = msg[messageProperty];\n    }\n  }\n\n  return data;\n}\n\n/**\n * Converts an EventData object to an AMQP message.\n * @param data The EventData object that needs to be converted to an AMQP message.\n * @param partitionKey An optional key to determine the partition that this event should land in.\n * @ignore\n */\nexport function toAmqpMessage(data: EventData, partitionKey?: string): Message {\n  const msg: Message = {\n    body: data.body\n  };\n  // As per the AMQP 1.0 spec If the message-annotations or delivery-annotations section is omitted,\n  // it is equivalent to a message-annotations section containing anempty map of annotations.\n  msg.message_annotations = {};\n  if (data.properties) {\n    msg.application_properties = data.properties;\n  }\n  if (partitionKey != undefined) {\n    msg.message_annotations[Constants.partitionKey] = partitionKey;\n    // Event Hub service cannot route messages to a specific partition based on the partition key\n    // if AMQP message header is an empty object. Hence we make sure that header is always present\n    // with atleast one property. Setting durable to true, helps us achieve that.\n    msg.durable = true;\n  }\n\n  return msg;\n}\n\n/**\n * The interface that describes the data to be sent to Event Hub.\n * Use this as a reference when creating the object to be sent when using the `EventHubProducerClient`.\n * For example, `{ body: \"your-data\" }` or\n * ```\n * {\n *    body: \"your-data\",\n *    properties: {\n *       propertyName: \"property value\"\n *    }\n * }\n */\nexport interface EventData {\n  /**\n   * @property The message body that needs to be sent.\n   */\n  body: any;\n  /**\n   * @property Set of key value pairs that can be used to set properties specific to user application.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * The interface that describes the structure of the event received from Event Hub.\n * Use this as a reference when creating the `processEvents` function to process the events\n * recieved from an Event Hub when using the `EventHubConsumerClient`.\n */\nexport interface ReceivedEventData {\n  /**\n   * @property The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * @property The application specific properties.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n  /**\n   * @property The enqueued time of the event.\n   */\n  enqueuedTimeUtc: Date;\n  /**\n   * @property When specified Event Hub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey: string | null;\n  /**\n   * @property The offset of the event.\n   */\n  offset: number;\n  /**\n   * @property The sequence number of the event.\n   */\n  sequenceNumber: number;\n  /**\n   * @property The properties set by the service.\n   */\n  systemProperties?: {\n    [key: string]: any;\n  };\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { logger, logErrorStackTrace } from \"../log\";\nimport { ConnectionContext } from \"../connectionContext\";\n\n/**\n * @internal\n * @ignore\n * Logs and throws Error if the current AMQP connection is closed.\n * @param context The ConnectionContext associated with the current AMQP connection.\n */\nexport function throwErrorIfConnectionClosed(context: ConnectionContext): void {\n  if (context && context.wasConnectionCloseCalled) {\n    const errorMessage = \"The underlying AMQP connection is closed.\";\n    const error = new Error(errorMessage);\n    logger.warning(`[${context.connectionId}] %O`, error);\n    logErrorStackTrace(error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * @ignore\n * Logs and Throws TypeError if given parameter is undefined or null\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param methodName Name of the method that was passed the parameter\n * @param parameterName Name of the parameter to check\n * @param parameterValue Value of the parameter to check\n */\nexport function throwTypeErrorIfParameterMissing(\n  connectionId: string,\n  methodName: string,\n  parameterName: string,\n  parameterValue: any\n): void {\n  if (parameterValue === undefined || parameterValue === null) {\n    const error = new TypeError(\n      `${methodName} called without required argument \"${parameterName}\"`\n    );\n    logger.warning(`[${connectionId}] %O`, error);\n    logErrorStackTrace(error);\n    throw error;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getTraceParentHeader, extractSpanContextFromTraceParentHeader } from \"@azure/core-tracing\";\nimport { Span, SpanContext } from \"@opentelemetry/types\";\nimport { EventData } from \"../eventData\";\n\n/**\n * @ignore\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * Populates the `EventData` with `SpanContext` info to support trace propagation.\n * Creates and returns a copy of the passed in `EventData` unless the `EventData`\n * has already been instrumented.\n * @param eventData The `EventData` to instrument.\n * @param span The `Span` containing the context to propagate tracing information.\n * @ignore\n * @internal\n */\nexport function instrumentEventData(eventData: EventData, span: Span): EventData {\n  if (eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]) {\n    return eventData;\n  }\n\n  // create a copy so the original isn't modified\n  eventData = { ...eventData, properties: { ...eventData.properties } };\n\n  const traceParent = getTraceParentHeader(span.context());\n  if (traceParent) {\n    eventData.properties![TRACEPARENT_PROPERTY] = traceParent;\n  }\n\n  return eventData;\n}\n\n/**\n * Extracts the `SpanContext` from an `EventData` if the context exists.\n * @param eventData An individual `EventData` object.\n * @internal\n * @ignore\n */\nexport function extractSpanContextFromEventData(eventData: EventData): SpanContext | undefined {\n  if (!eventData.properties || !eventData.properties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = eventData.properties[TRACEPARENT_PROPERTY];\n  return extractSpanContextFromTraceParentHeader(diagnosticId);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getTracer } from \"@azure/core-tracing\";\nimport { Span, SpanContext, SpanKind } from \"@opentelemetry/types\";\n\n/**\n * @internal\n * @ignore\n */\nexport function createMessageSpan(parentSpan?: Span | SpanContext): Span {\n  const tracer = getTracer();\n  const span = tracer.startSpan(\"Azure.EventHubs.message\", {\n    kind: SpanKind.PRODUCER,\n    parent: parentSpan\n  });\n  span.setAttribute(\"az.namespace\", \"Microsoft.EventHub\");\n\n  return span;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventData, toAmqpMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { AmqpMessage } from \"@azure/core-amqp\";\nimport { message } from \"rhea-promise\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { Span, SpanContext } from \"@opentelemetry/types\";\nimport { instrumentEventData, TRACEPARENT_PROPERTY } from \"./diagnostics/instrumentEventData\";\nimport { createMessageSpan } from \"./diagnostics/messageSpan\";\n\n/**\n * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.\n * @param eventDataBatch The instance of `EventDataBatch` to verify.\n * @internal\n * @ignore\n */\nexport function isEventDataBatch(eventDataBatch: any): eventDataBatch is EventDataBatch {\n  return (\n    eventDataBatch &&\n    typeof eventDataBatch.tryAdd === \"function\" &&\n    typeof eventDataBatch.count === \"number\" &&\n    typeof eventDataBatch.sizeInBytes === \"number\"\n  );\n}\n\n/**\n * Options to configure the behavior of the `tryAdd` method on the `EventDataBatch` class.\n */\nexport interface TryAddOptions {\n  /**\n   * The `Span` or `SpanContext` to use as the `parent` of any spans created while adding events.\n   */\n  parentSpan?: Span | SpanContext;\n}\n\n/**\n * An interface representing a batch of events which can be used to send events to Event Hub.\n * \n * To create the batch, use the `createBatch()` method on the `EventHubProducerClient`.\n * To send the batch, use the `sendBatch()` method on the same client.\n * To fill the batch, use the `tryAdd()` method on the batch itself.\n * \n */\nexport interface EventDataBatch {\n  /**\n   * A value that is hashed and used by the Azure Event Hubs service to determine the partition to\n   * which the events are sent. Use the `createBatch()` method on the `EventHubProducerClient` to\n   * set the partitionKey.\n   * @readonly\n   * @internal\n   * @ignore\n   */\n  readonly partitionKey?: string;\n\n  /**\n   * Id of the partition to which the batch of events are sent. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the partitionId.\n   * @readonly\n   * @internal\n   * @ignore\n   */\n  readonly partitionId?: string;\n\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of events added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAdd` function on the batch will return `false`\n   * if the event being added causes the size of the batch to exceed this limit. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the maxSizeInBytes.\n   * @readonly.\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds an event to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  tryAdd(eventData: EventData, options?: TryAddOptions): boolean;\n\n  /**\n   * The AMQP message containing encoded events that were added to the batch.\n   * Used internally by the `sendBatch()` method on the `EventHubProducerClient`.\n   * This is not meant for the user to use directly.\n   * \n   * @readonly\n   * @internal\n   * @ignore\n   */\n  readonly _message: Buffer | undefined;\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * Used internally by the `sendBatch()` method to set up the right spans in traces if tracing is enabled.\n   * @internal\n   * @ignore\n   */\n  readonly _messageSpanContexts: SpanContext[];\n}\n\n/**\n * An internal class representing a batch of events which can be used to send events to Event Hub.\n * \n * @class\n * @internal\n * @ignore\n */\nexport class EventDataBatchImpl implements EventDataBatch {\n  /**\n   * @property Describes the amqp connection context for the Client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * @property A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  private _partitionKey?: string;\n  /**\n   * @property The maximum size allowed for the batch.\n   */\n  private _maxSizeInBytes: number;\n  /**\n   * @property Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * @property Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * @property Number of events in the batch.\n   */\n  private _count: number;\n  /**\n   * @property Encoded batch message.\n   */\n  private _batchMessage: Buffer | undefined;\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: SpanContext[] = [];\n\n  /**\n   * EventDataBatch should not be constructed using `new EventDataBatch()`\n   * Use the `createBatch()` method on your `EventHubProducer` instead.\n   * @constructor\n   * @internal\n   * @ignore\n   */\n  constructor(\n    context: ConnectionContext,\n    maxSizeInBytes: number,\n    partitionKey?: string,\n    private _partitionId?: string\n  ) {\n    this._context = context;\n    this._maxSizeInBytes = maxSizeInBytes;\n    this._partitionKey = partitionKey;\n    this._sizeInBytes = 0;\n    this._count = 0;\n  }\n\n  /**\n   * @property The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * @property The partitionKey set during `EventDataBatch` creation. This value is hashed to\n   * produce a partition assignment when the producer is created without a `partitionId`\n   * @readonly\n   */\n  get partitionKey(): string | undefined {\n    return this._partitionKey;\n  }\n\n  /**\n   * The partitionId set during `EventDataBatch` creation.\n   * If this value is set then partitionKey can not be set.\n   * @readonly\n   */\n  get partitionId(): string | undefined {\n    return this._partitionId;\n  }\n\n  /**\n   * @property Size of the `EventDataBatch` instance after the events added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * @property Number of events in the `EventDataBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * @property Represents the single AMQP message which is the result of encoding all the events\n   * added into the `EventDataBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  get _message(): Buffer | undefined {\n    return this._batchMessage;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * @internal\n   * @ignore\n   */\n  get _messageSpanContexts(): SpanContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Tries to add an event data to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  public tryAdd(eventData: EventData, options: TryAddOptions = {}): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"tryAdd\", \"eventData\", eventData);\n\n    // check if the event has already been instrumented\n    const previouslyInstrumented = Boolean(\n      eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]\n    );\n    if (!previouslyInstrumented) {\n      const messageSpan = createMessageSpan(options.parentSpan);\n      eventData = instrumentEventData(eventData, messageSpan);\n      this._spanContexts.push(messageSpan.context());\n      messageSpan.end();\n    }\n    // Convert EventData to AmqpMessage.\n    const amqpMessage = toAmqpMessage(eventData, this._partitionKey);\n    amqpMessage.body = this._context.dataTransformer.encode(eventData.body);\n\n    // Encode every amqp message and then convert every encoded message to amqp data section\n    this._encodedMessages.push(message.encode(amqpMessage));\n\n    const batchMessage: AmqpMessage = {\n      body: message.data_sections(this._encodedMessages)\n    };\n\n    if (amqpMessage.message_annotations) {\n      batchMessage.message_annotations = amqpMessage.message_annotations;\n    }\n\n    const encodedBatchMessage = message.encode(batchMessage);\n    const currentSize = encodedBatchMessage.length;\n\n    // this._batchMessage will be used for final send operation\n    if (currentSize > this._maxSizeInBytes) {\n      this._encodedMessages.pop();\n      if (\n        !previouslyInstrumented &&\n        Boolean(eventData.properties && eventData.properties[TRACEPARENT_PROPERTY])\n      ) {\n        this._spanContexts.pop();\n      }\n      return false;\n    }\n    this._batchMessage = encodedBatchMessage;\n    this._sizeInBytes = currentSize;\n    this._count++;\n    return true;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport { logger, logErrorStackTrace } from \"./log\";\nimport {\n  AwaitableSender,\n  EventContext,\n  OnAmqpEvent,\n  AwaitableSenderOptions,\n  message,\n  AmqpError\n} from \"rhea-promise\";\nimport {\n  defaultLock,\n  retry,\n  translate,\n  AmqpMessage,\n  ErrorNameConditionMapper,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  Constants\n} from \"@azure/core-amqp\";\nimport { EventData, toAmqpMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { EventHubProducerOptions } from \"./models/private\";\nimport { SendOptions } from \"./models/public\";\n\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { AbortSignalLike, AbortError } from \"@azure/abort-controller\";\nimport { EventDataBatch, isEventDataBatch } from \"./eventDataBatch\";\n\n/**\n * Describes the EventHubSender that will send event data to EventHub.\n * @class EventHubSender\n * @internal\n * @ignore\n */\nexport class EventHubSender extends LinkEntity {\n  /**\n   * @property senderLock The unqiue lock name per connection that is used to acquire the\n   * lock for establishing a sender link by an entity on that connection.\n   * @readonly\n   */\n  readonly senderLock: string = `sender-${uuid()}`;\n  /**\n   * @property _onAmqpError The handler function to handle errors that happen on the\n   * underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpError: OnAmqpEvent;\n  /**\n   * @property _onAmqpClose The handler function to handle \"sender_close\" event\n   * that happens on the underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpClose: OnAmqpEvent;\n  /**\n   * @property _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_error\" event.\n   * @private\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * @property _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_close\" event.\n   * @private\n   */\n  private _onSessionClose: OnAmqpEvent;\n  /**\n   * @property [_sender] The AMQP sender link.\n   * @private\n   */\n  private _sender?: AwaitableSender;\n\n  /**\n   * Creates a new EventHubSender instance.\n   * @ignore\n   * @constructor\n   * @param context The connection context.\n   * @param [partitionId] The EventHub partition id to which the sender\n   * wants to send the event data.\n   */\n  constructor(context: ConnectionContext, partitionId?: string) {\n    super(context, {\n      name: context.config.getSenderAddress(partitionId),\n      partitionId: partitionId\n    });\n    this.address = context.config.getSenderAddress(partitionId);\n    this.audience = context.config.getSenderAudience(partitionId);\n\n    this._onAmqpError = (context: EventContext) => {\n      const senderError = context.sender && context.sender.error;\n      logger.verbose(\n        \"[%s] 'sender_error' event occurred on the sender '%s' with address '%s'. \" +\n          \"The associated error is: %O\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        senderError\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n      logger.verbose(\n        \"[%s] 'session_error' event occurred on the session of sender '%s' with address '%s'. \" +\n          \"The associated error is: %O\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        sessionError\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const sender = this._sender || context.sender!;\n      logger.verbose(\n        \"[%s] 'sender_close' event occurred on the sender '%s' with address '%s'. \" +\n          \"Value for isItselfClosed on the receiver is: '%s' \" +\n          \"Value for isConnecting on the session is: '%s'.\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        sender ? sender.isItselfClosed().toString() : undefined,\n        this.isConnecting\n      );\n      if (sender && !this.isConnecting) {\n        // Call close to clean up timers & other resources\n        await sender.close().catch((err) => {\n          logger.verbose(\n            \"[%s] Error when closing sender [%s] after 'sender_close' event: %O\",\n            this._context.connectionId,\n            this.name,\n            err\n          );\n        });\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const sender = this._sender || context.sender!;\n      logger.verbose(\n        \"[%s] 'session_close' event occurred on the session of sender '%s' with address '%s'. \" +\n          \"Value for isSessionItselfClosed on the session is: '%s' \" +\n          \"Value for isConnecting on the session is: '%s'.\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        sender ? sender.isSessionItselfClosed().toString() : undefined,\n        this.isConnecting\n      );\n      if (sender && !this.isConnecting) {\n        // Call close to clean up timers & other resources\n        await sender.close().catch((err) => {\n          logger.verbose(\n            \"[%s] Error when closing sender [%s] after 'session_close' event: %O\",\n            this._context.connectionId,\n            this.name,\n            err\n          );\n        });\n      }\n    };\n  }\n\n  /**\n   * Deletes the sender fromt the context. Clears the token renewal timer. Closes the sender link.\n   * @ignore\n   * @returns Promise<void>\n   */\n  async close(): Promise<void> {\n    if (this._sender) {\n      logger.info(\n        \"[%s] Closing the Sender for the entity '%s'.\",\n        this._context.connectionId,\n        this._context.config.entityPath\n      );\n      const senderLink = this._sender;\n      this._deleteFromCache();\n      await this._closeLink(senderLink);\n    }\n  }\n\n  /**\n   * Determines whether the AMQP sender link is open. If open then returns true else returns false.\n   * @ignore\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result: boolean = this._sender! && this._sender!.isOpen();\n    logger.verbose(\n      \"[%s] Sender '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n  /**\n   * Returns maximum message size on the AMQP sender link.\n   * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   * @returns Promise<number>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  async getMaxMessageSize(\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n    } = {}\n  ): Promise<number> {\n    const abortSignal = options.abortSignal;\n    const retryOptions = options.retryOptions || {};\n    if (this.isOpen()) {\n      return this._sender!.maxMessageSize;\n    }\n    return new Promise<number>(async (resolve, reject) => {\n      const rejectOnAbort = () => {\n        const desc: string = `[${this._context.connectionId}] The create batch operation has been cancelled by the user.`;\n        // Cancellation is user-intented, so treat as info instead of warning.\n        logger.info(desc);\n        const error = new AbortError(`The create batch operation has been cancelled by the user.`);\n        reject(error);\n      };\n\n      const onAbort = () => {\n        if (abortSignal) {\n          abortSignal.removeEventListener(\"abort\", onAbort);\n        }\n        rejectOnAbort();\n      };\n\n      if (abortSignal) {\n        // the aborter may have been triggered between request attempts\n        // so check if it was triggered and reject if needed.\n        if (abortSignal.aborted) {\n          return rejectOnAbort();\n        }\n        abortSignal.addEventListener(\"abort\", onAbort);\n      }\n      try {\n        logger.verbose(\n          \"Acquiring lock %s for initializing the session, sender and \" +\n            \"possibly the connection.\",\n          this.senderLock\n        );\n        const senderOptions = this._createSenderOptions(Constants.defaultOperationTimeoutInMs);\n        await defaultLock.acquire(this.senderLock, () => {\n          const config: RetryConfig<void> = {\n            operation: () => this._init(senderOptions),\n            connectionId: this._context.connectionId,\n            operationType: RetryOperationType.senderLink,\n            abortSignal: abortSignal,\n            retryOptions: retryOptions\n          };\n\n          return retry<void>(config);\n        });\n        resolve(this._sender!.maxMessageSize);\n      } catch (err) {\n        logger.warning(\n          \"[%s] An error occurred while creating the sender %s\",\n          this._context.connectionId,\n          this.name\n        );\n        logErrorStackTrace(err);\n        reject(err);\n      } finally {\n        if (abortSignal) {\n          abortSignal.removeEventListener(\"abort\", onAbort);\n        }\n      }\n    });\n  }\n\n  /**\n   * Send a batch of EventData to the EventHub. The \"message_annotations\",\n   * \"application_properties\" and \"properties\" of the first message will be set as that\n   * of the envelope (batch message).\n   * @ignore\n   * @param events  An array of EventData objects to be sent in a Batch message.\n   * @param options Options to control the way the events are batched along with request options\n   * @return Promise<void>\n   */\n  async send(\n    events: EventData[] | EventDataBatch,\n    options?: SendOptions & EventHubProducerOptions\n  ): Promise<void> {\n    try {\n      // throw an error if partition key and partition id are both defined\n      if (\n        options &&\n        typeof options.partitionKey === \"string\" &&\n        typeof options.partitionId === \"string\"\n      ) {\n        const error = new Error(\n          \"Partition key is not supported when using producers that were created using a partition id.\"\n        );\n        logger.warning(\n          \"[%s] Partition key is not supported when using producers that were created using a partition id. %O\",\n          this._context.connectionId,\n          error\n        );\n        logErrorStackTrace(error);\n        throw error;\n      }\n\n      // throw an error if partition key is different than the one provided in the options.\n      if (isEventDataBatch(events) && options && options.partitionKey) {\n        const error = new Error(\n          \"Partition key is not supported when sending a batch message. Pass the partition key when creating the batch message instead.\"\n        );\n        logger.warning(\n          \"[%s] Partition key is not supported when sending a batch message. Pass the partition key when creating the batch message instead. %O\",\n          this._context.connectionId,\n          error\n        );\n        logErrorStackTrace(error);\n        throw error;\n      }\n\n      logger.info(\n        \"[%s] Sender '%s', trying to send EventData[].\",\n        this._context.connectionId,\n        this.name\n      );\n\n      let encodedBatchMessage: Buffer | undefined;\n      if (isEventDataBatch(events)) {\n        encodedBatchMessage = events._message!;\n      } else {\n        const partitionKey = (options && options.partitionKey) || undefined;\n        const messages: AmqpMessage[] = [];\n        // Convert EventData to AmqpMessage.\n        for (let i = 0; i < events.length; i++) {\n          const message = toAmqpMessage(events[i], partitionKey);\n          message.body = this._context.dataTransformer.encode(events[i].body);\n          messages[i] = message;\n        }\n        // Encode every amqp message and then convert every encoded message to amqp data section\n        const batchMessage: AmqpMessage = {\n          body: message.data_sections(messages.map(message.encode))\n        };\n\n        // Set message_annotations of the first message as\n        // that of the envelope (batch message).\n        if (messages[0].message_annotations) {\n          batchMessage.message_annotations = messages[0].message_annotations;\n        }\n\n        // Finally encode the envelope (batch message).\n        encodedBatchMessage = message.encode(batchMessage);\n      }\n      logger.info(\n        \"[%s] Sender '%s', sending encoded batch message.\",\n        this._context.connectionId,\n        this.name,\n        encodedBatchMessage\n      );\n      return await this._trySendBatch(encodedBatchMessage, options);\n    } catch (err) {\n      logger.warning(\"An error occurred while sending the batch message %O\", err);\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  private _deleteFromCache(): void {\n    this._sender = undefined;\n    delete this._context.senders[this.name];\n    logger.verbose(\n      \"[%s] Deleted the sender '%s' with address '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name,\n      this.address\n    );\n  }\n\n  private _createSenderOptions(timeoutInMs: number, newName?: boolean): AwaitableSenderOptions {\n    if (newName) this.name = `${uuid()}`;\n    const srOptions: AwaitableSenderOptions = {\n      name: this.name,\n      target: {\n        address: this.address\n      },\n      onError: this._onAmqpError,\n      onClose: this._onAmqpClose,\n      onSessionError: this._onSessionError,\n      onSessionClose: this._onSessionClose,\n      sendTimeoutInSeconds: timeoutInMs / 1000\n    };\n    logger.verbose(\"Creating sender with options: %O\", srOptions);\n    return srOptions;\n  }\n\n  /**\n   * Tries to send the message to EventHub if there is enough credit to send them\n   * and the circular buffer has available space to settle the message after sending them.\n   *\n   * We have implemented a synchronous send over here in the sense that we shall be waiting\n   * for the message to be accepted or rejected and accordingly resolve or reject the promise.\n   * @ignore\n   * @param message The message to be sent to EventHub.\n   * @returns Promise<void>\n   */\n  private _trySendBatch(\n    message: AmqpMessage | Buffer,\n    options: SendOptions & EventHubProducerOptions = {}\n  ): Promise<void> {\n    const abortSignal: AbortSignalLike | undefined = options.abortSignal;\n    const retryOptions = options.retryOptions || {};\n    const sendEventPromise = () =>\n      new Promise<void>(async (resolve, reject) => {\n        const rejectOnAbort = () => {\n          const desc: string =\n            `[${this._context.connectionId}] The send operation on the Sender \"${this.name}\" with ` +\n            `address \"${this.address}\" has been cancelled by the user.`;\n          // Cancellation is user-intended, so log to info instead of warning.\n          logger.info(desc);\n          return reject(new AbortError(\"The send operation has been cancelled by the user.\"));\n        };\n\n        if (abortSignal && abortSignal.aborted) {\n          // operation has been cancelled, so exit quickly\n          return rejectOnAbort();\n        }\n\n        const removeListeners = (): void => {\n          clearTimeout(waitTimer);\n          if (abortSignal) {\n            abortSignal.removeEventListener(\"abort\", onAborted);\n          }\n        };\n\n        const onAborted = () => {\n          removeListeners();\n          return rejectOnAbort();\n        };\n\n        if (abortSignal) {\n          abortSignal.addEventListener(\"abort\", onAborted);\n        }\n\n        const actionAfterTimeout = () => {\n          removeListeners();\n          const desc: string =\n            `[${this._context.connectionId}] Sender \"${this.name}\" with ` +\n            `address \"${this.address}\", was not able to send the message right now, due ` +\n            `to operation timeout.`;\n          logger.warning(desc);\n          const e: Error = {\n            name: \"OperationTimeoutError\",\n            message: desc\n          };\n          return reject(translate(e));\n        };\n\n        const waitTimer = setTimeout(\n          actionAfterTimeout,\n          getRetryAttemptTimeoutInMs(options.retryOptions)\n        );\n\n        if (!this.isOpen()) {\n          logger.verbose(\n            \"Acquiring lock %s for initializing the session, sender and \" +\n              \"possibly the connection.\",\n            this.senderLock\n          );\n\n          try {\n            const senderOptions = this._createSenderOptions(\n              getRetryAttemptTimeoutInMs(options.retryOptions)\n            );\n            await defaultLock.acquire(this.senderLock, () => {\n              return this._init(senderOptions);\n            });\n          } catch (err) {\n            removeListeners();\n            err = translate(err);\n            logger.warning(\n              \"[%s] An error occurred while creating the sender %s\",\n              this._context.connectionId,\n              this.name,\n              err\n            );\n            logErrorStackTrace(err);\n            return reject(err);\n          }\n        }\n\n        logger.verbose(\n          \"[%s] Sender '%s', credit: %d available: %d\",\n          this._context.connectionId,\n          this.name,\n          this._sender!.credit,\n          this._sender!.session.outgoing.available()\n        );\n        if (this._sender!.sendable()) {\n          logger.verbose(\n            \"[%s] Sender '%s', sending message with id '%s'.\",\n            this._context.connectionId,\n            this.name\n          );\n\n          try {\n            const delivery = await this._sender!.send(message, undefined, 0x80013700);\n            logger.info(\n              \"[%s] Sender '%s', sent message with delivery id: %d\",\n              this._context.connectionId,\n              this.name,\n              delivery.id\n            );\n            return resolve();\n          } catch (err) {\n            err = translate(err.innerError || err);\n            logger.warning(\n              \"[%s] An error occurred while sending the message\",\n              this._context.connectionId,\n              err\n            );\n            logErrorStackTrace(err);\n            return reject(err);\n          } finally {\n            removeListeners();\n          }\n        } else {\n          // let us retry to send the message after some time.\n          const msg =\n            `[${this._context.connectionId}] Sender \"${this.name}\", ` +\n            `cannot send the message right now. Please try later.`;\n          logger.warning(msg);\n          const amqpError: AmqpError = {\n            condition: ErrorNameConditionMapper.SenderBusyError,\n            description: msg\n          };\n          reject(translate(amqpError));\n        }\n      });\n\n    const config: RetryConfig<void> = {\n      operation: sendEventPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.sendMessage,\n      abortSignal: abortSignal,\n      retryOptions: retryOptions\n    };\n    return retry<void>(config);\n  }\n\n  /**\n   * Initializes the sender session on the connection.\n   * @ignore\n   * @returns\n   */\n  private async _init(options: AwaitableSenderOptions): Promise<void> {\n    try {\n      if (!this.isOpen() && !this.isConnecting) {\n        this.isConnecting = true;\n        await this._negotiateClaim();\n\n        logger.verbose(\n          \"[%s] Trying to create sender '%s'...\",\n          this._context.connectionId,\n          this.name\n        );\n\n        this._sender = await this._context.connection.createAwaitableSender(options);\n        this.isConnecting = false;\n        logger.verbose(\n          \"[%s] Sender '%s' created with sender options: %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        this._sender.setMaxListeners(1000);\n\n        // It is possible for someone to close the sender and then start it again.\n        // Thus make sure that the sender is present in the client cache.\n        if (!this._context.senders[this.name]) this._context.senders[this.name] = this;\n        await this._ensureTokenRenewal();\n      } else {\n        logger.verbose(\n          \"[%s] The sender '%s' with address '%s' is open -> %s and is connecting \" +\n            \"-> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err) {\n      this.isConnecting = false;\n      err = translate(err);\n      logger.warning(\n        \"[%s] An error occurred while creating the sender %s\",\n        this._context.connectionId,\n        this.name,\n        err\n      );\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Creates a new sender to the given event hub, and optionally to a given partition if it is\n   * not present in the context or returns the one present in the context.\n   * @ignore\n   * @static\n   * @param [partitionId] Partition ID to which it will send event data.\n   * @returns\n   */\n  static create(context: ConnectionContext, partitionId?: string): EventHubSender {\n    const ehSender: EventHubSender = new EventHubSender(context, partitionId);\n    if (!context.senders[ehSender.name]) {\n      context.senders[ehSender.name] = ehSender;\n    }\n    return context.senders[ehSender.name];\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { Span, SpanContext, SpanOptions } from \"@opentelemetry/types\";\n\n/**\n * Options for configuring tracing.\n */\nexport interface TracingOptions {\n  /**\n   * Options for configuring tracing.\n   */\n  tracingOptions?: {\n    /**\n     * OpenTelemetry SpanOptions used to create a span when tracing is enabled.\n     */\n    spanOptions?: SpanOptions;\n  };\n}\n\n/**\n * Options for configuring tracing and the abortSignal.\n */\n// NOTE: This class is intended to mirror the relevant fields and structure from\n// @azure/core-http OperationOptions\nexport interface OperationOptions extends TracingOptions {\n  /**\n   * The signal which can be used to abort requests.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * @internal\n * @ignore\n */\nexport function getParentSpan(\n  options: Pick<OperationOptions, \"tracingOptions\">\n): Span | SpanContext | undefined {\n  return (\n    options &&\n    options.tracingOptions &&\n    options.tracingOptions.spanOptions &&\n    options.tracingOptions.spanOptions.parent\n  );\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventData } from \"./eventData\";\nimport { EventHubSender } from \"./eventHubSender\";\nimport { EventHubProducerOptions } from \"../src/models/private\";\nimport { SendOptions, CreateBatchOptions } from \"../src/models/public\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { logger, logErrorStackTrace } from \"./log\";\nimport { throwErrorIfConnectionClosed, throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { EventDataBatch, isEventDataBatch, EventDataBatchImpl } from \"./eventDataBatch\";\nimport { getTracer } from \"@azure/core-tracing\";\nimport { SpanContext, Span, SpanKind, CanonicalCode, Link } from \"@opentelemetry/types\";\nimport { instrumentEventData, TRACEPARENT_PROPERTY } from \"./diagnostics/instrumentEventData\";\nimport { createMessageSpan } from \"./diagnostics/messageSpan\";\nimport { getParentSpan } from \"./util/operationOptions\";\n\n/**\n * A producer responsible for sending events to an Event Hub.\n * To create a producer use the `createProducer()` method on your `EventHubClient`.\n * You can pass the below in the `options` when creating a producer.\n * - `partitionId`  : The identifier of the partition that the producer can be bound to.\n * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * If `partitionId` is specified when creating a producer, all event data sent using the producer\n * will be sent to the specified partition.\n * Otherwise, they are automatically routed to an available partition by the Event Hubs service.\n *\n * Automatic routing of partitions is recommended because:\n *  - The sending of events will be highly available.\n *  - The event data will be evenly distributed among all available partitions.\n *\n * @class\n * @internal\n * @ignore\n */\nexport class EventHubProducer {\n  /**\n   * @property Describes the amqp connection context for the Client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * @property Denotes if close() was called on this sender\n   */\n  private _isClosed: boolean = false;\n\n  private _senderOptions: EventHubProducerOptions;\n\n  private _eventHubSender: EventHubSender | undefined;\n\n  private _eventHubName: string;\n  private _endpoint: string;\n\n  /**\n   * @property Returns `true` if either the producer or the client that created it has been closed.\n   * @readonly\n   */\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  /**\n   * EventHubProducer should not be constructed using `new EventHubProduer()`\n   * Use the `createProducer()` method on your `EventHubClient` instead.\n   * @private\n   * @constructor\n   * @internal\n   * @ignore\n   */\n  constructor(\n    eventHubName: string,\n    endpoint: string,\n    context: ConnectionContext,\n    options?: EventHubProducerOptions\n  ) {\n    this._context = context;\n    this._senderOptions = options || {};\n    const partitionId =\n      this._senderOptions.partitionId != undefined\n        ? String(this._senderOptions.partitionId)\n        : undefined;\n    this._eventHubSender = EventHubSender.create(this._context, partitionId);\n    this._eventHubName = eventHubName;\n    this._endpoint = endpoint;\n  }\n\n  /**\n   * Creates an instance of `EventDataBatch` to which one can add events until the maximum supported size is reached.\n   * The batch can be passed to the `send()` method of the `EventHubProducer` to be sent to Azure Event Hubs.\n   * @param options  A set of options to configure the behavior of the batch.\n   * - `partitionKey`  : A value that is hashed to produce a partition assignment.\n   * Not applicable if the `EventHubProducer` was created using a `partitionId`.\n   * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   * - `abortSignal`   : A signal the request to cancel the send operation.\n   * @returns Promise<EventDataBatch>\n   */\n  async createBatch(options?: CreateBatchOptions): Promise<EventDataBatch> {\n    this._throwIfSenderOrConnectionClosed();\n    if (!options) {\n      options = {};\n    }\n    // throw an error if partition key and partition id are both defined\n    if (\n      typeof options.partitionKey === \"string\" &&\n      typeof this._senderOptions.partitionId === \"string\"\n    ) {\n      const error = new Error(\n        \"Creating a batch with partition key is not supported when using producers that were created using a partition id.\"\n      );\n      logger.warning(\n        \"[%s] Creating a batch with partition key is not supported when using producers that were created using a partition id. %O\",\n        this._context.connectionId,\n        error\n      );\n      logErrorStackTrace(error);\n      throw error;\n    }\n\n    let maxMessageSize = await this._eventHubSender!.getMaxMessageSize({\n      retryOptions: this._senderOptions.retryOptions,\n      abortSignal: options.abortSignal\n    });\n    if (options.maxSizeInBytes) {\n      if (options.maxSizeInBytes > maxMessageSize) {\n        const error = new Error(\n          `Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`\n        );\n        logger.warning(\n          `[${this._context.connectionId}] Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link. ${error}`\n        );\n        logErrorStackTrace(error);\n        throw error;\n      }\n      maxMessageSize = options.maxSizeInBytes;\n    }\n    return new EventDataBatchImpl(\n      this._context,\n      maxMessageSize,\n      options.partitionKey,\n      options.partitionId\n    );\n  }\n\n  /**\n   * Send one or more of events to the associated Event Hub.\n   *\n   * @param eventData  An individual `EventData` object, or an array of `EventData` objects or an\n   * instance of `EventDataBatch`.\n   * @param options The set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `partitionKey` : A value that is hashed to produce a partition assignment.\n   * Not applicable if the `EventHubProducer` was created using a `partitionId`.\n   * - `abortSignal`  : A signal the request to cancel the send operation.\n   *\n   * @returns Promise<void>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while sending a message.\n   * @throws TypeError if a required parameter is missing.\n   * @throws Error if the underlying connection or sender has been closed.\n   * @throws Error if a partitionKey is provided when the producer was created with a partitionId.\n   * @throws Error if batch was created with partitionKey different than the one provided in the options.\n   * Create a new producer using the EventHubClient createProducer method.\n   */\n  async send(\n    eventData: EventData | EventData[] | EventDataBatch,\n    options: SendOptions = {}\n  ): Promise<void> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"send\", \"eventData\", eventData);\n    if (Array.isArray(eventData) && eventData.length === 0) {\n      logger.info(`[${this._context.connectionId}] Empty array was passed. No events to send.`);\n      return;\n    }\n    if (isEventDataBatch(eventData) && eventData.count === 0) {\n      logger.info(`[${this._context.connectionId}] Empty batch was passsed. No events to send.`);\n      return;\n    }\n    if (!Array.isArray(eventData) && !isEventDataBatch(eventData)) {\n      eventData = [eventData];\n    }\n\n    // link message span contexts\n    let spanContextsToLink: SpanContext[] = [];\n    if (Array.isArray(eventData)) {\n      for (let i = 0; i < eventData.length; i++) {\n        const event = eventData[i];\n        if (!event.properties || !event.properties[TRACEPARENT_PROPERTY]) {\n          const messageSpan = createMessageSpan(getParentSpan(options));\n          // since these message spans are created from same context as the send span,\n          // these message spans don't need to be linked.\n          // replace the original event with the instrumented one\n          eventData[i] = instrumentEventData(eventData[i], messageSpan);\n          messageSpan.end();\n        }\n      }\n    } else if (isEventDataBatch(eventData)) {\n      spanContextsToLink = eventData._messageSpanContexts;\n    }\n\n    const sendSpan = this._createSendSpan(getParentSpan(options), spanContextsToLink);\n\n    try {\n      const result = await this._eventHubSender!.send(eventData, {\n        ...this._senderOptions,\n        ...options\n      });\n      sendSpan.setStatus({ code: CanonicalCode.OK });\n      return result;\n    } catch (err) {\n      sendSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      sendSpan.end();\n    }\n  }\n\n  /**\n   * Closes the underlying AMQP sender link.\n   * Once closed, the producer cannot be used for any further operations.\n   * Use the `createProducer` function on the EventHubClient to instantiate a new EventHubProducer.\n   *\n   * @returns\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._context.connection && this._context.connection.isOpen() && this._eventHubSender) {\n        await this._eventHubSender.close();\n        this._eventHubSender = undefined;\n      }\n      this._isClosed = true;\n    } catch (err) {\n      logger.warning(\n        \"[%s] An error occurred while closing the Sender for %s: %O\",\n        this._context.connectionId,\n        this._context.config.entityPath,\n        err\n      );\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  private _createSendSpan(\n    parentSpan?: Span | SpanContext,\n    spanContextsToLink: SpanContext[] = []\n  ): Span {\n    const links: Link[] = spanContextsToLink.map((spanContext) => {\n      return {\n        spanContext\n      };\n    });\n    const tracer = getTracer();\n    const span = tracer.startSpan(\"Azure.EventHubs.send\", {\n      kind: SpanKind.CLIENT,\n      parent: parentSpan,\n      links\n    });\n\n    span.setAttribute(\"az.namespace\", \"Microsoft.EventHub\");\n    span.setAttribute(\"message_bus.destination\", this._eventHubName);\n    span.setAttribute(\"peer.address\", this._endpoint);\n\n    return span;\n  }\n\n  private _throwIfSenderOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (this.isClosed) {\n      const errorMessage =\n        `The EventHubProducer for \"${this._context.config.entityPath}\" has been closed and can no longer be used. ` +\n        `Please create a new EventHubProducer using the \"createProducer\" function on the EventHubClient.`;\n      const error = new Error(errorMessage);\n      logger.warning(`[${this._context.connectionId}] %O`, error);\n      logErrorStackTrace(error);\n      throw error;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { translate, Constants, ErrorNameConditionMapper } from \"@azure/core-amqp\";\n\n/**\n * Represents the position of an event in an Event Hub partition, typically used when calling the `subscribe()`\n * method on an `EventHubConsumerClient` to specify the position in the partition to begin receiving events from.\n *\n * To get an EventPosition representing the start or end of the stream, use the constants\n * `earliestEventPosition` and `latestEventPosition` respectively.\n *\n */\nexport interface EventPosition {\n  /**\n   * @property The offset of the event identified by this position.\n   * Expected to be undefined if the position is just created from a sequence number or an enqueued time.\n   *\n   * The offset is the relative position for an event in the context of the partition.\n   * The offset should not be considered a stable value.\n   * The same offset may refer to a different event as events reach the age limit for\n   * retention and are no longer visible within the partition.\n   */\n  offset?: number | \"@latest\";\n  /**\n   * @property Indicates if the specified offset is inclusive of the event which it identifies.\n   * This information is only relevent if the event position was identified by an offset or sequence number.\n   * Default value: `false`.\n   */\n  isInclusive?: boolean;\n  /**\n   * @property The enqueued time in UTC of the event identified by this position.\n   * When provided as a number this value is the number of milliseconds since the Unix Epoch.\n   * Expected to be undefined if the position is just created from a sequence number or an offset.\n   */\n  enqueuedOn?: Date | number;\n\n  /**\n   * @property The sequence number of the event identified by this position.\n   * Expected to be undefined if the position is just created from an offset or enqueued time.\n   */\n  sequenceNumber?: number;\n}\n\n/**\n * @internal\n * @ignore\n * Gets the expression to be set as the filter clause when creating the receiver\n * @return {string} filterExpression\n */\nexport function getEventPositionFilter(eventPosition: EventPosition): string {\n  let result;\n  // order of preference\n  if (eventPosition.offset != undefined) {\n    result = eventPosition.isInclusive\n      ? `${Constants.offsetAnnotation} >= '${eventPosition.offset}'`\n      : `${Constants.offsetAnnotation} > '${eventPosition.offset}'`;\n  } else if (eventPosition.sequenceNumber != undefined) {\n    result = eventPosition.isInclusive\n      ? `${Constants.sequenceNumberAnnotation} >= '${eventPosition.sequenceNumber}'`\n      : `${Constants.sequenceNumberAnnotation} > '${eventPosition.sequenceNumber}'`;\n  } else if (eventPosition.enqueuedOn != undefined) {\n    const time =\n      eventPosition.enqueuedOn instanceof Date\n        ? eventPosition.enqueuedOn.getTime()\n        : eventPosition.enqueuedOn;\n    result = `${Constants.enqueuedTimeAnnotation} > '${time}'`;\n  }\n\n  if (!result) {\n    throw translate({\n      condition: ErrorNameConditionMapper.ArgumentError,\n      description: \"No starting position was set in the EventPosition.\"\n    });\n  }\n  return result;\n}\n\n/**\n * @internal\n * @ignore\n */\nexport function isLatestPosition(eventPosition: EventPosition): boolean {\n  if (eventPosition.offset === \"@latest\") {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Gets the `EventPosition` corresponding to the location of the the first event present in the partition.\n * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the\n * first event in the partition which has not expired due to the retention policy.\n */\nexport const earliestEventPosition: EventPosition = {\n  offset: -1\n};\n\n/**\n * Gets the `EventPosition` corresponding to the end of the partition.\n * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the\n * event that is enqueued right after the method call.\n * @returns EventPosition\n */\nexport const latestEventPosition: EventPosition = {\n  offset: \"@latest\"\n};\n\n/**\n * @ignore\n * @internal\n */\nexport function validateEventPositions(\n  position: EventPosition | { [partitionId: string]: EventPosition }\n) {\n  if (position == undefined) {\n    return;\n  }\n\n  const keys = Object.keys(position);\n\n  if (!keys.length) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.\"\n    );\n  }\n\n  if (isEventPosition(position)) {\n    validateEventPosition(position);\n    return;\n  }\n\n  const positions = position as { [partitionId: string]: EventPosition };\n  for (let i = 0; i < keys.length; i++) {\n    if (Object.prototype.hasOwnProperty.call(positions, keys[i])) {\n      validateEventPosition(positions[keys[i]]);\n    }\n  }\n}\n\n/**\n * Determines whether a position is an EventPosition.\n * Does not validate that the position is allowed.\n * @param position\n * @ignore\n * @internal\n */\nexport function isEventPosition(position: any): position is EventPosition {\n  if (!position) {\n    return false;\n  }\n\n  if (position.offset != undefined) {\n    return true;\n  }\n\n  if (position.sequenceNumber != undefined) {\n    return true;\n  }\n\n  if (position.enqueuedOn != undefined) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction validateEventPosition(position: EventPosition) {\n  if (position == undefined) {\n    return;\n  }\n  const offsetPresent = position.offset != undefined;\n  const sequenceNumberPresent = position.sequenceNumber != undefined;\n  const enqueuedOnPresent = position.enqueuedOn != undefined;\n\n  if (\n    (offsetPresent && sequenceNumberPresent) ||\n    (offsetPresent && enqueuedOnPresent) ||\n    (enqueuedOnPresent && sequenceNumberPresent)\n  ) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Set only one of offset, sequenceNumber or enqueuedOn properties.\"\n    );\n  }\n\n  if (!offsetPresent && !enqueuedOnPresent && !sequenceNumberPresent) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.\"\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport { logger, logErrorStackTrace } from \"./log\";\nimport {\n  Receiver,\n  OnAmqpEvent,\n  EventContext,\n  ReceiverOptions as RheaReceiverOptions,\n  types\n} from \"rhea-promise\";\nimport { delay, translate, Constants, MessagingError } from \"@azure/core-amqp\";\nimport { ReceivedEventData, EventDataInternal, fromAmqpMessage } from \"./eventData\";\nimport { EventHubConsumerOptions } from \"./impl/eventHubClient\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { EventPosition, getEventPositionFilter } from \"./eventPosition\";\nimport { AbortSignalLike, AbortError } from \"@azure/abort-controller\";\n\n/**\n * @ignore\n */\ninterface CreateReceiverOptions {\n  onMessage: OnAmqpEvent;\n  onError: OnAmqpEvent;\n  onClose: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSessionClose: OnAmqpEvent;\n  newName?: boolean;\n  eventPosition?: EventPosition;\n}\n\n/**\n * A set of information about the last enqueued event of a partition, as observed by the consumer as\n * events are received from the Event Hubs service\n * @interface LastEnqueuedEventProperties\n */\nexport interface LastEnqueuedEventProperties {\n  /**\n   * @property The sequence number of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  sequenceNumber?: number;\n  /**\n   * @property The date and time, in UTC, that the last event was enqueued into the Event Hub partition from\n   * which this event was received.\n   */\n  enqueuedOn?: Date;\n  /**\n   * @property The offset of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  offset?: string;\n  /**\n   * @property The date and time, in UTC, that the last event was retrieved from the Event Hub partition.\n   */\n  retrievedOn?: Date;\n}\n\n/**\n * Describes the message handler signature.\n * @internal\n * @ignore\n */\nexport type OnMessage = (eventData: ReceivedEventData) => void;\n\n/**\n * Describes the error handler signature.\n * @internal\n * @ignore\n */\nexport type OnError = (error: MessagingError | Error) => void;\n\n/**\n * Describes the abort handler signature.\n * @internal\n * @ignore\n */\nexport type OnAbort = () => void;\n\n/**\n * Describes the EventHubReceiver that will receive event data from EventHub.\n * @class EventHubReceiver\n * @internal\n * @ignore\n */\nexport class EventHubReceiver extends LinkEntity {\n  /**\n   * @property consumerGroup The EventHub consumer group from which the receiver will\n   * receive messages. (Default: \"default\").\n   */\n  consumerGroup: string;\n  /**\n   * @property runtimeInfo The receiver runtime info.\n   */\n  runtimeInfo: LastEnqueuedEventProperties;\n  /**\n   * @property [ownerLevel] The Receiver ownerLevel.\n   */\n  ownerLevel?: number;\n  /**\n   * @property eventPosition The event position in the partition at which to start receiving messages.\n   */\n  eventPosition: EventPosition;\n  /**\n   * @property [options] Optional properties that can be set while creating\n   * the EventHubConsumer.\n   */\n  options: EventHubConsumerOptions;\n  /**\n   * @property [_receiver] The RHEA AMQP-based receiver link.\n   * @private\n   */\n  private _receiver?: Receiver;\n  /**\n   * @property _onMessage The message handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   * @private\n   */\n  private _onMessage?: OnMessage;\n  /**\n   * @property _OnError The error handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   * @private\n   */\n  private _onError?: OnError;\n  /**\n   * @property _onAbort The abort handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   * @private\n   */\n  private _onAbort?: OnAbort;\n  /**\n   * @property _abortSignal An implementation of the `AbortSignalLike` interface to signal cancelling a receiver operation.\n   * @private\n   */\n  private _abortSignal?: AbortSignalLike;\n  /**\n   * @property _checkpoint The sequence number of the most recently received AMQP message.\n   * @private\n   */\n  private _checkpoint: number = -1;\n  /**\n   * @property _internalQueue A queue of events that were received from the AMQP link but not consumed externally by `EventHubConsumer`\n   * @private\n   */\n  private _internalQueue: ReceivedEventData[] = [];\n  /**\n   * @property _usingInternalQueue Indicates that events in the internal queue are being processed to be consumed by `EventHubConsumer`\n   * @private\n   */\n  private _usingInternalQueue: boolean = false;\n  /**\n   * @property _isReceivingMessages Indicates if messages are being received from this receiver.\n   * @private\n   */\n  private _isReceivingMessages: boolean = false;\n  /**\n   * @property _isStreaming Indicated if messages are being received in streaming mode.\n   * @private\n   */\n  private _isStreaming: boolean = false;\n\n  /**\n   * @property Returns sequenceNumber of the last event received from the service. This will not match the\n   * last event received by `EventHubConsumer` when the `_internalQueue` is not empty\n   * @readonly\n   */\n  get checkpoint(): number {\n    return this._checkpoint;\n  }\n\n  /**\n   * @property Indicates if messages are being received from this receiver.\n   * @readonly\n   */\n  get isReceivingMessages(): boolean {\n    return this._isReceivingMessages;\n  }\n\n  /**\n   * Instantiates a receiver that can be used to receive events over an AMQP receiver link in\n   * either batching or streaming mode.\n   * @ignore\n   * @constructor\n   * @param context        The connection context corresponding to the EventHubClient instance\n   * @param consumerGroup  The consumer group from which the receiver should receive events from.\n   * @param partitionId    The Partition ID from which to receive.\n   * @param eventPosition  The position in the stream from where to start receiving events.\n   * @param [options]      Receiver options.\n   */\n  constructor(\n    context: ConnectionContext,\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options: EventHubConsumerOptions = {}\n  ) {\n    super(context, {\n      partitionId: partitionId,\n      name: context.config.getReceiverAddress(partitionId, consumerGroup)\n    });\n    this.consumerGroup = consumerGroup;\n    this.address = context.config.getReceiverAddress(partitionId, this.consumerGroup);\n    this.audience = context.config.getReceiverAudience(partitionId, this.consumerGroup);\n    this.ownerLevel = options.ownerLevel;\n    this.eventPosition = eventPosition;\n    this.options = options;\n    this.runtimeInfo = {};\n  }\n\n  private _onAmqpMessage(context: EventContext): void {\n    if (!context.message) {\n      return;\n    }\n\n    const data: EventDataInternal = fromAmqpMessage(context.message);\n    const receivedEventData: ReceivedEventData = {\n      body: this._context.dataTransformer.decode(context.message.body),\n      properties: data.properties,\n      offset: data.offset!,\n      sequenceNumber: data.sequenceNumber!,\n      enqueuedTimeUtc: data.enqueuedTimeUtc!,\n      partitionKey: data.partitionKey!,\n      systemProperties: data.systemProperties\n    };\n\n    this._checkpoint = receivedEventData.sequenceNumber;\n\n    if (this.options.trackLastEnqueuedEventProperties && data) {\n      this.runtimeInfo.sequenceNumber = data.lastSequenceNumber;\n      this.runtimeInfo.enqueuedOn = data.lastEnqueuedTime;\n      this.runtimeInfo.offset = data.lastEnqueuedOffset;\n      this.runtimeInfo.retrievedOn = data.retrievalTime;\n    }\n\n    // Add to internal queue if\n    // - There are no listeners, we are probably getting events due to pending credits\n    // - Or Events from internal queue are being processed, so add to it to ensure order of processing is retained\n    if (!this._onMessage || this._usingInternalQueue) {\n      this._internalQueue.push(receivedEventData);\n    } else {\n      if (this._isStreaming) {\n        this._addCredit(1);\n      }\n      this._onMessage(receivedEventData);\n    }\n  }\n\n  private _onAmqpError(context: EventContext): void {\n    const rheaReceiver = this._receiver || context.receiver;\n    const amqpError = rheaReceiver && rheaReceiver.error;\n    logger.verbose(\n      \"[%s] 'receiver_error' event occurred on the receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      amqpError\n    );\n\n    if (this._onError && amqpError) {\n      const error = translate(amqpError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private _onAmqpSessionError(context: EventContext): void {\n    const sessionError = context.session && context.session.error;\n    logger.verbose(\n      \"[%s] 'session_error' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      sessionError\n    );\n\n    if (this._onError && sessionError) {\n      const error = translate(sessionError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private async _onAmqpClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s'. \" +\n        \"Value for isItselfClosed on the receiver is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'receiver_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  private async _onAmqpSessionClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'session_close' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"Value for isSessionItselfClosed on the session is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isSessionItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'session_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  async abort(): Promise<void> {\n    const desc: string =\n      `[${this._context.connectionId}] The receive operation on the Receiver \"${this.name}\" with ` +\n      `address \"${this.address}\" has been cancelled by the user.`;\n    // Cancellation is user-intended, so log to info instead of warning.\n    logger.info(desc);\n    if (this._onError) {\n      const error = new AbortError(\"The receive operation has been cancelled by the user.\");\n      this._onError(error);\n    }\n    this.clearHandlers();\n    await this.close();\n  }\n\n  /**\n   * Clears the user-provided handlers and updates the receiving messages flag.\n   * @ignore\n   */\n  clearHandlers(): void {\n    if (this._abortSignal && this._onAbort) {\n      this._abortSignal.removeEventListener(\"abort\", this._onAbort);\n    }\n\n    this._abortSignal = undefined;\n    this._onAbort = undefined;\n    this._onError = undefined;\n    this._onMessage = undefined;\n    this._isReceivingMessages = false;\n    this._isStreaming = false;\n  }\n\n  /**\n   * Closes the underlying AMQP receiver.\n   * @ignore\n   * @returns\n   */\n  async close(): Promise<void> {\n    this.clearHandlers();\n\n    if (!this._receiver) {\n      return;\n    }\n\n    const receiverLink = this._receiver;\n    this._deleteFromCache();\n    await this._closeLink(receiverLink);\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   * @ignore\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result = Boolean(this._receiver && this._receiver.isOpen());\n    logger.verbose(\n      \"[%s] Receiver '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Registers the user's onMessage and onError handlers.\n   * Sends buffered events from the queue before adding additional credits to the AMQP link.\n   * @ignore\n   */\n  registerHandlers(\n    onMessage: OnMessage,\n    onError: OnError,\n    maximumCreditCount: number,\n    isStreaming: boolean,\n    abortSignal?: AbortSignalLike,\n    onAbort?: OnAbort\n  ): void {\n    this._abortSignal = abortSignal;\n    this._onAbort = onAbort;\n    this._onError = onError;\n    this._onMessage = onMessage;\n    this._isStreaming = isStreaming;\n    // indicate that messages are being received.\n    this._isReceivingMessages = true;\n\n    this._useInternalQueue(onMessage, abortSignal)\n      .then(async (processedEventCount) => {\n        if (this._onMessage !== onMessage) {\n          // the original handler has been removed, so no further action required.\n          return;\n        }\n\n        // check if more messages are required\n        if (!isStreaming && maximumCreditCount - processedEventCount <= 0) {\n          return;\n        }\n\n        if (!this.isOpen()) {\n          try {\n            await this.initialize();\n            if (abortSignal && abortSignal.aborted) {\n              await this.abort();\n            }\n          } catch (err) {\n            return this._onError === onError && onError(err);\n          }\n        } else {\n          logger.verbose(\n            \"[%s] Receiver link already present, hence reusing it.\",\n            this._context.connectionId\n          );\n        }\n        // add credits\n        const existingCredits = this._receiver ? this._receiver.credit : 0;\n        const prcoessedEventCountToExclude = isStreaming ? 0 : processedEventCount;\n        const creditsToAdd = Math.max(\n          maximumCreditCount - (existingCredits + prcoessedEventCountToExclude),\n          0\n        );\n        this._addCredit(creditsToAdd);\n      })\n      .catch((err) => {\n        // something really unexpected happened, so attempt to call user's error handler\n        if (this._onError === onError) {\n          onError(err);\n        }\n      });\n  }\n\n  private _addCredit(credit: number): void {\n    if (this._receiver) {\n      this._receiver.addCredit(credit);\n    }\n  }\n\n  private _deleteFromCache(): void {\n    this._receiver = undefined;\n    delete this._context.receivers[this.name];\n    logger.verbose(\n      \"[%s] Deleted the receiver '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name\n    );\n  }\n\n  private async _useInternalQueue(\n    onMessage: OnMessage,\n    abortSignal?: AbortSignalLike\n  ): Promise<number> {\n    let processedMessagesCount = 0;\n    // allow the event loop to process any blocking code outside\n    // this code path before sending any events.\n    await delay(0);\n    this._usingInternalQueue = true;\n    while (this._internalQueue.length) {\n      if (!this._onMessage) {\n        break;\n      }\n\n      if (abortSignal && abortSignal.aborted) {\n        break;\n      }\n\n      // These will not be equal if clearHandlers and registerHandlers were called\n      // in the same tick of the event loop. If onMessage isn't the currently active\n      // handler, it should stop getting messages from the queue.\n      if (this._onMessage !== onMessage) {\n        break;\n      }\n      const eventData = this._internalQueue.splice(0, 1)[0];\n      processedMessagesCount++;\n      onMessage(eventData);\n      // allow the event loop to process any blocking code outside\n      // this code path before sending the next event.\n      await delay(0);\n    }\n    this._usingInternalQueue = false;\n    return processedMessagesCount;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   * @ignore\n   * @returns\n   */\n  async initialize(): Promise<void> {\n    try {\n      if (!this.isOpen() && !this.isConnecting) {\n        this.isConnecting = true;\n        await this._negotiateClaim();\n\n        const receiverOptions: CreateReceiverOptions = {\n          onClose: (context: EventContext) => this._onAmqpClose(context),\n          onError: (context: EventContext) => this._onAmqpError(context),\n          onMessage: (context: EventContext) => this._onAmqpMessage(context),\n          onSessionClose: (context: EventContext) => this._onAmqpSessionClose(context),\n          onSessionError: (context: EventContext) => this._onAmqpSessionError(context)\n        };\n        if (this.checkpoint > -1) {\n          receiverOptions.eventPosition = { sequenceNumber: this.checkpoint };\n        }\n        const options = this._createReceiverOptions(receiverOptions);\n\n        logger.verbose(\n          \"[%s] Trying to create receiver '%s' with options %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        this._receiver = await this._context.connection.createReceiver(options);\n        this.isConnecting = false;\n        logger.verbose(\n          \"[%s] Receiver '%s' created with receiver options: %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        // store the underlying link in a cache\n        this._context.receivers[this.name] = this;\n\n        await this._ensureTokenRenewal();\n      } else {\n        logger.verbose(\n          \"[%s] The receiver '%s' with address '%s' is open -> %s and is connecting \" +\n            \"-> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err) {\n      this.isConnecting = false;\n      const error = translate(err);\n      logger.warning(\n        \"[%s] An error occured while creating the receiver '%s': %O\",\n        this._context.connectionId,\n        this.name,\n        error\n      );\n      logErrorStackTrace(err);\n      throw error;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   * @ignore\n   */\n  private _createReceiverOptions(options: CreateReceiverOptions): RheaReceiverOptions {\n    if (options.newName) this.name = uuid();\n    const rcvrOptions: RheaReceiverOptions = {\n      name: this.name,\n      autoaccept: true,\n      source: {\n        address: this.address\n      },\n      credit_window: 0,\n      onMessage: options.onMessage || ((context: EventContext) => this._onAmqpMessage(context)),\n      onError: options.onError || ((context: EventContext) => this._onAmqpError(context)),\n      onClose: options.onClose || ((context: EventContext) => this._onAmqpClose(context)),\n      onSessionError:\n        options.onSessionError || ((context: EventContext) => this._onAmqpSessionError(context)),\n      onSessionClose:\n        options.onSessionClose || ((context: EventContext) => this._onAmqpSessionClose(context))\n    };\n\n    if (typeof this.ownerLevel === \"number\") {\n      rcvrOptions.properties = {\n        [Constants.attachEpoch]: types.wrap_long(this.ownerLevel)\n      };\n    }\n\n    if (this.options.trackLastEnqueuedEventProperties) {\n      rcvrOptions.desired_capabilities = Constants.enableReceiverRuntimeMetricName;\n    }\n\n    const eventPosition = options.eventPosition || this.eventPosition;\n    if (eventPosition) {\n      // Set filter on the receiver if event position is specified.\n      const filterClause = getEventPositionFilter(eventPosition);\n      if (filterClause) {\n        (rcvrOptions.source as any).filter = {\n          \"apache.org:selector-filter:string\": types.wrap_described(filterClause, 0x468c00000004)\n        };\n      }\n    }\n    return rcvrOptions;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventHubReceiver } from \"./eventHubReceiver\";\nimport { logger, logErrorStackTrace } from \"./log\";\n\n/**\n * Describes the receive handler object that is returned from the receive() method with handlers.\n * The ReceiveHandler is used to stop receiving more messages.\n * @class ReceiveHandler\n * @ignore\n * @internal\n */\nexport class ReceiveHandler {\n  /**\n   * @property _receiver  The underlying EventHubReceiver.\n   * @private\n   */\n  private _receiver: EventHubReceiver;\n\n  /**\n   * Creates an instance of the ReceiveHandler.\n   * @constructor\n   * @internal\n   * @param receiver The underlying EventHubReceiver.\n   */\n  constructor(receiver: EventHubReceiver) {\n    this._receiver = receiver;\n  }\n\n  /**\n   * @property The partitionId from which the handler is receiving events.\n   * @readonly\n   */\n  get partitionId(): string | undefined {\n    return this._receiver ? this._receiver.partitionId : undefined;\n  }\n\n  /**\n   * @property The consumer group from which the handler is receiving events.\n   * @readonly\n   */\n  get consumerGroup(): string | undefined {\n    return this._receiver ? this._receiver.consumerGroup : undefined;\n  }\n\n  /**\n   * @property Indicates whether the receiver is connected/open.\n   * `true` - is open; `false` otherwise.\n   * @readonly\n   */\n  get isReceiverOpen(): boolean {\n    return this._receiver ? this._receiver.isOpen() : false;\n  }\n\n  /**\n   * Stops the underlying EventHubReceiver from receiving more messages.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async stop(): Promise<void> {\n    if (this._receiver) {\n      try {\n        await this._receiver.close();\n      } catch (err) {\n        logger.warning(\n          \"An error occurred while stopping the receiver '%s' with address '%s': %O\",\n          this._receiver.name,\n          this._receiver.address,\n          err\n        );\n        logErrorStackTrace(err);\n      }\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { logger, logErrorStackTrace } from \"./log\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { EventHubConsumerOptions } from \"./impl/eventHubClient\";\nimport {\n  OnMessage,\n  OnError,\n  EventHubReceiver,\n  LastEnqueuedEventProperties\n} from \"./eventHubReceiver\";\nimport { ReceivedEventData } from \"./eventData\";\nimport {\n  RetryConfig,\n  Constants,\n  RetryOperationType,\n  retry,\n  MessagingError,\n  RetryOptions\n} from \"@azure/core-amqp\";\nimport { ReceiveHandler } from \"./receiveHandler\";\nimport { AbortSignalLike, AbortError } from \"@azure/abort-controller\";\nimport { throwErrorIfConnectionClosed } from \"./util/error\";\nimport { EventPosition } from \"./eventPosition\";\nimport \"@azure/core-asynciterator-polyfill\";\n\n/**\n * A consumer is responsible for reading `EventData` from a specific Event Hub partition\n * in the context of a specific consumer group.\n * To create a consumer use the `createConsumer()` method on your `EventHubClient`.\n *\n * You can pass the below in the `options` when creating a consumer.\n * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other\n * consumers to fail if their `ownerLevel` is lower or doesn't exist.\n * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.\n *\n * Multiple consumers are allowed on the same partition in a consumer group.\n * If there is a need to have an exclusive consumer for a partition in a consumer group,\n * then specify the `ownerLevel` in the `options`.\n * Exclusive consumers were previously referred to as \"Epoch Receivers\".\n *\n * The consumer can be used to receive messages in a batch using `receiveBatch()` or by registering handlers\n * by using `receive()` or via an async iterable got by using `getEventIterator()`\n * @class\n * @ignore\n * @internal\n */\nexport class EventHubConsumer {\n  private _baseConsumer?: EventHubReceiver;\n  /**\n   * @property Describes the amqp connection context for the QueueClient.\n   */\n  private _context: ConnectionContext;\n  /**\n   * @property The consumer group from which the receiver should receive events from.\n   */\n  private _consumerGroup: string;\n  /**\n   * @property Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n  /**\n   * @property The identifier of the Event Hub partition that this consumer is associated with.\n   * Events will be read only from this partition.\n   */\n  private _partitionId: string;\n  /**\n   * @property The set of options to configure the behavior of an EventHubConsumer.\n   */\n  private _receiverOptions: EventHubConsumerOptions;\n  /**\n   * @property The set of retry options to configure the receiveBatch operation.\n   */\n  private _retryOptions: RetryOptions;\n  /**\n   * @property A set of information about the last enqueued event of a partition.\n   */\n  private _lastEnqueuedEventProperties: LastEnqueuedEventProperties;\n\n  /**\n   * @property The last enqueued event information. This property will only\n   * be enabled when `trackLastEnqueuedEventProperties` option is set to true in the\n   * `client.createConsumer()` method.\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this._lastEnqueuedEventProperties;\n  }\n\n  /**\n   * @property Returns `true` if the consumer is closed. This can happen either because the consumer\n   * itself has been closed or the client that created it has been closed.\n   * @readonly\n   */\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  /**\n   * @property The identifier of the Event Hub partition that this consumer is associated with.\n   * Events will be read only from this partition.\n   * @readonly\n   */\n  public get partitionId(): string {\n    return this._partitionId;\n  }\n\n  /**\n   * @property The name of the consumer group that this consumer is associated with.\n   * Events will be read only in the context of this group.\n   * @readonly\n   */\n  get consumerGroup(): string {\n    return this._consumerGroup;\n  }\n\n  /**\n   * @property The owner level associated with an exclusive consumer; for a non-exclusive consumer, this value will be null or undefined.\n   *\n   * When provided, the owner level indicates that a consumer is intended to be the exclusive receiver of events for the\n   * requested partition and the associated consumer group.\n   * When multiple consumers exist for the same partition/consumer group pair, then the ones with lower or no\n   * `ownerLevel` will get a `ReceiverDisconnectedError` during the next attempted receive operation.\n   * @readonly\n   */\n  get ownerLevel(): number | undefined {\n    return this._receiverOptions.ownerLevel;\n  }\n\n  /**\n   * Indicates whether the consumer is currently receiving messages or not.\n   * When this returns true, new `receive()` or `receiveBatch()` calls cannot be made.\n   */\n  get isReceivingMessages(): boolean {\n    return Boolean(this._baseConsumer && this._baseConsumer.isReceivingMessages);\n  }\n\n  /**\n   * EventHubConsumer should not be constructed using `new EventHubConsumer()`\n   * Use the `createConsumer()` method on your `EventHubClient` instead.\n   * @private\n   * @constructor\n   * @internal\n   * @ignore\n   */\n  constructor(\n    context: ConnectionContext,\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options?: EventHubConsumerOptions\n  ) {\n    this._context = context;\n    this._consumerGroup = consumerGroup;\n    this._partitionId = partitionId;\n    this._lastEnqueuedEventProperties = {};\n    this._receiverOptions = options || {};\n    this._retryOptions = this._receiverOptions.retryOptions || {};\n    this._baseConsumer = new EventHubReceiver(\n      context,\n      consumerGroup,\n      partitionId,\n      eventPosition,\n      options\n    );\n  }\n  /**\n   * Starts receiving events from the service and calls the user provided message handler for each event.\n   * Returns an object that can be used to query the state of the receiver and to stop receiving events as well.\n   *\n   * @param onMessage The message handler to receive event data objects.\n   * @param onError The error handler for errora that can occur when receiving events.\n   * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   * @returns ReceiveHandler - An object that provides a mechanism to stop receiving more messages.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws TypeError if a required parameter is missing.\n   * @throws Error if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws Error if the receiver is already receiving messages.\n   */\n  receive(onMessage: OnMessage, onError: OnError, abortSignal?: AbortSignalLike): ReceiveHandler {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    const baseConsumer = this._baseConsumer!;\n\n    if (typeof onMessage !== \"function\") {\n      throw new TypeError(\"The parameter 'onMessage' must be of type 'function'.\");\n    }\n    if (typeof onError !== \"function\") {\n      throw new TypeError(\"The parameter 'onError' must be of type 'function'.\");\n    }\n\n    // return immediately if the abortSignal is already aborted.\n    if (abortSignal && abortSignal.aborted) {\n      onError(new AbortError(\"The receive operation has been cancelled by the user.\"));\n      // close this receiver when user triggers a cancellation.\n      this.close().catch(() => {}); // no-op close error handler\n      return new ReceiveHandler(baseConsumer);\n    }\n\n    const wrappedOnError = (error: Error) => {\n      // ignore retryable errors\n      if ((error as MessagingError).retryable) {\n        return;\n      }\n\n      logger.warning(\n        \"[%s] Since the error is not retryable, we let the user know about it by calling the user's error handler.\",\n        this._context.connectionId\n      );\n      logErrorStackTrace(error);\n\n      if (error.name === \"AbortError\") {\n        // close this receiver when user triggers a cancellation.\n        this.close().catch(() => {}); // no-op close error handler\n      }\n      onError(error);\n    };\n\n    const onAbort = () => {\n      if (this._baseConsumer) {\n        this._baseConsumer.abort();\n      }\n    };\n\n    baseConsumer.registerHandlers(\n      onMessage,\n      wrappedOnError,\n      Constants.defaultPrefetchCount,\n      true,\n      abortSignal,\n      onAbort\n    );\n\n    if (\n      this._receiverOptions.trackLastEnqueuedEventProperties &&\n      this._baseConsumer &&\n      this._baseConsumer.runtimeInfo\n    ) {\n      this._lastEnqueuedEventProperties = this._baseConsumer.runtimeInfo;\n    }\n\n    return new ReceiveHandler(baseConsumer);\n  }\n\n  /**\n   * Returns a promise that resolves to an array of events received from the service.\n   *\n   * @param maxMessageCount The maximum number of messages to receive.\n   * @param maxWaitTimeInSeconds The maximum amount of time to wait to build up the requested message count;\n   * If not provided, it defaults to 60 seconds.\n   * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @returns Promise<ReceivedEventData[]>.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while receiving a message.\n   * @throws Error if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws Error if the receiver is already receiving messages.\n   */\n  async receiveBatch(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds: number = 60,\n    abortSignal?: AbortSignalLike\n  ): Promise<ReceivedEventData[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n\n    // store events across multiple retries\n    const receivedEvents: ReceivedEventData[] = [];\n\n    const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n      return new Promise(async (resolve, reject) => {\n        // if this consumer was closed, _baseConsumer might be undefined.\n        // resolve the operation's promise with the events collected thus far in case\n        // the promise hasn't already been resolved.\n        if (!this._baseConsumer) {\n          return resolve(receivedEvents);\n        }\n\n        let timer: any;\n        const logOnAbort = (): void => {\n          const baseConsumer = this._baseConsumer;\n          const name = baseConsumer && baseConsumer.name;\n          const address = baseConsumer && baseConsumer.address;\n          const desc: string =\n            `[${this._context.connectionId}] The request operation on the Receiver \"${name}\" with ` +\n            `address \"${address}\" has been cancelled by the user.`;\n          // Cancellation is intentional so logging to 'info'.\n          logger.info(desc);\n        };\n\n        const rejectOnAbort = async (): Promise<void> => {\n          logOnAbort();\n          try {\n            await this.close();\n          } finally {\n            return reject(new AbortError(\"The receive operation has been cancelled by the user.\"));\n          }\n        };\n\n        // operation has been cancelled, so exit immediately\n        if (abortSignal && abortSignal.aborted) {\n          return await rejectOnAbort();\n        }\n\n        // updates the prefetch count so that the baseConsumer adds\n        // the correct number of credits to receive the same number of events.\n        const prefetchCount = Math.max(maxMessageCount - receivedEvents.length, 0);\n        if (prefetchCount === 0) {\n          return resolve(receivedEvents);\n        }\n\n        logger.verbose(\n          \"[%s] Receiver '%s', setting the prefetch count to %d.\",\n          this._context.connectionId,\n          this._baseConsumer && this._baseConsumer.name,\n          prefetchCount\n        );\n\n        const cleanUpBeforeReturn = (): void => {\n          if (this._baseConsumer) {\n            this._baseConsumer.clearHandlers();\n          }\n          clearTimeout(timer);\n        };\n\n        const onAbort = (): void => {\n          clearTimeout(timer);\n          rejectOnAbort();\n        };\n\n        this._baseConsumer.registerHandlers(\n          (eventData) => {\n            receivedEvents.push(eventData);\n            if (\n              this._receiverOptions.trackLastEnqueuedEventProperties &&\n              this._baseConsumer &&\n              this._baseConsumer.runtimeInfo\n            ) {\n              this._lastEnqueuedEventProperties = this._baseConsumer.runtimeInfo;\n            }\n            // resolve the operation's promise after the requested\n            // number of events are received.\n            if (receivedEvents.length === maxMessageCount) {\n              logger.info(\n                \"[%s] Batching Receiver '%s', %d messages received within %d seconds.\",\n                this._context.connectionId,\n                this._baseConsumer && this._baseConsumer.name,\n                receivedEvents.length,\n                maxWaitTimeInSeconds\n              );\n              cleanUpBeforeReturn();\n              resolve(receivedEvents);\n            }\n          },\n          (err) => {\n            cleanUpBeforeReturn();\n            if (err.name === \"AbortError\") {\n              rejectOnAbort();\n            } else {\n              reject(err);\n            }\n          },\n          maxMessageCount - receivedEvents.length,\n          false,\n          abortSignal,\n          onAbort\n        );\n\n        const addTimeout = (): void => {\n          const msg = \"[%s] Setting the wait timer for %d seconds for receiver '%s'.\";\n          logger.verbose(\n            msg,\n            this._context.connectionId,\n            maxWaitTimeInSeconds,\n            this._baseConsumer && this._baseConsumer.name\n          );\n\n          // resolve the operation's promise after the requested\n          // max number of seconds have passed.\n          timer = setTimeout(() => {\n            logger.info(\n              \"[%s] Batching Receiver '%s', %d messages received when max wait time in seconds %d is over.\",\n              this._context.connectionId,\n              this._baseConsumer && this._baseConsumer.name,\n              receivedEvents.length,\n              maxWaitTimeInSeconds\n            );\n            cleanUpBeforeReturn();\n            resolve(receivedEvents);\n          }, maxWaitTimeInSeconds * 1000);\n        };\n\n        addTimeout();\n        if (abortSignal && !abortSignal.aborted) {\n          abortSignal.addEventListener(\"abort\", onAbort);\n        }\n      });\n    };\n\n    const retryOptions = this._retryOptions;\n    const config: RetryConfig<ReceivedEventData[]> = {\n      connectionHost: this._context.config.host,\n      connectionId: this._context.connectionId,\n      operation: retrieveEvents,\n      operationType: RetryOperationType.receiveMessage,\n      abortSignal: abortSignal,\n      retryOptions: retryOptions\n    };\n    return retry<ReceivedEventData[]>(config);\n  }\n\n  /**\n   * Closes the underlying AMQP receiver link.\n   * Once closed, the consumer cannot be used for any further operations.\n   * Use the `createConsumer` function on the EventHubClient to instantiate\n   * a new EventHubConsumer.\n   *\n   * @returns\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._context.connection && this._context.connection.isOpen()) {\n        if (this._baseConsumer) {\n          await this._baseConsumer.close();\n          this._baseConsumer = void 0;\n        }\n      }\n    } catch (err) {\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this.isReceivingMessages) {\n      const errorMessage = `The EventHubConsumer for \"${this._context.config.entityPath}\" is already receiving messages.`;\n      const error = new Error(errorMessage);\n      logger.warning(`[${this._context.connectionId}] %O`, error);\n      logErrorStackTrace(error);\n      throw error;\n    }\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (!this._baseConsumer || this.isClosed) {\n      const errorMessage =\n        `The EventHubConsumer for \"${this._context.config.entityPath}\" has been closed and can no longer be used. ` +\n        `Please create a new EventHubConsumer using the \"createConsumer\" function on the EventHubClient.`;\n      const error = new Error(errorMessage);\n      logger.error(`[${this._context.connectionId}] %O`, error);\n      logErrorStackTrace(error);\n      throw error;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { logger, logErrorStackTrace } from \"../log\";\nimport {\n  TokenCredential,\n  EventHubConnectionConfig,\n  SharedKeyCredential,\n  ConnectionConfig,\n  isTokenCredential,\n  RetryOptions,\n  Constants,\n  parseConnectionString,\n  EventHubConnectionStringModel\n} from \"@azure/core-amqp\";\n\nimport { ConnectionContext } from \"../connectionContext\";\nimport { PartitionProperties, EventHubProperties } from \"../managementClient\";\nimport { EventPosition } from \"../eventPosition\";\nimport { EventHubProducer } from \"../sender\";\nimport { EventHubConsumer } from \"../receiver\";\nimport { throwTypeErrorIfParameterMissing, throwErrorIfConnectionClosed } from \"../util/error\";\nimport { getTracer } from \"@azure/core-tracing\";\nimport { SpanContext, Span, SpanKind, CanonicalCode } from \"@opentelemetry/types\";\nimport { getParentSpan } from \"../util/operationOptions\";\nimport { OperationNames, EventHubProducerOptions } from \"../models/private\";\nimport {\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  EventHubClientOptions\n} from \"../models/public\";\n\n/**\n * The set of options to configure the behavior of an `EventHubConsumer`.\n * These can be specified when creating the consumer using the `createConsumer` method.\n * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other\n * consumers to fail if their `ownerLevel` is lower or doesn't exist.\n * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * Example usage:\n * ```js\n * {\n *     retryOptions: {\n *         maxRetries: 4\n *     },\n *     trackLastEnqueuedEventProperties: false\n * }\n * ```\n * @internal\n * @ignore\n */\nexport interface EventHubConsumerOptions {\n  /**\n   * @property\n   * The owner level associated with an exclusive consumer.\n   *\n   * When provided, the owner level indicates that a consumer is intended to be the exclusive receiver of events for the\n   * requested partition and the associated consumer group.\n   * When multiple consumers exist for the same partition/consumer group pair, then the ones with lower or no\n   * `ownerLevel` will get a `ReceiverDisconnectedError` during the next attempted receive operation.\n   */\n  ownerLevel?: number;\n  /**\n   * @property\n   * The retry options used to govern retry attempts when an issue is encountered while receiving events.\n   * If no value is provided here, the retry options set when creating the `EventHubClient` is used.\n   */\n  retryOptions?: RetryOptions;\n  /**\n   * @property\n   * Indicates whether or not the consumer should request information on the last enqueued event on its\n   * associated partition, and track that information as events are received.\n\n   * When information about the partition's last enqueued event is being tracked, each event received \n   * from the Event Hubs service will carry metadata about the partition that it otherwise would not. This results in a small amount of\n   * additional network bandwidth consumption that is generally a favorable trade-off when considered\n   * against periodically making requests for partition properties using the Event Hub client.\n   */\n  trackLastEnqueuedEventProperties?: boolean;\n}\n\n/**\n * @class\n * The client is the main point of interaction with Azure Event Hubs service.\n * It offers connection to a specific Event Hub within the Event Hubs namespace along with\n * operations for sending event data, receiving events, and inspecting the connected Event Hub.\n *\n * There are multiple ways to create an `EventHubClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the fully qualified domain name of your Event Hub namespace like `<yournamespace>.servicebus.windows.net`,\n * and a credentials object.\n *\n * @internal\n * @ignore\n */\nexport class EventHubClient {\n  /**\n   * Describes the amqp connection context for the eventhub client.\n   */\n  private _context: ConnectionContext;\n\n  /**\n   * The options passed by the user when creating the EventHubClient instance.\n   */\n  private _clientOptions: EventHubClientOptions;\n\n  /**\n   * The Service Bus endpoint.\n   * @internal\n   * @ignore\n   */\n  public readonly endpoint: string;\n\n  /**\n   * @property\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._context.config.entityPath;\n  }\n\n  /**\n   * @property\n   * @readonly\n   * The fully qualified Event Hubs namespace for which this client is created. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._context.config.host;\n  }\n\n  constructor(connectionString: string, options?: EventHubClientOptions);\n  constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions);\n  constructor(\n    host: string,\n    eventHubName: string,\n    credential: TokenCredential,\n    options?: EventHubClientOptions\n  );\n  constructor(\n    hostOrConnectionString: string,\n    eventHubNameOrOptions?: string | EventHubClientOptions,\n    credentialOrOptions?: TokenCredential | EventHubClientOptions,\n    options?: EventHubClientOptions\n  ) {\n    let connectionString;\n    let config;\n    let credential: TokenCredential | SharedKeyCredential;\n    hostOrConnectionString = String(hostOrConnectionString);\n\n    if (!isTokenCredential(credentialOrOptions)) {\n      const parsedCS = parseConnectionString<EventHubConnectionStringModel>(hostOrConnectionString);\n      if (\n        !(\n          parsedCS.EntityPath ||\n          (typeof eventHubNameOrOptions === \"string\" && eventHubNameOrOptions)\n        )\n      ) {\n        throw new TypeError(\n          `Either provide \"eventHubName\" or the \"connectionString\": \"${hostOrConnectionString}\", ` +\n            `must contain \"EntityPath=<your-event-hub-name>\".`\n        );\n      }\n      if (\n        parsedCS.EntityPath &&\n        typeof eventHubNameOrOptions === \"string\" &&\n        eventHubNameOrOptions &&\n        parsedCS.EntityPath !== eventHubNameOrOptions\n      ) {\n        throw new TypeError(\n          `The entity path \"${parsedCS.EntityPath}\" in connectionString: \"${hostOrConnectionString}\" ` +\n            `doesn't match with eventHubName: \"${eventHubNameOrOptions}\".`\n        );\n      }\n      connectionString = hostOrConnectionString;\n      if (typeof eventHubNameOrOptions !== \"string\") {\n        // connectionstring and/or options were passed to constructor\n        config = EventHubConnectionConfig.create(connectionString);\n        options = eventHubNameOrOptions;\n      } else {\n        // connectionstring, eventHubName and/or options were passed to constructor\n        const eventHubName = eventHubNameOrOptions;\n        config = EventHubConnectionConfig.create(connectionString, eventHubName);\n        options = credentialOrOptions;\n      }\n      // Since connectionstring was passed, create a SharedKeyCredential\n      credential = new SharedKeyCredential(config.sharedAccessKeyName, config.sharedAccessKey);\n    } else {\n      // host, eventHubName, a TokenCredential and/or options were passed to constructor\n      const eventHubName = eventHubNameOrOptions;\n      let host = hostOrConnectionString;\n      credential = credentialOrOptions;\n      if (!eventHubName) {\n        throw new TypeError(`\"eventHubName\" is missing`);\n      }\n\n      if (!host.endsWith(\"/\")) host += \"/\";\n      connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;EntityPath=${eventHubName}`;\n      config = EventHubConnectionConfig.create(connectionString);\n    }\n\n    ConnectionConfig.validate(config);\n\n    this.endpoint = config.endpoint;\n\n    this._clientOptions = options || {};\n    this._context = ConnectionContext.create(config, credential, this._clientOptions);\n  }\n\n  private _createClientSpan(\n    operationName: OperationNames,\n    parentSpan?: Span | SpanContext,\n    internal: boolean = false\n  ): Span {\n    const tracer = getTracer();\n    const span = tracer.startSpan(`Azure.EventHubs.${operationName}`, {\n      kind: internal ? SpanKind.INTERNAL : SpanKind.CLIENT,\n      parent: parentSpan\n    });\n\n    span.setAttribute(\"az.namespace\", \"Microsoft.EventHub\");\n    span.setAttribute(\"message_bus.destination\", this.eventHubName);\n    span.setAttribute(\"peer.address\", this.endpoint);\n\n    return span;\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._context.connection.isOpen()) {\n        // Close all the senders.\n        for (const senderName of Object.keys(this._context.senders)) {\n          await this._context.senders[senderName].close();\n        }\n        // Close all the receivers.\n        for (const receiverName of Object.keys(this._context.receivers)) {\n          await this._context.receivers[receiverName].close();\n        }\n        // Close the cbs session;\n        await this._context.cbsSession.close();\n        // Close the management session\n        await this._context.managementSession!.close();\n        await this._context.connection.close();\n        this._context.wasConnectionCloseCalled = true;\n        logger.info(\"Closed the amqp connection '%s' on the client.\", this._context.connectionId);\n      }\n    } catch (err) {\n      err = err instanceof Error ? err : JSON.stringify(err);\n      logger.warning(\n        `An error occurred while closing the connection \"${this._context.connectionId}\":\\n${err}`\n      );\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Creates an Event Hub producer that can send events to the Event Hub.\n   * If `partitionId` is specified in the `options`, all event data sent using the producer\n   * will be sent to the specified partition.\n   * Otherwise, they are automatically routed to an available partition by the Event Hubs service.\n   *\n   * Automatic routing of partitions is recommended because:\n   *  - The sending of events will be highly available.\n   *  - The event data will be evenly distributed among all available partitions.\n   *\n   * @param options The set of options to apply when creating the producer.\n   * - `partitionId`  : The identifier of the partition that the producer can be bound to.\n   * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.\n   * A simple usage can be `{ \"maxRetries\": 4 }`.\n   *\n   * @throws Error if the underlying connection has been closed, create a new EventHubClient.\n   * @returns EventHubProducer\n   */\n  createProducer(options?: EventHubProducerOptions): EventHubProducer {\n    if (!options) {\n      options = {};\n    }\n    if (!options.retryOptions) {\n      options.retryOptions = this._clientOptions.retryOptions;\n    }\n    throwErrorIfConnectionClosed(this._context);\n    return new EventHubProducer(this.eventHubName, this.endpoint, this._context, options);\n  }\n\n  /**\n   * Creates an Event Hub consumer that can receive events from a specific Event Hub partition,\n   * in the context of a specific consumer group.\n   *\n   * Multiple consumers are allowed on the same partition in a consumer group.\n   * If there is a need to have an exclusive consumer for a partition in a consumer group,\n   * then specify the `ownerLevel` in the `options`.\n   * Exclusive consumers were previously referred to as \"Epoch Receivers\".\n   *\n   * @param consumerGroup The name of the consumer group this consumer is associated with.\n   * Events are read in the context of this group. You can get this information from Azure portal.\n   * @param partitionId The identifier of the Event Hub partition from which events will be received.\n   * You can get identifiers for all partitions by using the `getPartitionProperties` method on the `EventHubClient`.\n   * @param eventPosition The position within the partition where the consumer should begin reading events.\n   * @param options The set of options to apply when creating the consumer.\n   * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other\n   * consumers to fail if their `ownerLevel` is lower or doesn't exist.\n   * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.\n   * A simple usage can be `{ \"maxRetries\": 4 }`.\n   *\n   * @throws Error if the underlying connection has been closed, create a new EventHubClient.\n   * @throws TypeError if a required parameter is missing.\n   */\n  createConsumer(\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options?: EventHubConsumerOptions\n  ): EventHubConsumer {\n    if (!options) {\n      options = {};\n    }\n    if (!options.retryOptions) {\n      options.retryOptions = this._clientOptions.retryOptions;\n    }\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"createConsumer\",\n      \"consumerGroup\",\n      consumerGroup\n    );\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"createConsumer\",\n      \"partitionId\",\n      partitionId\n    );\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"createConsumer\",\n      \"eventPosition\",\n      eventPosition\n    );\n    partitionId = String(partitionId);\n    return new EventHubConsumer(this._context, consumerGroup, partitionId, eventPosition, options);\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param [options] The set of options to apply to the operation call.\n   * @returns A promise that resolves with EventHubProperties.\n   * @throws Error if the underlying connection has been closed, create a new EventHubClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal3.\n   */\n  async getProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    throwErrorIfConnectionClosed(this._context);\n    const clientSpan = this._createClientSpan(\"getEventHubProperties\", getParentSpan(options));\n    try {\n      const result = await this._context.managementSession!.getHubRuntimeInformation({\n        retryOptions: this._clientOptions.retryOptions,\n        abortSignal: options.abortSignal\n      });\n      clientSpan.setStatus({ code: CanonicalCode.OK });\n      return result;\n    } catch (err) {\n      clientSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n      logger.warning(\"An error occurred while getting the hub runtime information: %O\", err);\n      logErrorStackTrace(err);\n      throw err;\n    } finally {\n      clientSpan.end();\n    }\n  }\n\n  /**\n   * Provides an array of partitionIds.\n   * @param [options] The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings.\n   * @throws Error if the underlying connection has been closed, create a new EventHubClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  async getPartitionIds(options: GetPartitionIdsOptions): Promise<Array<string>> {\n    throwErrorIfConnectionClosed(this._context);\n    const clientSpan = this._createClientSpan(\"getPartitionIds\", getParentSpan(options), true);\n    try {\n      const runtimeInfo = await this.getProperties({\n        ...options,\n        tracingOptions: {\n          spanOptions: {\n            parent: clientSpan\n          }\n        }\n      });\n      clientSpan.setStatus({ code: CanonicalCode.OK });\n      return runtimeInfo.partitionIds;\n    } catch (err) {\n      clientSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n      logger.warning(\"An error occurred while getting the partition ids: %O\", err);\n      logErrorStackTrace(err);\n      throw err;\n    } finally {\n      clientSpan.end();\n    }\n  }\n\n  /**\n   * Provides information about the specified partition.\n   * @param partitionId Partition ID for which partition information is required.\n   * @param [options] The set of options to apply to the operation call.\n   * @returns A promise that resoloves with PartitionProperties.\n   * @throws Error if the underlying connection has been closed, create a new EventHubClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  async getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"getPartitionProperties\",\n      \"partitionId\",\n      partitionId\n    );\n    partitionId = String(partitionId);\n    const clientSpan = this._createClientSpan(\"getPartitionProperties\", getParentSpan(options));\n    try {\n      const result = await this._context.managementSession!.getPartitionProperties(partitionId, {\n        retryOptions: this._clientOptions.retryOptions,\n        abortSignal: options.abortSignal\n      });\n      clientSpan.setStatus({ code: CanonicalCode.OK });\n      return result;\n    } catch (err) {\n      clientSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n      logger.warning(\"An error occurred while getting the partition information: %O\", err);\n      logErrorStackTrace(err);\n      throw err;\n    } finally {\n      clientSpan.end();\n    }\n  }\n\n  /**\n   * @property\n   * The name of the default consumer group in the Event Hubs service.\n   */\n  static defaultConsumerGroupName: string = Constants.defaultConsumerGroup;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { PartitionOwnership, CheckpointStore } from \"./eventProcessor\";\nimport { Checkpoint } from \"./partitionProcessor\";\nimport { generate_uuid } from \"rhea-promise\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\n\n/**\n * The `EventProcessor` relies on a `CheckpointStore` to store checkpoints and handle partition\n * ownerships. `InMemoryCheckpointStore` is simple partition manager that stores checkpoints and\n * partition ownerships in memory of your program.\n *\n * You can use the `InMemoryCheckpointStore` to get started with using the `EventProcessor`.\n * But in production, you should choose an implementation of the `CheckpointStore` interface that will\n * store the checkpoints and partition ownerships to a durable store instead.\n *\n * @class\n * @internal\n * @ignore\n */\nexport class InMemoryCheckpointStore implements CheckpointStore {\n  private _partitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n  private _committedCheckpoints: Map<string, Map<string, Checkpoint>> = new Map();\n\n  /**\n   * Get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName The event hub name.\n   * @param consumerGroup The consumer group name.\n   * @return Partition ownership details of all the partitions that have/had an owner..\n   */\n  async listOwnership(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<PartitionOwnership[]> {\n    const ownerships = [];\n\n    for (const value of this._partitionOwnershipMap.values()) {\n      ownerships.push({ ...value });\n    }\n\n    return ownerships;\n  }\n\n  /**\n   * Claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership The list of partition ownership this instance is claiming to own.\n   * @return A list partitions this instance successfully claimed ownership.\n   */\n  async claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]> {\n    const claimedOwnerships = [];\n\n    for (const ownership of partitionOwnership) {\n      if (\n        !this._partitionOwnershipMap.has(ownership.partitionId) ||\n        this._partitionOwnershipMap.get(ownership.partitionId)!.etag === ownership.etag\n      ) {\n        var date = new Date();\n\n        const newOwnership = {\n          ...ownership,\n          etag: generate_uuid(),\n          lastModifiedTimeInMs: date.getTime()\n        };\n\n        this._partitionOwnershipMap.set(newOwnership.partitionId, newOwnership);\n        claimedOwnerships.push(newOwnership);\n      }\n    }\n    return claimedOwnerships;\n  }\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint The checkpoint.\n   */\n  async updateCheckpoint(checkpoint: Checkpoint): Promise<void> {\n    throwTypeErrorIfParameterMissing(\n      \"\",\n      \"updateCheckpoint\",\n      \"sequenceNumber\",\n      checkpoint.sequenceNumber\n    );\n    throwTypeErrorIfParameterMissing(\"\", \"updateCheckpoint\", \"offset\", checkpoint.offset);\n\n    checkpoint = { ...checkpoint };\n\n    const partitionOwnership = this._partitionOwnershipMap.get(checkpoint.partitionId);\n    if (partitionOwnership) {\n      partitionOwnership.etag = generate_uuid();\n\n      const key = `${checkpoint.fullyQualifiedNamespace}:${checkpoint.eventHubName}:${checkpoint.consumerGroup}`;\n      let partitionMap = this._committedCheckpoints.get(key);\n\n      if (partitionMap == null) {\n        partitionMap = new Map();\n        this._committedCheckpoints.set(key, partitionMap);\n      }\n\n      partitionMap.set(checkpoint.partitionId, checkpoint);\n    }\n  }\n\n  async listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<Checkpoint[]> {\n    const key = `${fullyQualifiedNamespace}:${eventHubName}:${consumerGroup}`;\n\n    const partitionMap = this._committedCheckpoints.get(key);\n\n    if (partitionMap == null) {\n      return [];\n    }\n\n    const checkpoints = [];\n\n    for (const value of partitionMap.values()) {\n      checkpoints.push({ ...value });\n    }\n\n    return checkpoints;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { OperationOptions } from \"../util/operationOptions\";\nimport { RetryOptions, WebSocketOptions } from \"@azure/core-amqp\";\n\n/**\n * The set of options to configure the behavior of `getEventHubProperties`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetEventHubPropertiesOptions extends OperationOptions {}\n\n/**\n * The set of options to configure the behavior of `getPartitionProperties`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPartitionPropertiesOptions extends OperationOptions {}\n\n/**\n * The set of options to configure the behavior of `getPartitionIds`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPartitionIdsOptions extends OperationOptions {}\n\n/**\n * Options to configure the `sendBatch` method on the `EventHubProducerClient`.\n * - `abortSignal`  : A signal used to cancel the send operation.\n */\nexport interface SendBatchOptions extends OperationOptions {}\n\n/**\n * The set of options to configure the `send` operation on the `EventHubProducer`.\n * - `partitionKey` : A value that is hashed to produce a partition assignment.\n * - `abortSignal`  : A signal used to cancel the send operation.\n *\n * Example usage:\n * ```js\n * {\n *     partitionKey: 'foo'\n * }\n * ```\n *\n * @internal\n * @ignore\n */\nexport interface SendOptions extends SendBatchOptions {\n  /**\n   * @property\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  partitionKey?: string | null;\n}\n\n/**\n * An enum representing the different reasons for an `EventHubConsumerClient` to stop processing\n * events from a partition in a consumer group of an Event Hub.\n */\nexport enum CloseReason {\n  /**\n   * Ownership of the partition was lost or transitioned to a new processor instance.\n   */\n  OwnershipLost = \"OwnershipLost\",\n  /**\n   * The EventProcessor was shutdown.\n   */\n  Shutdown = \"Shutdown\"\n}\n\n/**\n * Describes the options that can be provided while creating the EventHubClient.\n * - `userAgent`        : A string to append to the built in user agent string that is passed as a connection property\n * to the service.\n * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.\n *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`     : The retry options for all the operations on the client/producer/consumer.\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * Example usage:\n * ```js\n * {\n *     retryOptions: {\n *         maxRetries: 4\n *     }\n * }\n * ```\n * @interface ClientOptions\n */\nexport interface EventHubClientOptions {\n  /**\n   * @property\n   * Options to configure the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   */\n  retryOptions?: RetryOptions;\n  /**\n   * @property\n   * Options to configure the channelling of the AMQP connection over Web Sockets.\n   */\n  webSocketOptions?: WebSocketOptions;\n  /**\n   * @property\n   * Value that is appended to the built in user agent string that is passed to the Event Hubs service.\n   */\n  userAgent?: string;\n}\n\n/**\n * Options to configure the `createBatch` method on the `EventHubProducerClient`.\n * - `partitionKey`  : A value that is hashed to produce a partition assignment.\n * - `maxSizeInBytes`: The upper limit for the size of batch.\n * - `abortSignal`   : A signal the request to cancel the send operation.\n *\n * Example usage:\n * ```js\n * {\n *     partitionKey: 'foo',\n *     maxSizeInBytes: 1024 * 1024 // 1 MB\n * }\n * ```\n */\nexport interface CreateBatchOptions extends OperationOptions {\n  /**\n   * A value that is hashed to produce a partition assignment. It guarantees that messages\n   * with the same partitionKey end up in the same partition.\n   * If this value is set then partitionId can not be set.\n   */\n  partitionKey?: string;\n  /**\n   * The partition this batch will be sent to.\n   * If this value is set then partitionKey can not be set.\n   */\n  partitionId?: string;\n  /**\n   * @property\n   * The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   */\n  maxSizeInBytes?: number;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { logger, logErrorStackTrace } from \"./log\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\nimport { EventHubClient } from \"./impl/eventHubClient\";\nimport { EventPosition } from \"./eventPosition\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { EventHubConsumer } from \"./receiver\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { MessagingError } from \"@azure/core-amqp\";\nimport { getParentSpan, TracingOptions } from \"./util/operationOptions\";\nimport { getTracer } from \"@azure/core-tracing\";\nimport { Span, SpanKind, Link, CanonicalCode } from \"@opentelemetry/types\";\nimport { extractSpanContextFromEventData } from \"./diagnostics/instrumentEventData\";\nimport { ReceivedEventData } from \"./eventData\";\n\n/**\n * @ignore\n * @internal\n */\nexport class PartitionPump {\n  private _eventHubClient: EventHubClient;\n  private _partitionProcessor: PartitionProcessor;\n  private _processorOptions: CommonEventProcessorOptions;\n  private _receiver: EventHubConsumer | undefined;\n  private _isReceiving: boolean = false;\n  private _isStopped: boolean = false;\n  private _abortController: AbortController;\n\n  constructor(\n    eventHubClient: EventHubClient,\n    partitionProcessor: PartitionProcessor,\n    private readonly _startPosition: EventPosition,\n    options: CommonEventProcessorOptions\n  ) {\n    this._eventHubClient = eventHubClient;\n    this._partitionProcessor = partitionProcessor;\n    this._processorOptions = options;\n    this._abortController = new AbortController();\n  }\n\n  public get isReceiving(): boolean {\n    return this._isReceiving;\n  }\n\n  async start(): Promise<void> {\n    this._isReceiving = true;\n    try {\n      await this._partitionProcessor.initialize();\n    } catch (err) {\n      // swallow the error from the user-defined code\n      this._partitionProcessor.processError(err);\n    }\n\n    // this is intentionally not await'd - the _receiveEvents loop will continue to\n    // execute and can be stopped by calling .stop()\n    this._receiveEvents(this._partitionProcessor.partitionId);\n    logger.info(\n      `Successfully started the receiver for partition \"${this._partitionProcessor.partitionId}\".`\n    );\n  }\n\n  private async _receiveEvents(partitionId: string): Promise<void> {\n    this._receiver = this._eventHubClient.createConsumer(\n      this._partitionProcessor.consumerGroup,\n      partitionId,\n      this._startPosition,\n      {\n        ownerLevel: this._processorOptions.ownerLevel,\n        trackLastEnqueuedEventProperties: this._processorOptions.trackLastEnqueuedEventProperties\n      }\n    );\n\n    while (this._isReceiving) {\n      try {\n        const receivedEvents = await this._receiver.receiveBatch(\n          this._processorOptions.maxBatchSize,\n          this._processorOptions.maxWaitTimeInSeconds,\n          this._abortController.signal\n        );\n\n        if (\n          this._processorOptions.trackLastEnqueuedEventProperties &&\n          this._receiver.lastEnqueuedEventProperties\n        ) {\n          this._partitionProcessor.lastEnqueuedEventProperties = this._receiver.lastEnqueuedEventProperties;\n        }\n        // avoid calling user's processEvents handler if the pump was stopped while receiving events\n        if (!this._isReceiving) {\n          return;\n        }\n\n        const span = createProcessingSpan(\n          receivedEvents,\n          this._eventHubClient,\n          this._processorOptions\n        );\n\n        await trace(() => this._partitionProcessor.processEvents(receivedEvents), span);\n      } catch (err) {\n        // check if this pump is still receiving\n        // it may not be if the EventProcessor was stopped during processEvents\n        if (!this._isReceiving) {\n          // no longer receiving, so close was called from somewhere else\n          return;\n        }\n\n        logger.warning(\n          `An error was thrown while receiving or processing events on partition \"${this._partitionProcessor.partitionId}\"`\n        );\n        logErrorStackTrace(err);\n        // forward error to user's processError and swallow errors they may throw\n        try {\n          await this._partitionProcessor.processError(err);\n        } catch (err) {\n          // Using verbose over warning because this error is swallowed.\n          logger.verbose(\"An error was thrown by user's processError method: \", err);\n        }\n\n        // close the partition processor if a non-retryable error was encountered\n        if (typeof err !== \"object\" || !(err as MessagingError).retryable) {\n          try {\n            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel\n            // started consuming the partition), update the closeReason\n            if (err.code === \"ReceiverDisconnectedError\") {\n              return await this.stop(CloseReason.OwnershipLost);\n            }\n            // this will close the pump and will break us out of the while loop\n            return await this.stop(CloseReason.Shutdown);\n          } catch (err) {\n            // Using verbose over warning because this error is swallowed.\n            logger.verbose(\n              `An error occurred while closing the receiver with reason ${CloseReason.Shutdown}: `,\n              err\n            );\n          }\n        }\n      }\n    }\n  }\n\n  async stop(reason: CloseReason): Promise<void> {\n    if (this._isStopped) {\n      return;\n    }\n    this._isStopped = true;\n    this._isReceiving = false;\n    try {\n      if (this._receiver) {\n        await this._receiver.close();\n      }\n      this._abortController.abort();\n      await this._partitionProcessor.close(reason);\n    } catch (err) {\n      logger.warning(\"An error occurred while closing the receiver.\", err);\n      logErrorStackTrace(err);\n      this._partitionProcessor.processError(err);\n      throw err;\n    }\n  }\n}\n\n/**\n * @internal\n * @ignore\n */\nexport function createProcessingSpan(\n  receivedEvents: ReceivedEventData[],\n  eventHubProperties: { eventHubName: string; endpoint: string },\n  tracingOptions: TracingOptions\n): Span {\n  const links: Link[] = [];\n\n  for (const receivedEvent of receivedEvents) {\n    const spanContext = extractSpanContextFromEventData(receivedEvent);\n\n    if (spanContext == null) {\n      continue;\n    }\n\n    links.push({\n      spanContext\n    });\n  }\n\n  const span = getTracer().startSpan(\"Azure.EventHubs.process\", {\n    kind: SpanKind.CONSUMER,\n    links,\n    parent: getParentSpan(tracingOptions)\n  });\n\n  span.setAttributes({\n    \"az.namespace\": \"Microsoft.EventHub\",\n    \"message_bus.destination\": eventHubProperties.eventHubName,\n    \"peer.address\": eventHubProperties.endpoint\n  });\n\n  return span;\n}\n\n/**\n * @ignore\n * @internal\n */\nexport async function trace(fn: () => Promise<void>, span: Span): Promise<void> {\n  try {\n    await fn();\n    span.setStatus({ code: CanonicalCode.OK });\n  } catch (err) {\n    span.setStatus({\n      code: CanonicalCode.UNKNOWN,\n      message: err.message\n    });\n    throw err;\n  } finally {\n    span.end();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventHubClient } from \"./impl/eventHubClient\";\nimport { EventPosition } from \"./eventPosition\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { PartitionPump } from \"./partitionPump\";\nimport { logger, logErrorStackTrace } from \"./log\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\n\n/**\n * The PumpManager handles the creation and removal of PartitionPumps.\n * It also starts a PartitionPump when it is created, and stops a\n * PartitionPump when it is removed.\n * @ignore\n * @internal\n */\nexport interface PumpManager {\n  /**\n   * Creates and starts a PartitionPump.\n   * @param startPosition The position in the partition to start reading from.\n   * @param eventHubClient The EventHubClient to forward to the PartitionPump.\n   * @param partitionProcessor The PartitionProcessor to forward to the PartitionPump.\n   * @param abortSignal Used to cancel pump creation.\n   * @ignore\n   */\n  createPump(\n    startPosition: EventPosition,\n    eventHubClient: EventHubClient,\n    partitionProcessor: PartitionProcessor,\n    abortSignal: AbortSignalLike\n  ): Promise<void>;\n\n  /**\n   * Indicates whether the pump manager is actively receiving events from a given partition.\n   * @param partitionId The partition to check.\n   * @ignore\n   * @internal\n   */\n  isReceivingFromPartition(partitionId: string): boolean;\n\n  /**\n   * Stops all PartitionPumps and removes them from the internal map.\n   * @param reason The reason for removing the pump.\n   * @ignore\n   */\n  removeAllPumps(reason: CloseReason): Promise<void>;\n}\n\n/**\n * The PumpManager handles the creation and removal of PartitionPumps.\n * It also starts a PartitionPump when it is created, and stops a\n * PartitionPump when it is removed.\n * @ignore\n * @internal\n */\nexport class PumpManagerImpl implements PumpManager {\n  private readonly _eventProcessorName: string;\n  private readonly _options: CommonEventProcessorOptions;\n  private _partitionIdToPumps: {\n    [partitionId: string]: PartitionPump | undefined;\n  } = {};\n\n  /**\n   * @ignore\n   */\n  constructor(eventProcessorName: string, eventProcessorOptions: CommonEventProcessorOptions) {\n    this._eventProcessorName = eventProcessorName;\n    this._options = eventProcessorOptions;\n  }\n\n  /**\n   * Returns a list of partitionIds that are actively receiving messages.\n   * @ignore\n   */\n  public receivingFromPartitions(): string[] {\n    return Object.keys(this._partitionIdToPumps).filter((id) => {\n      const pump = this._partitionIdToPumps[id];\n      return Boolean(pump && pump.isReceiving);\n    });\n  }\n\n  /**\n   * Indicates whether the pump manager is actively receiving events from a given partition.\n   * @param partitionId\n   * @ignore\n   * @internal\n   */\n  public isReceivingFromPartition(partitionId: string): boolean {\n    const pump = this._partitionIdToPumps[partitionId];\n    return Boolean(pump && pump.isReceiving);\n  }\n\n  /**\n   * Creates and starts a PartitionPump.\n   * @param startPosition The position in the partition to start reading from.\n   * @param eventHubClient The EventHubClient to forward to the PartitionPump.\n   * @param partitionProcessor The PartitionProcessor to forward to the PartitionPump.\n   * @ignore\n   */\n  public async createPump(\n    startPosition: EventPosition,\n    eventHubClient: EventHubClient,\n    partitionProcessor: PartitionProcessor,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    const partitionId = partitionProcessor.partitionId;\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `${this._eventProcessorName}] The subscription was closed before creating the pump for partition ${partitionId}.`\n      );\n      return;\n    }\n    // attempt to get an existing pump\n    const existingPump = this._partitionIdToPumps[partitionId];\n    if (existingPump) {\n      if (existingPump.isReceiving) {\n        logger.verbose(\n          `[${this._eventProcessorName}] [${partitionId}] The existing pump is running.`\n        );\n        return;\n      }\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] The existing pump is not running.`\n      );\n      await this.removePump(partitionId, CloseReason.OwnershipLost);\n    }\n\n    logger.verbose(`[${this._eventProcessorName}] [${partitionId}] Creating a new pump.`);\n\n    const pump = new PartitionPump(\n      eventHubClient,\n      partitionProcessor,\n      startPosition,\n      this._options\n    );\n\n    try {\n      await pump.start();\n      this._partitionIdToPumps[partitionId] = pump;\n    } catch (err) {\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] An error occured while adding/updating a pump: ${err}`\n      );\n      logErrorStackTrace(err);\n    }\n  }\n\n  /**\n   * Stop a PartitionPump and removes it from the internal map.\n   * @param partitionId The partitionId to remove the associated PartitionPump from.\n   * @param reason The reason for removing the pump.\n   * @ignore\n   */\n  public async removePump(partitionId: string, reason: CloseReason): Promise<void> {\n    try {\n      const pump = this._partitionIdToPumps[partitionId];\n      if (pump) {\n        delete this._partitionIdToPumps[partitionId];\n        logger.verbose(`[${this._eventProcessorName}] [${partitionId}] Stopping the pump.`);\n        await pump.stop(reason);\n      } else {\n        logger.verbose(\n          `[${this._eventProcessorName}] [${partitionId}] No pump was found to remove.`\n        );\n      }\n    } catch (err) {\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] An error occured while removing a pump: ${err}`\n      );\n      logErrorStackTrace(err);\n    }\n  }\n\n  /**\n   * Stops all PartitionPumps and removes them from the internal map.\n   * @param reason The reason for removing the pump.\n   * @ignore\n   */\n  public async removeAllPumps(reason: CloseReason): Promise<void> {\n    const partitionIds = Object.keys(this._partitionIdToPumps);\n\n    logger.verbose(`[${this._eventProcessorName}] Removing all pumps due to reason ${reason}.`);\n\n    const tasks: PromiseLike<void>[] = [];\n    for (const partitionId of partitionIds) {\n      const pump = this._partitionIdToPumps[partitionId];\n      if (pump) {\n        tasks.push(pump.stop(reason));\n      }\n    }\n\n    try {\n      await Promise.all(tasks);\n    } catch (err) {\n      logger.verbose(\n        `[${this._eventProcessorName}] An error occured while removing all pumps: ${err}`\n      );\n      logErrorStackTrace(err);\n    } finally {\n      this._partitionIdToPumps = {};\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { PartitionOwnership } from \"./eventProcessor\";\nimport { logger } from \"./log\";\n\n/**\n * Implements a load balancing algorithm for determining which consumers\n * own which partitions.\n * @ignore\n * @internal\n */\nexport interface PartitionLoadBalancer {\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the new set of partitions to add.\n   * @param ownerId The id we should assume is _our_ id when checking for ownership.\n   * @param partitionOwnershipMap The current ownerships for partitions.\n   * @param partitionsToAdd New partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  loadBalance(\n    ownerId: string,\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionsToAdd: string[]\n  ): string[];\n}\n\n/**\n * This class does no load balancing - it's intended to be used when\n * you want to avoid load balancing and consume a set of partitions (or all\n * available partitions)\n * @internal\n * @ignore\n */\nexport class GreedyPartitionLoadBalancer implements PartitionLoadBalancer {\n  private partitionsToClaim?: Set<string>;\n\n  /**\n   * @param partitionIds An optional set of partition IDs. undefined means all partitions.\n   */\n  constructor(partitionIds?: string[]) {\n    logger.verbose(\n      `GreedyPartitionLoadBalancer created. Watching ${\n        partitionIds ? \"(\" + partitionIds.join(\",\") + \")\" : \"all\"\n      }.`\n    );\n    this.partitionsToClaim = partitionIds && new Set(partitionIds);\n  }\n\n  loadBalance(\n    ownerId: string,\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionsToAdd: string[]\n  ): string[] {\n    let potential: string[] = partitionsToAdd;\n\n    if (this.partitionsToClaim) {\n      const partitionsToClaim = this.partitionsToClaim;\n      potential = partitionsToAdd.filter((part) => partitionsToClaim.has(part));\n    }\n\n    return potential;\n  }\n}\n\n/**\n * This class is responsible for balancing the load of processing events from all partitions of an Event Hub by\n * distributing the number of partitions uniformly among all the active EventProcessors.\n *\n * This load balancer will retrieve partition ownership details from the CheckpointStore to find the number of\n * active EventProcessor. It uses the last modified time to decide if an EventProcessor is active. If a\n * partition ownership entry has not be updated for a specified duration of time, the owner of that partition is\n * considered inactive and the partition is available for other EventProcessors to own.\n * @class PartitionLoadBalancer\n * @internal\n * @ignore\n */\nexport class FairPartitionLoadBalancer implements PartitionLoadBalancer {\n  private _inactiveTimeLimitInMS: number;\n\n  /**\n   * Creates an instance of PartitionBasedLoadBalancer.\n   *\n   * @param ownerId The identifier of the Event Processor that owns this load balancer.\n   * @param inactiveTimeLimitInMS The time to wait for an update on an ownership record before\n   * assuming the owner of the partition is inactive.\n   * */\n  constructor(inactiveTimeLimitInMS: number) {\n    logger.verbose(\n      `FairPartitionLoadBalancer created inactive time limit: ${inactiveTimeLimitInMS}ms`\n    );\n    this._inactiveTimeLimitInMS = inactiveTimeLimitInMS;\n  }\n\n  /*\n   * Find the event processor that owns the maximum number of partitions and steal a random partition\n   * from it.\n   */\n  private _findPartitionToSteal(\n    ourOwnerId: string,\n    ownerPartitionMap: Map<string, PartitionOwnership[]>\n  ): string {\n    let maxList: PartitionOwnership[] = [];\n    let maxPartitionsOwnedByAnyEventProcessor = Number.MIN_VALUE;\n    let ownerId;\n    ownerPartitionMap.forEach((ownershipList: PartitionOwnership[], ownerId: string) => {\n      if (ownershipList.length > maxPartitionsOwnedByAnyEventProcessor) {\n        maxPartitionsOwnedByAnyEventProcessor = ownershipList.length;\n        maxList = ownershipList;\n        ownerId = ownerId;\n      }\n    });\n    logger.verbose(\n      `[${ourOwnerId}] Owner id ${ownerId} owns ${maxList.length} partitions, stealing a partition from it.`\n    );\n    return maxList[Math.floor(Math.random() * maxList.length)].partitionId;\n  }\n\n  /**\n   * Whether we should attempt to claim more partitions for this particular processor.\n   *\n   * @param minRequired The minimum required number of partitions.\n   * @param numEventProcessorsWithAdditionalPartition The current number of processors that have an additional partition.\n   * @param numPartitionsOwnedByUs The number of partitions we currently own.\n   * @param processorCounts Processors, grouped by criteria.\n   */\n  private _shouldOwnMorePartitions(\n    minRequired: number,\n    numEventProcessorsWithAdditionalPartition: number,\n    numPartitionsOwnedByUs: number,\n    processorCounts: ProcessorCounts\n  ): boolean {\n    let actualRequired = minRequired;\n\n    if (\n      numEventProcessorsWithAdditionalPartition > 0 &&\n      // eventually the `haveTooManyPartitions` will get decay into `haveAdditionalPartition`\n      // processors as partitions are balanced to consumers that aren't at par. We can\n      // consider them to be `haveAdditionalPartition` processors for our purposes.\n      processorCounts.haveAdditionalPartition + processorCounts.haveTooManyPartitions <\n        numEventProcessorsWithAdditionalPartition\n    ) {\n      // overall we don't have enough processors that are taking on an additional partition\n      // so we should attempt to.\n      actualRequired = minRequired + 1;\n    }\n\n    return numPartitionsOwnedByUs < actualRequired;\n  }\n\n  /**\n   * Validates that we are currently in a balanced state - all processors own the\n   * minimum required number of partitions (and additional partitions, if the # of partitions\n   * is not evenly divisible by the # of processors).\n   *\n   * @param requiredNumberOfEventProcessorsWithAdditionalPartition The # of processors that process an additional partition, in addition to the required minimum.\n   * @param totalExpectedProcessors The total # of processors we expect.\n   * @param processorCounts Processors, grouped by criteria.\n   */\n  private _isLoadBalanced(\n    requiredNumberOfEventProcessorsWithAdditionalPartition: number,\n    totalExpectedProcessors: number,\n    processorCounts: ProcessorCounts\n  ): boolean {\n    return (\n      processorCounts.haveAdditionalPartition ===\n        requiredNumberOfEventProcessorsWithAdditionalPartition &&\n      processorCounts.haveRequiredPartitions + processorCounts.haveAdditionalPartition ===\n        totalExpectedProcessors\n    );\n  }\n\n  /**\n   * Counts the processors and tallying them by type.\n   *\n   * To be in balance we need to make sure that each processor is only consuming\n   * their fair share.\n   *\n   * When the partitions are divvied up we will sometimes end up with some processors\n   * that will have 1 more partition than others. This can happen if the number of\n   * partitions is not evenly divisible by the number of processors.\n   *\n   * So this function largely exists to support _isLoadBalanced() and\n   * _shouldOwnMorePartitions(), both of which depend on knowing if our current list\n   * of processors is actually in the proper state.\n   *\n   * @param numPartitionsRequired The number of required partitions per processor.\n   * @param ownerPartitionMap The current ownerships for partitions.\n   */\n  private _getProcessorCounts(\n    numPartitionsRequired: number,\n    ownerPartitionMap: Map<string, PartitionOwnership[]>\n  ): ProcessorCounts {\n    const counts: ProcessorCounts = {\n      haveRequiredPartitions: 0,\n      haveAdditionalPartition: 0,\n      haveTooManyPartitions: 0\n    };\n\n    for (const ownershipList of ownerPartitionMap.values()) {\n      const numberOfPartitions = ownershipList.length;\n\n      // there are basically three kinds of partition counts\n      // for a processor:\n\n      // 1. Has _exactly_ the required number of partitions\n      if (numberOfPartitions === numPartitionsRequired) {\n        counts.haveRequiredPartitions++;\n      }\n\n      // 2. Has the required number plus one extra (correct in cases)\n      // where the # of partitions is not evenly divisible by the\n      // number of processors.\n      if (numberOfPartitions === numPartitionsRequired + 1) {\n        counts.haveAdditionalPartition++;\n      }\n\n      // 3. has more than the possible # of partitions required\n      if (numberOfPartitions > numPartitionsRequired + 1) {\n        counts.haveTooManyPartitions++;\n      }\n    }\n\n    return counts;\n  }\n\n  /*\n   * This method will create a new map of partition id and PartitionOwnership containing only those partitions\n   * that are actively owned. All entries in the original map returned by CheckpointStore that haven't been\n   * modified for a duration of time greater than the allowed inactivity time limit are assumed to be owned by\n   * dead event processors. These will not be included in the map returned by this method.\n   */\n  private _removeInactivePartitionOwnerships(\n    partitionOwnershipMap: Map<string, PartitionOwnership>\n  ): Map<string, PartitionOwnership> {\n    const activePartitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n    partitionOwnershipMap.forEach((partitionOwnership: PartitionOwnership, partitionId: string) => {\n      var date = new Date();\n      if (\n        partitionOwnership.lastModifiedTimeInMs &&\n        date.getTime() - partitionOwnership.lastModifiedTimeInMs < this._inactiveTimeLimitInMS &&\n        partitionOwnership.ownerId\n      ) {\n        activePartitionOwnershipMap.set(partitionId, partitionOwnership);\n      }\n    });\n\n    return activePartitionOwnershipMap;\n  }\n\n  /*\n   * This method works with the given partition ownership details and Event Hub partitions to evaluate whether the\n   * current Event Processor should take on the responsibility of processing more partitions.\n   */\n  loadBalance(\n    ourOwnerId: string,\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionsToAdd: string[]\n  ): string[] {\n    //  Remove all partitions ownership that have not been modified within the configured period of time. This means that the previous\n    //  event processor that owned the partition is probably down and the partition is now eligible to be\n    //  claimed by other event processors.\n    const activePartitionOwnershipMap = this._removeInactivePartitionOwnerships(\n      partitionOwnershipMap\n    );\n    logger.verbose(\n      `[${ourOwnerId}] Number of active ownership records: ${activePartitionOwnershipMap.size}.`\n    );\n    if (activePartitionOwnershipMap.size === 0) {\n      // If the active partition ownership map is empty, this is the first time an event processor is\n      // running or all Event Processors are down for this Event Hub, consumer group combination. All\n      // partitions in this Event Hub are available to claim. Choose a random partition to claim ownership.\n      return [partitionsToAdd[Math.floor(Math.random() * partitionsToAdd.length)]];\n    }\n\n    // Create a map of owner id and a list of partitions it owns\n    const ownerPartitionMap: Map<string, PartitionOwnership[]> = new Map();\n    for (const activePartitionOwnership of activePartitionOwnershipMap.values()) {\n      const partitionOwnershipArray = ownerPartitionMap.get(activePartitionOwnership.ownerId) || [];\n      partitionOwnershipArray.push(activePartitionOwnership);\n      ownerPartitionMap.set(activePartitionOwnership.ownerId, partitionOwnershipArray);\n    }\n\n    // add the current event processor to the map if it doesn't exist\n    if (!ownerPartitionMap.has(ourOwnerId)) {\n      ownerPartitionMap.set(ourOwnerId, []);\n    }\n    logger.info(`[${ourOwnerId}] Number of active event processors: ${ownerPartitionMap.size}.`);\n\n    // Include any partitions this entity already owns in the list of partitions to claim.\n    const partitionsToClaim = (ownerPartitionMap.get(ourOwnerId) || []).map(\n      (ownership) => ownership.partitionId\n    );\n\n    // Find the minimum number of partitions every event processor should own when the load is\n    // evenly distributed.\n    const minPartitionsPerEventProcessor = Math.floor(\n      partitionsToAdd.length / ownerPartitionMap.size\n    );\n    // If the number of partitions in Event Hub is not evenly divisible by number of active event processors,\n    // a few Event Processors may own 1 additional partition than the minimum when the load is balanced. Calculate\n    // the number of event processors that can own an additional partition.\n    const requiredNumberOfEventProcessorsWithAdditionalPartition =\n      partitionsToAdd.length % ownerPartitionMap.size;\n\n    logger.verbose(\n      `[${ourOwnerId}] Expected minimum number of partitions per event processor: ${minPartitionsPerEventProcessor}, \n      expected number of event processors with additional partition: ${requiredNumberOfEventProcessorsWithAdditionalPartition}.`\n    );\n\n    const processorCounts = this._getProcessorCounts(\n      minPartitionsPerEventProcessor,\n      ownerPartitionMap\n    );\n\n    if (\n      this._isLoadBalanced(\n        requiredNumberOfEventProcessorsWithAdditionalPartition,\n        ownerPartitionMap.size,\n        processorCounts\n      )\n    ) {\n      logger.info(`[${ourOwnerId}] Load is balanced.`);\n      // If the partitions are evenly distributed among all active event processors, no change required.\n      return partitionsToClaim;\n    }\n\n    if (\n      !this._shouldOwnMorePartitions(\n        minPartitionsPerEventProcessor,\n        requiredNumberOfEventProcessorsWithAdditionalPartition,\n        ownerPartitionMap.get(ourOwnerId)!.length,\n        processorCounts\n      )\n    ) {\n      logger.verbose(\n        `[${ourOwnerId}] This event processor owns ${\n          ownerPartitionMap.get(ourOwnerId)!.length\n        } partitions and shouldn't own more.`\n      );\n      // This event processor already has enough partitions and shouldn't own more yet\n      return partitionsToClaim;\n    }\n    logger.info(\n      `[${ourOwnerId}] Load is unbalanced and this event processor should own more partitions.`\n    );\n    // If we have reached this stage, this event processor has to claim/steal ownership of at least 1 more partition\n\n    //  If some partitions are unclaimed, this could be because an event processor is down and\n    //  it's partitions are now available for others to own or because event processors are just\n    //  starting up and gradually claiming partitions to own or new partitions were added to Event Hub.\n    //  Find any partition that is not actively owned and claim it.\n\n    //   OR\n\n    //  Find a partition to steal from another event processor. Pick the event processor that owns the highest\n    //  number of partitions.\n    const unOwnedPartitionIds = [];\n\n    for (const partitionId of partitionsToAdd) {\n      if (!activePartitionOwnershipMap.has(partitionId)) {\n        unOwnedPartitionIds.push(partitionId);\n      }\n    }\n    if (unOwnedPartitionIds.length === 0) {\n      logger.info(\n        `[${ourOwnerId}] No unclaimed partitions, stealing from another event processor.`\n      );\n      partitionsToClaim.push(this._findPartitionToSteal(ourOwnerId, ownerPartitionMap));\n    } else {\n      partitionsToClaim.push(\n        unOwnedPartitionIds[Math.floor(Math.random() * unOwnedPartitionIds.length)]\n      );\n    }\n\n    return partitionsToClaim;\n  }\n}\n\n/**\n * Counts of the processors that currently own partitions.\n */\ninterface ProcessorCounts {\n  /**\n   * The # of processors that only own the required # of\n   * partitions.\n   */\n  haveRequiredPartitions: number;\n  /**\n   * The # of processors that currently own the required #\n   * of partitions + 1 additional (ie, handling the case where\n   * the number of partitions is not evenly divisible by the # of\n   * processors).\n   */\n  haveAdditionalPartition: number;\n  /**\n   * Processors which have more than the required or even required + 1\n   * number of partitions. These will eventually be downsized by other\n   * processors as they acquire their required number of partitions.\n   */\n  haveTooManyPartitions: number;\n}\n","import { CheckpointStore } from \"./eventProcessor\";\nimport { CloseReason } from \"./models/public\";\nimport { ReceivedEventData } from \"./eventData\";\nimport { LastEnqueuedEventProperties } from \"./eventHubReceiver\";\nimport {\n  SubscriptionEventHandlers,\n  BasicPartitionProperties,\n  PartitionContext\n} from \"./eventHubConsumerClientModels\";\nimport { logger } from \"./log\";\n\n/**\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * When the `updateCheckpoint()` method on the `PartitionProcessor` class is called by the user, a\n * `Checkpoint` is created internally. It is then stored in the storage solution implemented by the\n * `CheckpointManager` chosen by the user when creating an `EventProcessor`.\n *\n * Users are never expected to interact with `Checkpoint` directly. This interface exists to support the\n * internal workings of `EventProcessor` and `CheckpointManager`.\n **/\nexport interface Checkpoint {\n  /**\n   * @property The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * @property The event hub name\n   */\n  eventHubName: string;\n  /**\n   * @property The consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * @property The identifier of the Event Hub partition\n   */\n  partitionId: string;\n  /**\n   * @property The sequence number of the event\n   */\n  sequenceNumber: number;\n  /**\n   * @property The offset of the event.\n   */\n  offset: number;\n}\n\n/**\n * The `PartitionProcessor` is responsible for processing events received from Event Hubs when using `EventProcessor`\n *\n * The EventProcessor creates a new instance of the PartitionProcessor for each partition of the event hub it starts processing. When you extend the `PartitionProcessor` in order to customize it as you see fit,\n * - Override the `processEvents()` method to add the code to process the received events. This is also a good place to update the checkpoints using the `updateCheckpoint()` method\n * - Optionally override the `processError()` method to handle any error that might have occurred when processing the events.\n * - Optionally override the `initialize()` method to implement any set up related tasks you would want to carry out before starting to receive events from the partition\n * - Optionally override the `close()` method to implement any tear down or clean up tasks you would want to carry out.\n * @internal\n * @ignore\n */\nexport class PartitionProcessor implements PartitionContext {\n  private _lastEnqueuedEventProperties?: LastEnqueuedEventProperties;\n\n  constructor(\n    private _eventHandlers: SubscriptionEventHandlers,\n    private _checkpointStore: CheckpointStore,\n    private _context: BasicPartitionProperties & {\n      eventProcessorId: string;\n    }\n  ) {}\n\n  /**\n   * @property Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this._lastEnqueuedEventProperties!;\n  }\n\n  /**\n   * @property Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor\n   */\n  public set lastEnqueuedEventProperties(properties: LastEnqueuedEventProperties) {\n    this._lastEnqueuedEventProperties = properties;\n  }\n\n  /**\n   * @property The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get fullyQualifiedNamespace() {\n    return this._context.fullyQualifiedNamespace;\n  }\n\n  /**\n   * @property The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get consumerGroup() {\n    return this._context.consumerGroup!;\n  }\n\n  /**\n   * @property The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get eventHubName() {\n    return this._context.eventHubName;\n  }\n\n  /**\n   * @property The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get partitionId() {\n    return this._context.partitionId;\n  }\n\n  /**\n   * @property The unique identifier of the `EventProcessor` that has spawned the current instance of `PartitionProcessor`. This is set by the `EventProcessor`\n   */\n  public get eventProcessorId() {\n    return this._context.eventProcessorId;\n  }\n\n  /**\n   * This method is called when the `EventProcessor` takes ownership of a new partition and before any\n   * events are received.\n   *\n   * @return {Promise<EventPosition>}\n   */\n  async initialize(): Promise<void> {\n    if (this._eventHandlers.processInitialize) {\n      await this._eventHandlers.processInitialize(this);\n    }\n  }\n\n  /**\n   * This method is called before the partition processor is closed by the EventProcessor.\n   *\n   * @param reason The reason for closing this partition processor.\n   * @return {Promise<void>}\n   */\n  async close(reason: CloseReason): Promise<void> {\n    if (this._eventHandlers.processClose) {\n      await this._eventHandlers.processClose(reason, this);\n    }\n  }\n\n  /**\n   * This method is called when new events are received.\n   *\n   * This is also a good place to update checkpoints as appropriate.\n   *\n   * @param event The received events to be processed.\n   * @return {Promise<void>}\n   */\n  async processEvents(events: ReceivedEventData[]): Promise<void> {\n    await this._eventHandlers.processEvents(events, this);\n  }\n\n  /**\n   * This method is called when an error occurs while receiving events from Event Hubs.\n   *\n   * @param error The error to be processed.\n   * @return {Promise<void>}\n   */\n  async processError(error: Error): Promise<void> {\n    if (this._eventHandlers.processError) {\n      try {\n        await this._eventHandlers.processError(error, this);\n      } catch (err) {\n        logger.verbose(`Error thrown from user's processError handler : ${err}`);\n      }\n    }\n  }\n\n  /**\n   * Updates the checkpoint using the event data.\n   *\n   * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n   * partition of a consumer group in an Event Hub instance.\n   *\n   * @param eventData The event that you want to update the checkpoint with.\n   * @return Promise<void>\n   */\n  public async updateCheckpoint(eventData: ReceivedEventData): Promise<void> {\n    const checkpoint: Checkpoint = {\n      fullyQualifiedNamespace: this._context.fullyQualifiedNamespace,\n      eventHubName: this._context.eventHubName,\n      consumerGroup: this._context.consumerGroup,\n      partitionId: this._context.partitionId,\n      sequenceNumber: eventData.sequenceNumber,\n      offset: eventData.offset\n    };\n\n    await this._checkpointStore!.updateCheckpoint(checkpoint);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { delay } from \"@azure/core-amqp\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\n\n/**\n * @param delayInMs The number of milliseconds to be delayed.\n * @param abortSignal The abortSignal associated with the containing operation.\n * @internal\n * @ignore\n */\nexport async function delayWithoutThrow(\n  delayInMs: number,\n  abortSignal?: AbortSignalLike\n): Promise<void> {\n  try {\n    await delay(delayInMs, abortSignal);\n  } catch {} // swallow AbortError\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport { EventHubClient } from \"./impl/eventHubClient\";\nimport { PumpManager, PumpManagerImpl } from \"./pumpManager\";\nimport { AbortController, AbortSignalLike } from \"@azure/abort-controller\";\nimport { logger, logErrorStackTrace } from \"./log\";\nimport { FairPartitionLoadBalancer, PartitionLoadBalancer } from \"./partitionLoadBalancer\";\nimport { PartitionProcessor, Checkpoint } from \"./partitionProcessor\";\nimport { SubscriptionEventHandlers } from \"./eventHubConsumerClientModels\";\nimport { EventPosition, latestEventPosition, isEventPosition } from \"./eventPosition\";\nimport { delayWithoutThrow } from \"./util/delayWithoutThrow\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\n\n/**\n * An interface representing the details on which instance of a `EventProcessor` owns processing\n * of a given partition from a consumer group of an Event Hub instance.\n *\n * **Note**: This is used internally by the `EventProcessor` and user never has to create it directly.\n */\nexport interface PartitionOwnership {\n  /**\n   * @property The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * @property The event hub name\n   */\n  eventHubName: string;\n  /**\n   * @property The consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * @property The identifier of the Event Hub partition.\n   */\n  partitionId: string;\n  /**\n   * @property The unique identifier of the event processor.\n   */\n  ownerId: string;\n  /**\n   * @property The last modified time.\n   */\n  lastModifiedTimeInMs?: number;\n  /**\n   * @property The unique identifier for the operation.\n   */\n  etag?: string;\n}\n\n/**\n * A checkpoint store stores and retrieves partition ownership information and checkpoint details\n * for each partition in a given consumer group of an event hub instance.\n *\n * Users are not meant to implement an `CheckpointStore`.\n * Users are expected to choose existing implementations of this interface, instantiate it, and pass\n * it to the `EventHubConsumerClient` class constructor when instantiating a client.\n * Users are not expected to use any of the methods on a checkpoint store, these are used internally by\n * the client.\n *\n * Implementations of `CheckpointStore` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.\n */\nexport interface CheckpointStore {\n  /**\n   * Called to get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName The event hub name.\n   * @param consumerGroup The consumer group name.\n   * @return A list of partition ownership details of all the partitions that have/had an owner.\n   */\n  listOwnership(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<PartitionOwnership[]>;\n  /**\n   * Called to claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership The list of partition ownership this instance is claiming to own.\n   * @return A list of partitions this instance successfully claimed ownership.\n   */\n  claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]>;\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint The checkpoint.\n   */\n  updateCheckpoint(checkpoint: Checkpoint): Promise<void>;\n\n  /**\n   * Lists all the checkpoints in a data store for a given namespace, eventhub and consumer group.\n   *\n   * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName The event hub name.\n   * @param consumerGroup The consumer group name.\n   */\n  listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<Checkpoint[]>;\n}\n\n/**\n * A set of options to pass to the constructor of `EventProcessor`.\n * You can specify\n * - `maxBatchSize`: The max size of the batch of events passed each time to user code for processing.\n * - `maxWaitTimeInSeconds`: The maximum amount of time to wait to build up the requested message count before\n * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n *\n * Example usage with default values:\n * ```ts\n * {\n *     maxBatchSize: 1,\n *     maxWaitTimeInSeconds: 60,\n * }\n * ```\n * @internal\n * @ignore\n */\nexport interface FullEventProcessorOptions extends CommonEventProcessorOptions {\n  /**\n   * An optional pump manager to use, rather than instantiating one internally\n   * @internal\n   * @ignore\n   */\n  pumpManager?: PumpManager;\n}\n\n/**\n * Event Processor based applications consist of one or more instances of EventProcessor which have been\n * configured to consume events from the same Event Hub and consumer group. They balance the\n * workload across different instances by distributing the partitions to be processed among themselves.\n * They also allow the user to track progress when events are processed using checkpoints.\n *\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * You need the below to create an instance of `EventProcessor`\n * - The name of the consumer group from which you want to process events\n * - An instance of `EventHubClient` class that was created for the Event Hub instance.\n * - A user implemented class that extends the `PartitionProcessor` class. To get started, you can use the\n * base class `PartitionProcessor` which simply logs the incoming events. To provide your code to process incoming\n * events, extend this class and override the `processEvents()` method. For example:\n * ```js\n * class SamplePartitionProcessor extends PartitionProcessor {\n *     async processEvents(events) {\n *        // user code to process events here\n *        // Information on the partition being processed is available as properties on the `SamplePartitionProcessor` class\n *        // use `this.updateCheckpoint()` method to update checkpoints as needed\n *     }\n * }\n * ```\n * - An instance of `CheckpointStore`. See &commat;azure/eventhubs-checkpointstore-blob for an implementation.\n * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.\n * Implementations of `CheckpointStore` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.\n *\n * @class EventProcessor\n * @internal\n * @ignore\n */\nexport class EventProcessor {\n  private _consumerGroup: string;\n  private _processorOptions: FullEventProcessorOptions;\n  private _pumpManager: PumpManager;\n  private _id: string;\n  private _isRunning: boolean = false;\n  private _loopTask?: PromiseLike<void>;\n  private _abortController?: AbortController;\n  private _processingTarget: PartitionLoadBalancer | string;\n  private _loopIntervalInMs = 10000;\n  private _inactiveTimeLimitInMs = 60000;\n\n  /**\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param eventHubClient An instance of `EventHubClient` that was created for the Event Hub instance.\n   * @param PartitionProcessorClass A user-provided class that extends the `PartitionProcessor` class.\n   * This class will be responsible for processing and checkpointing events.\n   * @param checkpointStore An instance of `CheckpointStore`. See &commat;azure/eventhubs-checkpointstore-blob for an implementation.\n   * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.\n   * @param options A set of options to configure the Event Processor\n   * - `maxBatchSize`         : The max size of the batch of events passed each time to user code for processing.\n   * - `maxWaitTimeInSeconds` : The maximum amount of time to wait to build up the requested message count before\n   * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n   */\n  constructor(\n    consumerGroup: string,\n    private _eventHubClient: EventHubClient,\n    private _subscriptionEventHandlers: SubscriptionEventHandlers,\n    private _checkpointStore: CheckpointStore,\n    options: FullEventProcessorOptions\n  ) {\n    if (options.ownerId) {\n      this._id = options.ownerId;\n      logger.verbose(`Starting event processor with ID ${this._id}`);\n    } else {\n      this._id = uuid();\n      logger.verbose(`Starting event processor with autogenerated ID ${this._id}`);\n    }\n\n    this._consumerGroup = consumerGroup;\n    this._processorOptions = options;\n    this._pumpManager =\n      options.pumpManager || new PumpManagerImpl(this._id, this._processorOptions);\n    const inactiveTimeLimitInMS = options.inactiveTimeLimitInMs || this._inactiveTimeLimitInMs;\n    this._processingTarget =\n      options.processingTarget || new FairPartitionLoadBalancer(inactiveTimeLimitInMS);\n    if (options.loopIntervalInMs) {\n      this._loopIntervalInMs = options.loopIntervalInMs;\n    }\n  }\n\n  /**\n   * The unique identifier for the EventProcessor.\n   *\n   * @return {string}\n   */\n  get id(): string {\n    return this._id;\n  }\n\n  private _createPartitionOwnershipRequest(\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIdToClaim: string\n  ): PartitionOwnership {\n    const previousPartitionOwnership = partitionOwnershipMap.get(partitionIdToClaim);\n    const partitionOwnership: PartitionOwnership = {\n      ownerId: this._id,\n      partitionId: partitionIdToClaim,\n      fullyQualifiedNamespace: this._eventHubClient.fullyQualifiedNamespace,\n      consumerGroup: this._consumerGroup,\n      eventHubName: this._eventHubClient.eventHubName,\n      etag: previousPartitionOwnership ? previousPartitionOwnership.etag : undefined\n    };\n\n    return partitionOwnership;\n  }\n\n  /*\n   * Claim ownership of the given partition if it's available\n   */\n  private async _claimOwnership(\n    ownershipRequest: PartitionOwnership,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `[${this._id}] Subscription was closed before claiming ownership of ${ownershipRequest.partitionId}.`\n      );\n      return;\n    }\n    logger.info(\n      `[${this._id}] Attempting to claim ownership of partition ${ownershipRequest.partitionId}.`\n    );\n    try {\n      const claimedOwnerships = await this._checkpointStore.claimOwnership([ownershipRequest]);\n\n      // can happen if the partition was claimed out from underneath us - we shouldn't\n      // attempt to spin up a processor.\n      if (!claimedOwnerships.length) {\n        return;\n      }\n\n      logger.info(\n        `[${this._id}] Successfully claimed ownership of partition ${ownershipRequest.partitionId}.`\n      );\n\n      await this._startPump(ownershipRequest.partitionId, abortSignal);\n    } catch (err) {\n      logger.warning(\n        `[${this.id}] Failed to claim ownership of partition ${ownershipRequest.partitionId}`\n      );\n      logErrorStackTrace(err);\n      await this._handleSubscriptionError(err);\n    }\n  }\n\n  private async _startPump(partitionId: string, abortSignal: AbortSignalLike) {\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `[${this._id}] The subscription was closed before starting to read from ${partitionId}.`\n      );\n      return;\n    }\n\n    if (this._pumpManager.isReceivingFromPartition(partitionId)) {\n      logger.verbose(\n        `[${this._id}] There is already an active partitionPump for partition \"${partitionId}\", skipping pump creation.`\n      );\n      return;\n    }\n\n    logger.verbose(\n      `[${this._id}] [${partitionId}] Calling user-provided PartitionProcessorFactory.`\n    );\n\n    const partitionProcessor = new PartitionProcessor(\n      this._subscriptionEventHandlers,\n      this._checkpointStore,\n      {\n        fullyQualifiedNamespace: this._eventHubClient.fullyQualifiedNamespace,\n        eventHubName: this._eventHubClient.eventHubName,\n        consumerGroup: this._consumerGroup,\n        partitionId: partitionId,\n        eventProcessorId: this.id\n      }\n    );\n\n    const eventPosition = await this._getStartingPosition(partitionId);\n    await this._pumpManager.createPump(\n      eventPosition,\n      this._eventHubClient,\n      partitionProcessor,\n      abortSignal\n    );\n\n    logger.verbose(`[${this._id}] PartitionPump created successfully.`);\n  }\n\n  private async _getStartingPosition(partitionIdToClaim: string): Promise<EventPosition> {\n    const availableCheckpoints = await this._checkpointStore.listCheckpoints(\n      this._eventHubClient.fullyQualifiedNamespace,\n      this._eventHubClient.eventHubName,\n      this._consumerGroup\n    );\n\n    const validCheckpoints = availableCheckpoints.filter(\n      (chk) => chk.partitionId === partitionIdToClaim\n    );\n\n    if (validCheckpoints.length > 0) {\n      return { offset: validCheckpoints[0].offset };\n    }\n\n    logger.verbose(\n      `No checkpoint found for partition ${partitionIdToClaim}. Looking for fallback.`\n    );\n    return getStartPosition(partitionIdToClaim, this._processorOptions.startPosition);\n  }\n\n  private async _runLoopForSinglePartition(\n    partitionId: string,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    while (!abortSignal.aborted) {\n      try {\n        await this._startPump(partitionId, abortSignal);\n      } catch (err) {\n        logger.warning(`[${this._id}] An error occured within the EventProcessor loop: ${err}`);\n        logErrorStackTrace(err);\n        await this._handleSubscriptionError(err);\n      } finally {\n        // sleep for some time after which we can attempt to create a pump again.\n        logger.verbose(\n          `[${this._id}] Pausing the EventProcessor loop for ${this._loopIntervalInMs} ms.`\n        );\n        // swallow errors from delay since it's fine for delay to exit early\n        await delayWithoutThrow(this._loopIntervalInMs, abortSignal);\n      }\n    }\n    this._isRunning = false;\n  }\n\n  /**\n   * Every loop to this method will result in this EventProcessor owning at most one new partition.\n   *\n   * The load is considered balanced when no active EventProcessor owns 2 partitions more than any other active\n   * EventProcessor. Given that each invocation to this method results in ownership claim of at most one partition,\n   * this algorithm converges gradually towards a steady state.\n   *\n   * When a new partition is claimed, this method is also responsible for starting a partition pump that creates an\n   * EventHubConsumer for processing events from that partition.\n   */\n\n  private async _runLoopWithLoadBalancing(\n    loadBalancer: PartitionLoadBalancer,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    // periodically check if there is any partition not being processed and process it\n    while (!abortSignal.aborted) {\n      try {\n        const partitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n        // Retrieve current partition ownership details from the datastore.\n        const partitionOwnership = await this._checkpointStore.listOwnership(\n          this._eventHubClient.fullyQualifiedNamespace,\n          this._eventHubClient.eventHubName,\n          this._consumerGroup\n        );\n\n        const abandonedMap: Map<string, PartitionOwnership> = new Map();\n\n        for (const ownership of partitionOwnership) {\n          if (isAbandoned(ownership)) {\n            abandonedMap.set(ownership.partitionId, ownership);\n            continue;\n          }\n\n          partitionOwnershipMap.set(ownership.partitionId, ownership);\n        }\n        const partitionIds = await this._eventHubClient.getPartitionIds({\n          abortSignal: abortSignal\n        });\n\n        if (abortSignal.aborted) {\n          return;\n        }\n\n        if (partitionIds.length > 0) {\n          const partitionsToClaim = loadBalancer.loadBalance(\n            this._id,\n            partitionOwnershipMap,\n            partitionIds\n          );\n          if (partitionsToClaim) {\n            for (const partitionToClaim of partitionsToClaim) {\n              let ownershipRequest: PartitionOwnership;\n\n              if (abandonedMap.has(partitionToClaim)) {\n                ownershipRequest = this._createPartitionOwnershipRequest(\n                  abandonedMap,\n                  partitionToClaim\n                );\n              } else {\n                ownershipRequest = this._createPartitionOwnershipRequest(\n                  partitionOwnershipMap,\n                  partitionToClaim\n                );\n              }\n\n              await this._claimOwnership(ownershipRequest, abortSignal);\n            }\n          }\n        }\n      } catch (err) {\n        logger.warning(`[${this._id}] An error occured within the EventProcessor loop: ${err}`);\n        logErrorStackTrace(err);\n        await this._handleSubscriptionError(err);\n      } finally {\n        // sleep for some time, then continue the loop again.\n        logger.verbose(\n          `[${this._id}] Pausing the EventProcessor loop for ${this._loopIntervalInMs} ms.`\n        );\n        // swallow the error since it's fine to exit early from delay\n        await delayWithoutThrow(this._loopIntervalInMs, abortSignal);\n      }\n    }\n    this._isRunning = false;\n  }\n\n  /**\n   * This is called when there are errors that are not specific to a partition (ex: load balancing)\n   */\n  private async _handleSubscriptionError(err: Error): Promise<void> {\n    // filter out any internal \"expected\" errors\n    if (err.name === \"AbortError\") {\n      return;\n    }\n\n    if (this._subscriptionEventHandlers.processError) {\n      try {\n        await this._subscriptionEventHandlers.processError(err, {\n          fullyQualifiedNamespace: this._eventHubClient.fullyQualifiedNamespace,\n          eventHubName: this._eventHubClient.eventHubName,\n          consumerGroup: this._consumerGroup,\n          partitionId: \"\",\n          updateCheckpoint: async () => {}\n        });\n      } catch (err) {\n        logger.verbose(\n          `[${this._id}] An error was thrown from the user's processError handler: ${err}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Starts the `EventProcessor`. Based on the number of instances of `EventProcessor` that are running for the\n   * same consumer group, the partitions are distributed among these instances to process events.\n   *\n   * For each partition, the user provided `PartitionProcessor` is instantiated.\n   *\n   * Subsequent calls to start will be ignored if this event processor is already running.\n   * Calling `start()` after `stop()` is called will restart this event processor.\n   *\n   * @return {void}\n   */\n  start(): void {\n    if (this._isRunning) {\n      logger.verbose(`[${this._id}] Attempted to start an already running EventProcessor.`);\n      return;\n    }\n\n    this._isRunning = true;\n    this._abortController = new AbortController();\n    logger.verbose(`[${this._id}] Starting an EventProcessor.`);\n\n    if (targetWithoutOwnership(this._processingTarget)) {\n      logger.verbose(`[${this._id}] Single partition target: ${this._processingTarget}`);\n      this._loopTask = this._runLoopForSinglePartition(\n        this._processingTarget,\n        this._abortController.signal\n      );\n    } else {\n      logger.verbose(`[${this._id}] Multiple partitions, using load balancer`);\n      this._loopTask = this._runLoopWithLoadBalancing(\n        this._processingTarget,\n        this._abortController.signal\n      );\n    }\n  }\n\n  isRunning() {\n    return this._isRunning;\n  }\n\n  /**\n   * Stops processing events for all partitions owned by this event processor.\n   * All `PartitionProcessor` will be shutdown and any open resources will be closed.\n   *\n   * Subsequent calls to stop will be ignored if the event processor is not running.\n   *\n   */\n  async stop(): Promise<void> {\n    logger.verbose(`[${this._id}] Stopping an EventProcessor.`);\n    if (this._abortController) {\n      // cancel the event processor loop\n      this._abortController.abort();\n    }\n\n    try {\n      // remove all existing pumps\n      await this._pumpManager.removeAllPumps(CloseReason.Shutdown);\n\n      // waits for the event processor loop to complete\n      // will complete immediately if _loopTask is undefined\n      if (this._loopTask) {\n        await this._loopTask;\n      }\n    } catch (err) {\n      logger.verbose(`[${this._id}] An error occured while stopping the EventProcessor: ${err}`);\n    } finally {\n      logger.verbose(`[${this._id}] EventProcessor stopped.`);\n    }\n\n    if (targetWithoutOwnership(this._processingTarget)) {\n      logger.verbose(`[${this._id}] No partitions owned, skipping abandoning.`);\n    } else {\n      await this.abandonPartitionOwnerships();\n    }\n  }\n\n  private async abandonPartitionOwnerships() {\n    logger.verbose(`[${this._id}] Abandoning owned partitions`);\n    const allOwnerships = await this._checkpointStore.listOwnership(\n      this._eventHubClient.fullyQualifiedNamespace,\n      this._eventHubClient.eventHubName,\n      this._consumerGroup\n    );\n    const ourOwnerships = allOwnerships.filter((ownership) => ownership.ownerId === this._id);\n    // unclaim any partitions that we currently own\n    for (const ownership of ourOwnerships) {\n      ownership.ownerId = \"\";\n    }\n    return this._checkpointStore.claimOwnership(ourOwnerships);\n  }\n}\n\nfunction isAbandoned(ownership: PartitionOwnership): boolean {\n  return ownership.ownerId === \"\";\n}\n\nfunction getStartPosition(\n  partitionIdToClaim: string,\n  startPositions?: EventPosition | { [partitionId: string]: EventPosition }\n): EventPosition {\n  if (startPositions == null) {\n    return latestEventPosition;\n  }\n\n  if (isEventPosition(startPositions)) {\n    return startPositions;\n  }\n\n  const startPosition = (startPositions as { [partitionId: string]: EventPosition })[\n    partitionIdToClaim\n  ];\n\n  if (startPosition == null) {\n    return latestEventPosition;\n  }\n\n  return startPosition;\n}\n\nfunction targetWithoutOwnership(target: PartitionLoadBalancer | string): target is string {\n  return typeof target === \"string\";\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * Used by EventHubConsumerClient to prevent accidentally spinning up multiple\n * subscriptions against the same set of partitions.\n *\n * This is needed now that EventHubConsumerClient only uses a single CheckpointStore\n * instance - otherwise users will see unpredictable results as their event processor\n * continually steals/overwrites checkpointing and ownership with itself.\n *\n * @internal\n * @ignore\n */\nexport class PartitionGate {\n  private _partitions = new Set<string>();\n\n  /**\n   * Adds a partition, throwing an Error if there is a conflict with partitions (including \"all\")\n   * that are already added.\n   *\n   * @param partitionId A partition ID or the constant \"all\"\n   */\n  add(partitionId: string | \"all\") {\n    this._validatePartitionId(partitionId);\n\n    if (\n      (partitionId === \"all\" && this._partitions.size > 0) ||\n      this._partitions.has(partitionId) ||\n      this._partitions.has(\"all\")\n    ) {\n      throw new Error(`Partition already has a subscriber.`);\n    }\n\n    this._partitions.add(partitionId);\n  }\n\n  /**\n   * Removes a partition\n   *\n   * @param partitionId A partition ID or the constant \"all\"\n   */\n  remove(partitionId: string | \"all\") {\n    this._partitions.delete(partitionId);\n  }\n\n  private _validatePartitionId(partitionId: string) {\n    if (partitionId === \"all\") {\n      return;\n    }\n\n    const partitionNumber = parseInt(partitionId, 10);\n\n    if (isNaN(partitionNumber)) {\n      throw new TypeError(`Invalid partition number ${partitionId}`);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventHubClient } from \"./impl/eventHubClient\";\nimport {\n  EventHubClientOptions,\n  GetPartitionPropertiesOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions\n} from \"./models/public\";\nimport { InMemoryCheckpointStore } from \"./inMemoryCheckpointStore\";\nimport { EventProcessor, CheckpointStore, FullEventProcessorOptions } from \"./eventProcessor\";\nimport { GreedyPartitionLoadBalancer } from \"./partitionLoadBalancer\";\nimport { TokenCredential, Constants } from \"@azure/core-amqp\";\nimport { logger } from \"./log\";\n\nimport {\n  SubscribeOptions,\n  Subscription,\n  SubscriptionEventHandlers\n} from \"./eventHubConsumerClientModels\";\nimport { isTokenCredential } from \"@azure/core-amqp\";\nimport { PartitionProperties, EventHubProperties } from \"./managementClient\";\nimport { PartitionGate } from \"./impl/partitionGate\";\nimport uuid from \"uuid/v4\";\nimport { validateEventPositions } from \"./eventPosition\";\n\nconst defaultConsumerClientOptions: Required<Pick<\n  FullEventProcessorOptions,\n  \"maxWaitTimeInSeconds\" | \"maxBatchSize\"\n>> = {\n  // to support our current \"process single event only\" workflow we'll also purposefully\n  // only request a single event at a time.\n  maxBatchSize: 1,\n  maxWaitTimeInSeconds: 60\n};\n\n/**\n * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n *\n * There are multiple ways to create an `EventHubConsumerClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.\n *\n * Optionally, you can also pass:\n * - An options bag to configure the retry policy or proxy settings.\n * - A checkpoint store that is used by the client to read checkpoints to determine the position from where it should\n * resume receiving events when your application gets restarted. The checkpoint store is also used by the client\n * to load balance multiple instances of your application.\n */\nexport class EventHubConsumerClient {\n  private _eventHubClient: EventHubClient;\n  private _partitionGate = new PartitionGate();\n  private _id = uuid();\n\n  /**\n   * @property\n   * The name of the default consumer group in the Event Hubs service.\n   */\n  static defaultConsumerGroupName: string = Constants.defaultConsumerGroup;\n\n  private _checkpointStore: CheckpointStore;\n  private _userChoseCheckpointStore: boolean;\n\n  /**\n   * @property\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._eventHubClient.eventHubName;\n  }\n\n  /**\n   * @property\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._eventHubClient.fullyQualifiedNamespace;\n  }\n\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(consumerGroup: string, connectionString: string, options?: EventHubClientOptions); // #1\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param checkpointStore A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubClientOptions\n  ); // #1.1\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    options?: EventHubClientOptions\n  ); // #2\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param checkpointStore A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubClientOptions\n  ); // #2.1\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service. See &commat;azure/identity for creating the credentials.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential,\n    options?: EventHubClientOptions\n  ); // #3\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service. See &commat;azure/identity for creating the credentials.\n   * @param checkpointStore A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential,\n    checkpointStore: CheckpointStore,\n    options?: EventHubClientOptions\n  ); // #3.1\n  constructor(\n    private _consumerGroup: string,\n    connectionStringOrFullyQualifiedNamespace2: string,\n    checkpointStoreOrEventHubNameOrOptions3?: CheckpointStore | EventHubClientOptions | string,\n    checkpointStoreOrCredentialOrOptions4?:\n      | CheckpointStore\n      | EventHubClientOptions\n      | TokenCredential,\n    checkpointStoreOrOptions5?: CheckpointStore | EventHubClientOptions,\n    options6?: EventHubClientOptions\n  ) {\n    if (isTokenCredential(checkpointStoreOrCredentialOrOptions4)) {\n      // #3 or 3.1\n      logger.info(\"Creating EventHubConsumerClient with TokenCredential.\");\n\n      let eventHubClientOptions: EventHubClientOptions | undefined;\n\n      if (isCheckpointStore(checkpointStoreOrOptions5)) {\n        // 3.1\n        this._checkpointStore = checkpointStoreOrOptions5;\n        this._userChoseCheckpointStore = true;\n        eventHubClientOptions = options6;\n      } else {\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        eventHubClientOptions = checkpointStoreOrOptions5;\n      }\n\n      this._eventHubClient = new EventHubClient(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3 as string,\n        checkpointStoreOrCredentialOrOptions4,\n        eventHubClientOptions\n      );\n    } else if (typeof checkpointStoreOrEventHubNameOrOptions3 === \"string\") {\n      // #2 or 2.1\n      logger.info(\"Creating EventHubConsumerClient with connection string and event hub name.\");\n\n      let eventHubClientOptions: EventHubClientOptions | undefined;\n\n      if (isCheckpointStore(checkpointStoreOrCredentialOrOptions4)) {\n        // 2.1\n        this._checkpointStore = checkpointStoreOrCredentialOrOptions4;\n        this._userChoseCheckpointStore = true;\n        eventHubClientOptions = checkpointStoreOrOptions5 as EventHubClientOptions | undefined;\n      } else {\n        // 2\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        eventHubClientOptions = checkpointStoreOrCredentialOrOptions4;\n      }\n\n      this._eventHubClient = new EventHubClient(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3,\n        eventHubClientOptions as EventHubClientOptions\n      );\n    } else {\n      // #1 or 1.1\n      logger.info(\"Creating EventHubConsumerClient with connection string.\");\n\n      let eventHubClientOptions: EventHubClientOptions | undefined;\n\n      if (isCheckpointStore(checkpointStoreOrEventHubNameOrOptions3)) {\n        // 1.1\n        this._checkpointStore = checkpointStoreOrEventHubNameOrOptions3;\n        this._userChoseCheckpointStore = true;\n        eventHubClientOptions = checkpointStoreOrCredentialOrOptions4 as\n          | EventHubClientOptions\n          | undefined;\n      } else {\n        // 1\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        eventHubClientOptions = checkpointStoreOrEventHubNameOrOptions3 as\n          | EventHubClientOptions\n          | undefined;\n      }\n\n      this._eventHubClient = new EventHubClient(\n        connectionStringOrFullyQualifiedNamespace2,\n        eventHubClientOptions\n      );\n    }\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  close(): Promise<void> {\n    return this._eventHubClient.close();\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<string[]> {\n    return this._eventHubClient.getPartitionIds(options);\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId The id of the partition for which information is required.\n   * @param options The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    return this._eventHubClient.getPartitionProperties(partitionId, options);\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._eventHubClient.getProperties(options);\n  }\n\n  /**\n   * Subscribe to events from all partitions.\n   *\n   * If checkpoint store is provided to the `EventHubConsumerClient` and there are multiple\n   * instances of your application, then each instance will subscribe to a subset of the\n   * partitions such that the load is balanced amongst them.\n   *\n   * Call close() on the returned object to stop receiving events.\n   *\n   * @param handlers Handlers for the lifecycle of the subscription - subscription initialization\n   *                 per partition, receiving events, handling errors and the closing\n   *                 of a subscription per partition.\n   * @param options Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }\n   */\n  subscribe(handlers: SubscriptionEventHandlers, options?: SubscribeOptions): Subscription; // #1\n  /**\n   * Subscribe to events from a single partition.\n   * Call close() on the returned object to stop receiving events.\n   *\n   * @param partitionId The id of the partition to subscribe to.\n   * @param handlers Handlers for the lifecycle of the subscription - subscription initialization\n   *                 of the partition, receiving events, handling errors and the closing\n   *                 of a subscription to the partition.\n   * @param options Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }\n   */\n\n  subscribe(\n    partitionId: string,\n    handlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): Subscription; // #2\n  subscribe(\n    handlersOrPartitionId1?: SubscriptionEventHandlers | string,\n    optionsOrHandlers2?: SubscribeOptions | SubscriptionEventHandlers,\n    possibleOptions3?: SubscribeOptions\n  ): Subscription {\n    let eventProcessor: EventProcessor;\n    let targetedPartitionId: string;\n\n    if (isSubscriptionEventHandlers(handlersOrPartitionId1)) {\n      // #1: subscribe overload - read from all partitions\n      const options = optionsOrHandlers2 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForAllPartitions(\n        handlersOrPartitionId1,\n        options\n      ));\n    } else if (\n      typeof handlersOrPartitionId1 === \"string\" &&\n      isSubscriptionEventHandlers(optionsOrHandlers2)\n    ) {\n      // #2: subscribe overload (read from specific partition IDs), don't coordinate\n      const options = possibleOptions3 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForSinglePartition(\n        handlersOrPartitionId1,\n        optionsOrHandlers2,\n        possibleOptions3\n      ));\n    } else {\n      throw new TypeError(\"Unhandled subscribe() overload\");\n    }\n\n    eventProcessor.start();\n\n    return {\n      get isRunning() {\n        return eventProcessor.isRunning();\n      },\n      close: () => {\n        this._partitionGate.remove(targetedPartitionId);\n        return eventProcessor.stop();\n      }\n    };\n  }\n\n  private createEventProcessorForAllPartitions(\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ) {\n    this._partitionGate.add(\"all\");\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        \"EventHubConsumerClient subscribing to all partitions, using a checkpoint store.\"\n      );\n    } else {\n      logger.verbose(\"EventHubConsumerClient subscribing to all partitions, no checkpoint store.\");\n    }\n\n    const eventProcessor = this._createEventProcessor(\n      this._consumerGroup,\n      this._eventHubClient,\n      subscriptionEventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...(options as SubscribeOptions),\n        ownerLevel: getOwnerLevel(options, this._userChoseCheckpointStore),\n        processingTarget: this._userChoseCheckpointStore\n          ? undefined\n          : new GreedyPartitionLoadBalancer(),\n        // make it so all the event processors process work with the same overarching owner ID\n        // this allows the EventHubConsumer to unify all the work for any processors that it spawns\n        ownerId: this._id\n      }\n    );\n\n    return { targetedPartitionId: \"all\", eventProcessor };\n  }\n\n  private createEventProcessorForSinglePartition(\n    partitionId: string,\n    eventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ) {\n    this._partitionGate.add(partitionId);\n\n    const subscribeOptions = options as SubscribeOptions | undefined;\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), using a checkpoint store.`\n      );\n    } else {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), no checkpoint store.`\n      );\n    }\n\n    const eventProcessor = this._createEventProcessor(\n      this._consumerGroup,\n      this._eventHubClient,\n      eventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...options,\n        processingTarget: partitionId,\n        ownerLevel: getOwnerLevel(subscribeOptions, this._userChoseCheckpointStore)\n      }\n    );\n\n    return { targetedPartitionId: partitionId, eventProcessor };\n  }\n\n  private _createEventProcessor(\n    consumerGroup: string,\n    eventHubClient: EventHubClient,\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    checkpointStore: CheckpointStore,\n    options: FullEventProcessorOptions\n  ) {\n    return new EventProcessor(\n      consumerGroup,\n      eventHubClient,\n      subscriptionEventHandlers,\n      checkpointStore,\n      options\n    );\n  }\n}\n\n/**\n * @internal\n * @ignore\n */\nexport function isCheckpointStore(possible: CheckpointStore | any): possible is CheckpointStore {\n  if (!possible) {\n    return false;\n  }\n\n  const checkpointStore = possible as CheckpointStore;\n\n  return (\n    typeof checkpointStore.claimOwnership === \"function\" &&\n    typeof checkpointStore.listCheckpoints === \"function\" &&\n    typeof checkpointStore.listOwnership === \"function\" &&\n    typeof checkpointStore.updateCheckpoint === \"function\"\n  );\n}\n\n/**\n * @internal\n * @ignore\n */\nfunction isSubscriptionEventHandlers(\n  possible: any | SubscriptionEventHandlers\n): possible is SubscriptionEventHandlers {\n  return typeof (possible as SubscriptionEventHandlers).processEvents === \"function\";\n}\n\nfunction getOwnerLevel(\n  options: SubscribeOptions | undefined,\n  userChoseCheckpointStore: boolean\n): number | undefined {\n  if (options && options.ownerLevel) {\n    return options.ownerLevel;\n  }\n\n  if (userChoseCheckpointStore) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { isTokenCredential, TokenCredential } from \"@azure/core-amqp\";\nimport { EventDataBatch } from \"./eventDataBatch\";\nimport { EventHubClient } from \"./impl/eventHubClient\";\nimport { EventHubProperties, PartitionProperties } from \"./managementClient\";\nimport { EventHubProducer } from \"./sender\";\nimport {\n  SendBatchOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  EventHubClientOptions,\n  CreateBatchOptions\n} from \"./models/public\";\n\n/**\n * The `EventHubProducerClient` class is used to send events to an Event Hub.\n *\n * There are multiple ways to create an `EventHubProducerClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.\n *\n * Optionally, you can also pass an options bag to configure the retry policy or proxy settings.\n *\n */\nexport class EventHubProducerClient {\n  private _client: EventHubClient;\n\n  private _producersMap: Map<string, EventHubProducer>;\n\n  /**\n   * @property\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._client.eventHubName;\n  }\n\n  /**\n   * @property\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._client.fullyQualifiedNamespace;\n  }\n\n  /**\n   * @constructor\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(connectionString: string, options?: EventHubClientOptions);\n  /**\n   * @constructor\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions);\n  /**\n   * @constructor\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service. See &commat;azure/identity for creating the credentials.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential,\n    options?: EventHubClientOptions\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    eventHubNameOrOptions2?: string | EventHubClientOptions,\n    credentialOrOptions3?: TokenCredential | EventHubClientOptions,\n    options4?: EventHubClientOptions\n  ) {\n    if (typeof eventHubNameOrOptions2 !== \"string\") {\n      this._client = new EventHubClient(\n        fullyQualifiedNamespaceOrConnectionString1,\n        eventHubNameOrOptions2\n      );\n    } else if (!isTokenCredential(credentialOrOptions3)) {\n      this._client = new EventHubClient(\n        fullyQualifiedNamespaceOrConnectionString1,\n        eventHubNameOrOptions2,\n        credentialOrOptions3\n      );\n    } else {\n      this._client = new EventHubClient(\n        fullyQualifiedNamespaceOrConnectionString1,\n        eventHubNameOrOptions2,\n        credentialOrOptions3,\n        options4\n      );\n    }\n\n    this._producersMap = new Map();\n  }\n\n  /**\n   * Creates an instance of `EventDataBatch` to which one can add events until the maximum supported size is reached.\n   * The batch can be passed to the {@link sendBatch} method of the `EventHubProducerClient` to be sent to Azure Event Hubs.\n   * @param options  Configures the behavior of the batch.\n   * - `partitionKey`  : A value that is hashed and used by the Azure Event Hubs service to determine the partition to which\n   * the events need to be sent.\n   * - `partitionId`   : Id of the partition to which the batch of events need to be sent.\n   * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   * - `abortSignal`   : A signal the request to cancel the operation.\n   * @returns Promise<EventDataBatch>\n   * @throws Error if both `partitionId` and `partitionKey` are set in the options.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal in the options.\n   */\n  async createBatch(options?: CreateBatchOptions): Promise<EventDataBatch> {\n    if (options && options.partitionId && options.partitionKey) {\n      throw new Error(\"partitionId and partitionKey cannot both be set when creating a batch\");\n    }\n\n    let producer = this._producersMap.get(\"\");\n\n    if (!producer) {\n      producer = this._client.createProducer();\n      this._producersMap.set(\"\", producer);\n    }\n\n    return producer.createBatch(options);\n  }\n\n  /**\n   * Sends a batch of events to the associated Event Hub.\n   *\n   * @param batch A batch of events that you can create using the {@link createBatch} method.\n   * @param options A set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `abortSignal`  : A signal the request to cancel the send operation.\n   *\n   * @returns Promise<void>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while sending a message.\n   * @throws Error if the underlying connection or sender has been closed.\n   */\n  async sendBatch(batch: EventDataBatch, options?: SendBatchOptions): Promise<void> {\n    let partitionId = \"\";\n\n    if (batch.partitionId) {\n      partitionId = batch.partitionId;\n    }\n\n    let producer = this._producersMap.get(partitionId);\n    if (!producer) {\n      producer = this._client.createProducer({\n        partitionId: partitionId === \"\" ? undefined : partitionId\n      });\n      this._producersMap.set(partitionId, producer);\n    }\n    return producer.send(batch, options);\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    await this._client.close();\n\n    for (const pair of this._producersMap) {\n      await pair[1].close();\n    }\n    this._producersMap.clear();\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._client.getProperties(options);\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    return this._client.getPartitionIds(options);\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId The id of the partition for which information is required.\n   * @param options The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    return this._client.getPartitionProperties(partitionId, options);\n  }\n}\n"],"names":["createClientLogger","os.type","os.release","bytesToUuid","uuid","defaultLock","SharedKeyCredential","TokenType","Constants","translate","RequestResponseLink","SenderEvents","ReceiverEvents","AbortError","generate_uuid","RetryOperationType","retry","ConnectionContextBase","ConnectionEvents","getTraceParentHeader","extractSpanContextFromTraceParentHeader","getTracer","SpanKind","message","ErrorNameConditionMapper","CanonicalCode","delay","types","isTokenCredential","parseConnectionString","EventHubConnectionConfig","ConnectionConfig","CloseReason","AbortController"],"mappings":"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"}