{"version":3,"file":"partitionLoadBalancer.js","sourceRoot":"","sources":["../../src/partitionLoadBalancer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { PartitionOwnership } from \"./eventProcessor\";\nimport { logger } from \"./log\";\n\n/**\n * Implements a load balancing algorithm for determining which consumers\n * own which partitions.\n * @ignore\n * @internal\n */\nexport interface PartitionLoadBalancer {\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the new set of partitions to add.\n   * @param ownerId The id we should assume is _our_ id when checking for ownership.\n   * @param partitionOwnershipMap The current ownerships for partitions.\n   * @param partitionsToAdd New partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  loadBalance(\n    ownerId: string,\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionsToAdd: string[]\n  ): string[];\n}\n\n/**\n * This class does no load balancing - it's intended to be used when\n * you want to avoid load balancing and consume a set of partitions (or all\n * available partitions)\n * @internal\n * @ignore\n */\nexport class GreedyPartitionLoadBalancer implements PartitionLoadBalancer {\n  private partitionsToClaim?: Set<string>;\n\n  /**\n   * @param partitionIds An optional set of partition IDs. undefined means all partitions.\n   */\n  constructor(partitionIds?: string[]) {\n    logger.verbose(\n      `GreedyPartitionLoadBalancer created. Watching ${\n        partitionIds ? \"(\" + partitionIds.join(\",\") + \")\" : \"all\"\n      }.`\n    );\n    this.partitionsToClaim = partitionIds && new Set(partitionIds);\n  }\n\n  loadBalance(\n    ownerId: string,\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionsToAdd: string[]\n  ): string[] {\n    let potential: string[] = partitionsToAdd;\n\n    if (this.partitionsToClaim) {\n      const partitionsToClaim = this.partitionsToClaim;\n      potential = partitionsToAdd.filter((part) => partitionsToClaim.has(part));\n    }\n\n    return potential;\n  }\n}\n\n/**\n * This class is responsible for balancing the load of processing events from all partitions of an Event Hub by\n * distributing the number of partitions uniformly among all the active EventProcessors.\n *\n * This load balancer will retrieve partition ownership details from the CheckpointStore to find the number of\n * active EventProcessor. It uses the last modified time to decide if an EventProcessor is active. If a\n * partition ownership entry has not be updated for a specified duration of time, the owner of that partition is\n * considered inactive and the partition is available for other EventProcessors to own.\n * @class PartitionLoadBalancer\n * @internal\n * @ignore\n */\nexport class FairPartitionLoadBalancer implements PartitionLoadBalancer {\n  private _inactiveTimeLimitInMS: number;\n\n  /**\n   * Creates an instance of PartitionBasedLoadBalancer.\n   *\n   * @param ownerId The identifier of the Event Processor that owns this load balancer.\n   * @param inactiveTimeLimitInMS The time to wait for an update on an ownership record before\n   * assuming the owner of the partition is inactive.\n   * */\n  constructor(inactiveTimeLimitInMS: number) {\n    logger.verbose(\n      `FairPartitionLoadBalancer created inactive time limit: ${inactiveTimeLimitInMS}ms`\n    );\n    this._inactiveTimeLimitInMS = inactiveTimeLimitInMS;\n  }\n\n  /*\n   * Find the event processor that owns the maximum number of partitions and steal a random partition\n   * from it.\n   */\n  private _findPartitionToSteal(\n    ourOwnerId: string,\n    ownerPartitionMap: Map<string, PartitionOwnership[]>\n  ): string {\n    let maxList: PartitionOwnership[] = [];\n    let maxPartitionsOwnedByAnyEventProcessor = Number.MIN_VALUE;\n    let ownerId;\n    ownerPartitionMap.forEach((ownershipList: PartitionOwnership[], ownerId: string) => {\n      if (ownershipList.length > maxPartitionsOwnedByAnyEventProcessor) {\n        maxPartitionsOwnedByAnyEventProcessor = ownershipList.length;\n        maxList = ownershipList;\n        ownerId = ownerId;\n      }\n    });\n    logger.verbose(\n      `[${ourOwnerId}] Owner id ${ownerId} owns ${maxList.length} partitions, stealing a partition from it.`\n    );\n    return maxList[Math.floor(Math.random() * maxList.length)].partitionId;\n  }\n\n  /**\n   * Whether we should attempt to claim more partitions for this particular processor.\n   *\n   * @param minRequired The minimum required number of partitions.\n   * @param numEventProcessorsWithAdditionalPartition The current number of processors that have an additional partition.\n   * @param numPartitionsOwnedByUs The number of partitions we currently own.\n   * @param processorCounts Processors, grouped by criteria.\n   */\n  private _shouldOwnMorePartitions(\n    minRequired: number,\n    numEventProcessorsWithAdditionalPartition: number,\n    numPartitionsOwnedByUs: number,\n    processorCounts: ProcessorCounts\n  ): boolean {\n    let actualRequired = minRequired;\n\n    if (\n      numEventProcessorsWithAdditionalPartition > 0 &&\n      // eventually the `haveTooManyPartitions` will get decay into `haveAdditionalPartition`\n      // processors as partitions are balanced to consumers that aren't at par. We can\n      // consider them to be `haveAdditionalPartition` processors for our purposes.\n      processorCounts.haveAdditionalPartition + processorCounts.haveTooManyPartitions <\n        numEventProcessorsWithAdditionalPartition\n    ) {\n      // overall we don't have enough processors that are taking on an additional partition\n      // so we should attempt to.\n      actualRequired = minRequired + 1;\n    }\n\n    return numPartitionsOwnedByUs < actualRequired;\n  }\n\n  /**\n   * Validates that we are currently in a balanced state - all processors own the\n   * minimum required number of partitions (and additional partitions, if the # of partitions\n   * is not evenly divisible by the # of processors).\n   *\n   * @param requiredNumberOfEventProcessorsWithAdditionalPartition The # of processors that process an additional partition, in addition to the required minimum.\n   * @param totalExpectedProcessors The total # of processors we expect.\n   * @param processorCounts Processors, grouped by criteria.\n   */\n  private _isLoadBalanced(\n    requiredNumberOfEventProcessorsWithAdditionalPartition: number,\n    totalExpectedProcessors: number,\n    processorCounts: ProcessorCounts\n  ): boolean {\n    return (\n      processorCounts.haveAdditionalPartition ===\n        requiredNumberOfEventProcessorsWithAdditionalPartition &&\n      processorCounts.haveRequiredPartitions + processorCounts.haveAdditionalPartition ===\n        totalExpectedProcessors\n    );\n  }\n\n  /**\n   * Counts the processors and tallying them by type.\n   *\n   * To be in balance we need to make sure that each processor is only consuming\n   * their fair share.\n   *\n   * When the partitions are divvied up we will sometimes end up with some processors\n   * that will have 1 more partition than others. This can happen if the number of\n   * partitions is not evenly divisible by the number of processors.\n   *\n   * So this function largely exists to support _isLoadBalanced() and\n   * _shouldOwnMorePartitions(), both of which depend on knowing if our current list\n   * of processors is actually in the proper state.\n   *\n   * @param numPartitionsRequired The number of required partitions per processor.\n   * @param ownerPartitionMap The current ownerships for partitions.\n   */\n  private _getProcessorCounts(\n    numPartitionsRequired: number,\n    ownerPartitionMap: Map<string, PartitionOwnership[]>\n  ): ProcessorCounts {\n    const counts: ProcessorCounts = {\n      haveRequiredPartitions: 0,\n      haveAdditionalPartition: 0,\n      haveTooManyPartitions: 0\n    };\n\n    for (const ownershipList of ownerPartitionMap.values()) {\n      const numberOfPartitions = ownershipList.length;\n\n      // there are basically three kinds of partition counts\n      // for a processor:\n\n      // 1. Has _exactly_ the required number of partitions\n      if (numberOfPartitions === numPartitionsRequired) {\n        counts.haveRequiredPartitions++;\n      }\n\n      // 2. Has the required number plus one extra (correct in cases)\n      // where the # of partitions is not evenly divisible by the\n      // number of processors.\n      if (numberOfPartitions === numPartitionsRequired + 1) {\n        counts.haveAdditionalPartition++;\n      }\n\n      // 3. has more than the possible # of partitions required\n      if (numberOfPartitions > numPartitionsRequired + 1) {\n        counts.haveTooManyPartitions++;\n      }\n    }\n\n    return counts;\n  }\n\n  /*\n   * This method will create a new map of partition id and PartitionOwnership containing only those partitions\n   * that are actively owned. All entries in the original map returned by CheckpointStore that haven't been\n   * modified for a duration of time greater than the allowed inactivity time limit are assumed to be owned by\n   * dead event processors. These will not be included in the map returned by this method.\n   */\n  private _removeInactivePartitionOwnerships(\n    partitionOwnershipMap: Map<string, PartitionOwnership>\n  ): Map<string, PartitionOwnership> {\n    const activePartitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n    partitionOwnershipMap.forEach((partitionOwnership: PartitionOwnership, partitionId: string) => {\n      var date = new Date();\n      if (\n        partitionOwnership.lastModifiedTimeInMs &&\n        date.getTime() - partitionOwnership.lastModifiedTimeInMs < this._inactiveTimeLimitInMS &&\n        partitionOwnership.ownerId\n      ) {\n        activePartitionOwnershipMap.set(partitionId, partitionOwnership);\n      }\n    });\n\n    return activePartitionOwnershipMap;\n  }\n\n  /*\n   * This method works with the given partition ownership details and Event Hub partitions to evaluate whether the\n   * current Event Processor should take on the responsibility of processing more partitions.\n   */\n  loadBalance(\n    ourOwnerId: string,\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionsToAdd: string[]\n  ): string[] {\n    //  Remove all partitions ownership that have not been modified within the configured period of time. This means that the previous\n    //  event processor that owned the partition is probably down and the partition is now eligible to be\n    //  claimed by other event processors.\n    const activePartitionOwnershipMap = this._removeInactivePartitionOwnerships(\n      partitionOwnershipMap\n    );\n    logger.verbose(\n      `[${ourOwnerId}] Number of active ownership records: ${activePartitionOwnershipMap.size}.`\n    );\n    if (activePartitionOwnershipMap.size === 0) {\n      // If the active partition ownership map is empty, this is the first time an event processor is\n      // running or all Event Processors are down for this Event Hub, consumer group combination. All\n      // partitions in this Event Hub are available to claim. Choose a random partition to claim ownership.\n      return [partitionsToAdd[Math.floor(Math.random() * partitionsToAdd.length)]];\n    }\n\n    // Create a map of owner id and a list of partitions it owns\n    const ownerPartitionMap: Map<string, PartitionOwnership[]> = new Map();\n    for (const activePartitionOwnership of activePartitionOwnershipMap.values()) {\n      const partitionOwnershipArray = ownerPartitionMap.get(activePartitionOwnership.ownerId) || [];\n      partitionOwnershipArray.push(activePartitionOwnership);\n      ownerPartitionMap.set(activePartitionOwnership.ownerId, partitionOwnershipArray);\n    }\n\n    // add the current event processor to the map if it doesn't exist\n    if (!ownerPartitionMap.has(ourOwnerId)) {\n      ownerPartitionMap.set(ourOwnerId, []);\n    }\n    logger.info(`[${ourOwnerId}] Number of active event processors: ${ownerPartitionMap.size}.`);\n\n    // Include any partitions this entity already owns in the list of partitions to claim.\n    const partitionsToClaim = (ownerPartitionMap.get(ourOwnerId) || []).map(\n      (ownership) => ownership.partitionId\n    );\n\n    // Find the minimum number of partitions every event processor should own when the load is\n    // evenly distributed.\n    const minPartitionsPerEventProcessor = Math.floor(\n      partitionsToAdd.length / ownerPartitionMap.size\n    );\n    // If the number of partitions in Event Hub is not evenly divisible by number of active event processors,\n    // a few Event Processors may own 1 additional partition than the minimum when the load is balanced. Calculate\n    // the number of event processors that can own an additional partition.\n    const requiredNumberOfEventProcessorsWithAdditionalPartition =\n      partitionsToAdd.length % ownerPartitionMap.size;\n\n    logger.verbose(\n      `[${ourOwnerId}] Expected minimum number of partitions per event processor: ${minPartitionsPerEventProcessor}, \n      expected number of event processors with additional partition: ${requiredNumberOfEventProcessorsWithAdditionalPartition}.`\n    );\n\n    const processorCounts = this._getProcessorCounts(\n      minPartitionsPerEventProcessor,\n      ownerPartitionMap\n    );\n\n    if (\n      this._isLoadBalanced(\n        requiredNumberOfEventProcessorsWithAdditionalPartition,\n        ownerPartitionMap.size,\n        processorCounts\n      )\n    ) {\n      logger.info(`[${ourOwnerId}] Load is balanced.`);\n      // If the partitions are evenly distributed among all active event processors, no change required.\n      return partitionsToClaim;\n    }\n\n    if (\n      !this._shouldOwnMorePartitions(\n        minPartitionsPerEventProcessor,\n        requiredNumberOfEventProcessorsWithAdditionalPartition,\n        ownerPartitionMap.get(ourOwnerId)!.length,\n        processorCounts\n      )\n    ) {\n      logger.verbose(\n        `[${ourOwnerId}] This event processor owns ${\n          ownerPartitionMap.get(ourOwnerId)!.length\n        } partitions and shouldn't own more.`\n      );\n      // This event processor already has enough partitions and shouldn't own more yet\n      return partitionsToClaim;\n    }\n    logger.info(\n      `[${ourOwnerId}] Load is unbalanced and this event processor should own more partitions.`\n    );\n    // If we have reached this stage, this event processor has to claim/steal ownership of at least 1 more partition\n\n    //  If some partitions are unclaimed, this could be because an event processor is down and\n    //  it's partitions are now available for others to own or because event processors are just\n    //  starting up and gradually claiming partitions to own or new partitions were added to Event Hub.\n    //  Find any partition that is not actively owned and claim it.\n\n    //   OR\n\n    //  Find a partition to steal from another event processor. Pick the event processor that owns the highest\n    //  number of partitions.\n    const unOwnedPartitionIds = [];\n\n    for (const partitionId of partitionsToAdd) {\n      if (!activePartitionOwnershipMap.has(partitionId)) {\n        unOwnedPartitionIds.push(partitionId);\n      }\n    }\n    if (unOwnedPartitionIds.length === 0) {\n      logger.info(\n        `[${ourOwnerId}] No unclaimed partitions, stealing from another event processor.`\n      );\n      partitionsToClaim.push(this._findPartitionToSteal(ourOwnerId, ownerPartitionMap));\n    } else {\n      partitionsToClaim.push(\n        unOwnedPartitionIds[Math.floor(Math.random() * unOwnedPartitionIds.length)]\n      );\n    }\n\n    return partitionsToClaim;\n  }\n}\n\n/**\n * Counts of the processors that currently own partitions.\n */\ninterface ProcessorCounts {\n  /**\n   * The # of processors that only own the required # of\n   * partitions.\n   */\n  haveRequiredPartitions: number;\n  /**\n   * The # of processors that currently own the required #\n   * of partitions + 1 additional (ie, handling the case where\n   * the number of partitions is not evenly divisible by the # of\n   * processors).\n   */\n  haveAdditionalPartition: number;\n  /**\n   * Processors which have more than the required or even required + 1\n   * number of partitions. These will eventually be downsized by other\n   * processors as they acquire their required number of partitions.\n   */\n  haveTooManyPartitions: number;\n}\n"]}