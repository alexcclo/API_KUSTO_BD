{"version":3,"file":"receiver.js","sourceRoot":"","sources":["../../src/receiver.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC;;AAElC,OAAO,EAAE,MAAM,EAAE,kBAAkB,EAAE,MAAM,OAAO,CAAC;AAGnD,OAAO,EAGL,gBAAgB,EAEjB,MAAM,oBAAoB,CAAC;AAE5B,OAAO,EAEL,SAAS,EACT,kBAAkB,EAClB,KAAK,EAGN,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAmB,UAAU,EAAE,MAAM,yBAAyB,CAAC;AACtE,OAAO,EAAE,4BAA4B,EAAE,MAAM,cAAc,CAAC;AAE5D,OAAO,oCAAoC,CAAC;AAE5C;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,MAAM,OAAO,gBAAgB;IA0F3B;;;;;;;OAOG;IACH,YACE,OAA0B,EAC1B,aAAqB,EACrB,WAAmB,EACnB,aAA4B,EAC5B,OAAiC;QA7FnC;;WAEG;QACK,cAAS,GAAY,KAAK,CAAC;QA4FjC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,cAAc,GAAG,aAAa,CAAC;QACpC,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,4BAA4B,GAAG,EAAE,CAAC;QACvC,IAAI,CAAC,gBAAgB,GAAG,OAAO,IAAI,EAAE,CAAC;QACtC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,gBAAgB,CAAC,YAAY,IAAI,EAAE,CAAC;QAC9D,IAAI,CAAC,aAAa,GAAG,IAAI,gBAAgB,CACvC,OAAO,EACP,aAAa,EACb,WAAW,EACX,aAAa,EACb,OAAO,CACR,CAAC;IACJ,CAAC;IAtFD;;;;;OAKG;IACH,IAAW,2BAA2B;QACpC,OAAO,IAAI,CAAC,4BAA4B,CAAC;IAC3C,CAAC;IAED;;;;OAIG;IACH,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC;IAClE,CAAC;IAED;;;;OAIG;IACH,IAAW,WAAW;QACpB,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED;;;;OAIG;IACH,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,cAAc,CAAC;IAC7B,CAAC;IAED;;;;;;;;OAQG;IACH,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC;IAC1C,CAAC;IAED;;;OAGG;IACH,IAAI,mBAAmB;QACrB,OAAO,OAAO,CAAC,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC,CAAC;IAC/E,CAAC;IA+BD;;;;;;;;;;;;;;OAcG;IACH,OAAO,CAAC,SAAoB,EAAE,OAAgB,EAAE,WAA6B;QAC3E,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,MAAM,YAAY,GAAG,IAAI,CAAC,aAAc,CAAC;QAEzC,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;YACnC,MAAM,IAAI,SAAS,CAAC,uDAAuD,CAAC,CAAC;SAC9E;QACD,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;YACjC,MAAM,IAAI,SAAS,CAAC,qDAAqD,CAAC,CAAC;SAC5E;QAED,4DAA4D;QAC5D,IAAI,WAAW,IAAI,WAAW,CAAC,OAAO,EAAE;YACtC,OAAO,CAAC,IAAI,UAAU,CAAC,uDAAuD,CAAC,CAAC,CAAC;YACjF,yDAAyD;YACzD,IAAI,CAAC,KAAK,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC,CAAC,4BAA4B;YAC1D,OAAO,IAAI,cAAc,CAAC,YAAY,CAAC,CAAC;SACzC;QAED,MAAM,cAAc,GAAG,CAAC,KAAY,EAAE,EAAE;YACtC,0BAA0B;YAC1B,IAAK,KAAwB,CAAC,SAAS,EAAE;gBACvC,OAAO;aACR;YAED,MAAM,CAAC,OAAO,CACZ,2GAA2G,EAC3G,IAAI,CAAC,QAAQ,CAAC,YAAY,CAC3B,CAAC;YACF,kBAAkB,CAAC,KAAK,CAAC,CAAC;YAE1B,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;gBAC/B,yDAAyD;gBACzD,IAAI,CAAC,KAAK,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC,CAAC,4BAA4B;aAC3D;YACD,OAAO,CAAC,KAAK,CAAC,CAAC;QACjB,CAAC,CAAC;QAEF,MAAM,OAAO,GAAG,GAAG,EAAE;YACnB,IAAI,IAAI,CAAC,aAAa,EAAE;gBACtB,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;aAC5B;QACH,CAAC,CAAC;QAEF,YAAY,CAAC,gBAAgB,CAC3B,SAAS,EACT,cAAc,EACd,SAAS,CAAC,oBAAoB,EAC9B,IAAI,EACJ,WAAW,EACX,OAAO,CACR,CAAC;QAEF,IACE,IAAI,CAAC,gBAAgB,CAAC,gCAAgC;YACtD,IAAI,CAAC,aAAa;YAClB,IAAI,CAAC,aAAa,CAAC,WAAW,EAC9B;YACA,IAAI,CAAC,4BAA4B,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;SACpE;QAED,OAAO,IAAI,cAAc,CAAC,YAAY,CAAC,CAAC;IAC1C,CAAC;IAED;;;;;;;;;;;;;;;OAeG;IACG,YAAY,CAChB,eAAuB,EACvB,uBAA+B,EAAE,EACjC,WAA6B;;YAE7B,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAEhC,uCAAuC;YACvC,MAAM,cAAc,GAAwB,EAAE,CAAC;YAE/C,MAAM,cAAc,GAAG,GAAiC,EAAE;gBACxD,OAAO,IAAI,OAAO,CAAC,CAAO,OAAO,EAAE,MAAM,EAAE,EAAE;oBAC3C,iEAAiE;oBACjE,6EAA6E;oBAC7E,4CAA4C;oBAC5C,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;wBACvB,OAAO,OAAO,CAAC,cAAc,CAAC,CAAC;qBAChC;oBAED,IAAI,KAAU,CAAC;oBACf,MAAM,UAAU,GAAG,GAAS,EAAE;wBAC5B,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC;wBACxC,MAAM,IAAI,GAAG,YAAY,IAAI,YAAY,CAAC,IAAI,CAAC;wBAC/C,MAAM,OAAO,GAAG,YAAY,IAAI,YAAY,CAAC,OAAO,CAAC;wBACrD,MAAM,IAAI,GACR,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,4CAA4C,IAAI,SAAS;4BACvF,YAAY,OAAO,mCAAmC,CAAC;wBACzD,oDAAoD;wBACpD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACpB,CAAC,CAAC;oBAEF,MAAM,aAAa,GAAG,GAAwB,EAAE;wBAC9C,UAAU,EAAE,CAAC;wBACb,IAAI;4BACF,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;yBACpB;gCAAS;4BACR,OAAO,MAAM,CAAC,IAAI,UAAU,CAAC,uDAAuD,CAAC,CAAC,CAAC;yBACxF;oBACH,CAAC,CAAA,CAAC;oBAEF,oDAAoD;oBACpD,IAAI,WAAW,IAAI,WAAW,CAAC,OAAO,EAAE;wBACtC,OAAO,MAAM,aAAa,EAAE,CAAC;qBAC9B;oBAED,2DAA2D;oBAC3D,sEAAsE;oBACtE,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,eAAe,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;oBAC3E,IAAI,aAAa,KAAK,CAAC,EAAE;wBACvB,OAAO,OAAO,CAAC,cAAc,CAAC,CAAC;qBAChC;oBAED,MAAM,CAAC,OAAO,CACZ,uDAAuD,EACvD,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,EAC7C,aAAa,CACd,CAAC;oBAEF,MAAM,mBAAmB,GAAG,GAAS,EAAE;wBACrC,IAAI,IAAI,CAAC,aAAa,EAAE;4BACtB,IAAI,CAAC,aAAa,CAAC,aAAa,EAAE,CAAC;yBACpC;wBACD,YAAY,CAAC,KAAK,CAAC,CAAC;oBACtB,CAAC,CAAC;oBAEF,MAAM,OAAO,GAAG,GAAS,EAAE;wBACzB,YAAY,CAAC,KAAK,CAAC,CAAC;wBACpB,aAAa,EAAE,CAAC;oBAClB,CAAC,CAAC;oBAEF,IAAI,CAAC,aAAa,CAAC,gBAAgB,CACjC,CAAC,SAAS,EAAE,EAAE;wBACZ,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;wBAC/B,IACE,IAAI,CAAC,gBAAgB,CAAC,gCAAgC;4BACtD,IAAI,CAAC,aAAa;4BAClB,IAAI,CAAC,aAAa,CAAC,WAAW,EAC9B;4BACA,IAAI,CAAC,4BAA4B,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;yBACpE;wBACD,sDAAsD;wBACtD,iCAAiC;wBACjC,IAAI,cAAc,CAAC,MAAM,KAAK,eAAe,EAAE;4BAC7C,MAAM,CAAC,IAAI,CACT,sEAAsE,EACtE,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,EAC7C,cAAc,CAAC,MAAM,EACrB,oBAAoB,CACrB,CAAC;4BACF,mBAAmB,EAAE,CAAC;4BACtB,OAAO,CAAC,cAAc,CAAC,CAAC;yBACzB;oBACH,CAAC,EACD,CAAC,GAAG,EAAE,EAAE;wBACN,mBAAmB,EAAE,CAAC;wBACtB,IAAI,GAAG,CAAC,IAAI,KAAK,YAAY,EAAE;4BAC7B,aAAa,EAAE,CAAC;yBACjB;6BAAM;4BACL,MAAM,CAAC,GAAG,CAAC,CAAC;yBACb;oBACH,CAAC,EACD,eAAe,GAAG,cAAc,CAAC,MAAM,EACvC,KAAK,EACL,WAAW,EACX,OAAO,CACR,CAAC;oBAEF,MAAM,UAAU,GAAG,GAAS,EAAE;wBAC5B,MAAM,GAAG,GAAG,+DAA+D,CAAC;wBAC5E,MAAM,CAAC,OAAO,CACZ,GAAG,EACH,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,oBAAoB,EACpB,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,CAC9C,CAAC;wBAEF,sDAAsD;wBACtD,qCAAqC;wBACrC,KAAK,GAAG,UAAU,CAAC,GAAG,EAAE;4BACtB,MAAM,CAAC,IAAI,CACT,6FAA6F,EAC7F,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,EAC7C,cAAc,CAAC,MAAM,EACrB,oBAAoB,CACrB,CAAC;4BACF,mBAAmB,EAAE,CAAC;4BACtB,OAAO,CAAC,cAAc,CAAC,CAAC;wBAC1B,CAAC,EAAE,oBAAoB,GAAG,IAAI,CAAC,CAAC;oBAClC,CAAC,CAAC;oBAEF,UAAU,EAAE,CAAC;oBACb,IAAI,WAAW,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE;wBACvC,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;qBAChD;gBACH,CAAC,CAAA,CAAC,CAAC;YACL,CAAC,CAAC;YAEF,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC;YACxC,MAAM,MAAM,GAAqC;gBAC/C,cAAc,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;gBACzC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,SAAS,EAAE,cAAc;gBACzB,aAAa,EAAE,kBAAkB,CAAC,cAAc;gBAChD,WAAW,EAAE,WAAW;gBACxB,YAAY,EAAE,YAAY;aAC3B,CAAC;YACF,OAAO,KAAK,CAAsB,MAAM,CAAC,CAAC;QAC5C,CAAC;KAAA;IAED;;;;;;;;OAQG;IACG,KAAK;;YACT,IAAI;gBACF,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE;oBACjE,IAAI,IAAI,CAAC,aAAa,EAAE;wBACtB,MAAM,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;wBACjC,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC,CAAC;qBAC7B;iBACF;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,GAAG,CAAC;aACX;oBAAS;gBACR,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;aACvB;QACH,CAAC;KAAA;IAEO,wBAAwB;QAC9B,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC5B,MAAM,YAAY,GAAG,6BAA6B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,kCAAkC,CAAC;YACpH,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtC,MAAM,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,MAAM,EAAE,KAAK,CAAC,CAAC;YAC5D,kBAAkB,CAAC,KAAK,CAAC,CAAC;YAC1B,MAAM,KAAK,CAAC;SACb;IACH,CAAC;IAEO,kCAAkC;QACxC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC5C,IAAI,CAAC,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,QAAQ,EAAE;YACxC,MAAM,YAAY,GAChB,6BAA6B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,+CAA+C;gBAC3G,iGAAiG,CAAC;YACpG,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtC,MAAM,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,MAAM,EAAE,KAAK,CAAC,CAAC;YAC1D,kBAAkB,CAAC,KAAK,CAAC,CAAC;YAC1B,MAAM,KAAK,CAAC;SACb;IACH,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { logger, logErrorStackTrace } from \"./log\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { EventHubConsumerOptions } from \"./impl/eventHubClient\";\nimport {\n  OnMessage,\n  OnError,\n  EventHubReceiver,\n  LastEnqueuedEventProperties\n} from \"./eventHubReceiver\";\nimport { ReceivedEventData } from \"./eventData\";\nimport {\n  RetryConfig,\n  Constants,\n  RetryOperationType,\n  retry,\n  MessagingError,\n  RetryOptions\n} from \"@azure/core-amqp\";\nimport { ReceiveHandler } from \"./receiveHandler\";\nimport { AbortSignalLike, AbortError } from \"@azure/abort-controller\";\nimport { throwErrorIfConnectionClosed } from \"./util/error\";\nimport { EventPosition } from \"./eventPosition\";\nimport \"@azure/core-asynciterator-polyfill\";\n\n/**\n * A consumer is responsible for reading `EventData` from a specific Event Hub partition\n * in the context of a specific consumer group.\n * To create a consumer use the `createConsumer()` method on your `EventHubClient`.\n *\n * You can pass the below in the `options` when creating a consumer.\n * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other\n * consumers to fail if their `ownerLevel` is lower or doesn't exist.\n * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.\n *\n * Multiple consumers are allowed on the same partition in a consumer group.\n * If there is a need to have an exclusive consumer for a partition in a consumer group,\n * then specify the `ownerLevel` in the `options`.\n * Exclusive consumers were previously referred to as \"Epoch Receivers\".\n *\n * The consumer can be used to receive messages in a batch using `receiveBatch()` or by registering handlers\n * by using `receive()` or via an async iterable got by using `getEventIterator()`\n * @class\n * @ignore\n * @internal\n */\nexport class EventHubConsumer {\n  private _baseConsumer?: EventHubReceiver;\n  /**\n   * @property Describes the amqp connection context for the QueueClient.\n   */\n  private _context: ConnectionContext;\n  /**\n   * @property The consumer group from which the receiver should receive events from.\n   */\n  private _consumerGroup: string;\n  /**\n   * @property Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n  /**\n   * @property The identifier of the Event Hub partition that this consumer is associated with.\n   * Events will be read only from this partition.\n   */\n  private _partitionId: string;\n  /**\n   * @property The set of options to configure the behavior of an EventHubConsumer.\n   */\n  private _receiverOptions: EventHubConsumerOptions;\n  /**\n   * @property The set of retry options to configure the receiveBatch operation.\n   */\n  private _retryOptions: RetryOptions;\n  /**\n   * @property A set of information about the last enqueued event of a partition.\n   */\n  private _lastEnqueuedEventProperties: LastEnqueuedEventProperties;\n\n  /**\n   * @property The last enqueued event information. This property will only\n   * be enabled when `trackLastEnqueuedEventProperties` option is set to true in the\n   * `client.createConsumer()` method.\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this._lastEnqueuedEventProperties;\n  }\n\n  /**\n   * @property Returns `true` if the consumer is closed. This can happen either because the consumer\n   * itself has been closed or the client that created it has been closed.\n   * @readonly\n   */\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  /**\n   * @property The identifier of the Event Hub partition that this consumer is associated with.\n   * Events will be read only from this partition.\n   * @readonly\n   */\n  public get partitionId(): string {\n    return this._partitionId;\n  }\n\n  /**\n   * @property The name of the consumer group that this consumer is associated with.\n   * Events will be read only in the context of this group.\n   * @readonly\n   */\n  get consumerGroup(): string {\n    return this._consumerGroup;\n  }\n\n  /**\n   * @property The owner level associated with an exclusive consumer; for a non-exclusive consumer, this value will be null or undefined.\n   *\n   * When provided, the owner level indicates that a consumer is intended to be the exclusive receiver of events for the\n   * requested partition and the associated consumer group.\n   * When multiple consumers exist for the same partition/consumer group pair, then the ones with lower or no\n   * `ownerLevel` will get a `ReceiverDisconnectedError` during the next attempted receive operation.\n   * @readonly\n   */\n  get ownerLevel(): number | undefined {\n    return this._receiverOptions.ownerLevel;\n  }\n\n  /**\n   * Indicates whether the consumer is currently receiving messages or not.\n   * When this returns true, new `receive()` or `receiveBatch()` calls cannot be made.\n   */\n  get isReceivingMessages(): boolean {\n    return Boolean(this._baseConsumer && this._baseConsumer.isReceivingMessages);\n  }\n\n  /**\n   * EventHubConsumer should not be constructed using `new EventHubConsumer()`\n   * Use the `createConsumer()` method on your `EventHubClient` instead.\n   * @private\n   * @constructor\n   * @internal\n   * @ignore\n   */\n  constructor(\n    context: ConnectionContext,\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options?: EventHubConsumerOptions\n  ) {\n    this._context = context;\n    this._consumerGroup = consumerGroup;\n    this._partitionId = partitionId;\n    this._lastEnqueuedEventProperties = {};\n    this._receiverOptions = options || {};\n    this._retryOptions = this._receiverOptions.retryOptions || {};\n    this._baseConsumer = new EventHubReceiver(\n      context,\n      consumerGroup,\n      partitionId,\n      eventPosition,\n      options\n    );\n  }\n  /**\n   * Starts receiving events from the service and calls the user provided message handler for each event.\n   * Returns an object that can be used to query the state of the receiver and to stop receiving events as well.\n   *\n   * @param onMessage The message handler to receive event data objects.\n   * @param onError The error handler for errora that can occur when receiving events.\n   * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   * @returns ReceiveHandler - An object that provides a mechanism to stop receiving more messages.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws TypeError if a required parameter is missing.\n   * @throws Error if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws Error if the receiver is already receiving messages.\n   */\n  receive(onMessage: OnMessage, onError: OnError, abortSignal?: AbortSignalLike): ReceiveHandler {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    const baseConsumer = this._baseConsumer!;\n\n    if (typeof onMessage !== \"function\") {\n      throw new TypeError(\"The parameter 'onMessage' must be of type 'function'.\");\n    }\n    if (typeof onError !== \"function\") {\n      throw new TypeError(\"The parameter 'onError' must be of type 'function'.\");\n    }\n\n    // return immediately if the abortSignal is already aborted.\n    if (abortSignal && abortSignal.aborted) {\n      onError(new AbortError(\"The receive operation has been cancelled by the user.\"));\n      // close this receiver when user triggers a cancellation.\n      this.close().catch(() => {}); // no-op close error handler\n      return new ReceiveHandler(baseConsumer);\n    }\n\n    const wrappedOnError = (error: Error) => {\n      // ignore retryable errors\n      if ((error as MessagingError).retryable) {\n        return;\n      }\n\n      logger.warning(\n        \"[%s] Since the error is not retryable, we let the user know about it by calling the user's error handler.\",\n        this._context.connectionId\n      );\n      logErrorStackTrace(error);\n\n      if (error.name === \"AbortError\") {\n        // close this receiver when user triggers a cancellation.\n        this.close().catch(() => {}); // no-op close error handler\n      }\n      onError(error);\n    };\n\n    const onAbort = () => {\n      if (this._baseConsumer) {\n        this._baseConsumer.abort();\n      }\n    };\n\n    baseConsumer.registerHandlers(\n      onMessage,\n      wrappedOnError,\n      Constants.defaultPrefetchCount,\n      true,\n      abortSignal,\n      onAbort\n    );\n\n    if (\n      this._receiverOptions.trackLastEnqueuedEventProperties &&\n      this._baseConsumer &&\n      this._baseConsumer.runtimeInfo\n    ) {\n      this._lastEnqueuedEventProperties = this._baseConsumer.runtimeInfo;\n    }\n\n    return new ReceiveHandler(baseConsumer);\n  }\n\n  /**\n   * Returns a promise that resolves to an array of events received from the service.\n   *\n   * @param maxMessageCount The maximum number of messages to receive.\n   * @param maxWaitTimeInSeconds The maximum amount of time to wait to build up the requested message count;\n   * If not provided, it defaults to 60 seconds.\n   * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @returns Promise<ReceivedEventData[]>.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while receiving a message.\n   * @throws Error if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws Error if the receiver is already receiving messages.\n   */\n  async receiveBatch(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds: number = 60,\n    abortSignal?: AbortSignalLike\n  ): Promise<ReceivedEventData[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n\n    // store events across multiple retries\n    const receivedEvents: ReceivedEventData[] = [];\n\n    const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n      return new Promise(async (resolve, reject) => {\n        // if this consumer was closed, _baseConsumer might be undefined.\n        // resolve the operation's promise with the events collected thus far in case\n        // the promise hasn't already been resolved.\n        if (!this._baseConsumer) {\n          return resolve(receivedEvents);\n        }\n\n        let timer: any;\n        const logOnAbort = (): void => {\n          const baseConsumer = this._baseConsumer;\n          const name = baseConsumer && baseConsumer.name;\n          const address = baseConsumer && baseConsumer.address;\n          const desc: string =\n            `[${this._context.connectionId}] The request operation on the Receiver \"${name}\" with ` +\n            `address \"${address}\" has been cancelled by the user.`;\n          // Cancellation is intentional so logging to 'info'.\n          logger.info(desc);\n        };\n\n        const rejectOnAbort = async (): Promise<void> => {\n          logOnAbort();\n          try {\n            await this.close();\n          } finally {\n            return reject(new AbortError(\"The receive operation has been cancelled by the user.\"));\n          }\n        };\n\n        // operation has been cancelled, so exit immediately\n        if (abortSignal && abortSignal.aborted) {\n          return await rejectOnAbort();\n        }\n\n        // updates the prefetch count so that the baseConsumer adds\n        // the correct number of credits to receive the same number of events.\n        const prefetchCount = Math.max(maxMessageCount - receivedEvents.length, 0);\n        if (prefetchCount === 0) {\n          return resolve(receivedEvents);\n        }\n\n        logger.verbose(\n          \"[%s] Receiver '%s', setting the prefetch count to %d.\",\n          this._context.connectionId,\n          this._baseConsumer && this._baseConsumer.name,\n          prefetchCount\n        );\n\n        const cleanUpBeforeReturn = (): void => {\n          if (this._baseConsumer) {\n            this._baseConsumer.clearHandlers();\n          }\n          clearTimeout(timer);\n        };\n\n        const onAbort = (): void => {\n          clearTimeout(timer);\n          rejectOnAbort();\n        };\n\n        this._baseConsumer.registerHandlers(\n          (eventData) => {\n            receivedEvents.push(eventData);\n            if (\n              this._receiverOptions.trackLastEnqueuedEventProperties &&\n              this._baseConsumer &&\n              this._baseConsumer.runtimeInfo\n            ) {\n              this._lastEnqueuedEventProperties = this._baseConsumer.runtimeInfo;\n            }\n            // resolve the operation's promise after the requested\n            // number of events are received.\n            if (receivedEvents.length === maxMessageCount) {\n              logger.info(\n                \"[%s] Batching Receiver '%s', %d messages received within %d seconds.\",\n                this._context.connectionId,\n                this._baseConsumer && this._baseConsumer.name,\n                receivedEvents.length,\n                maxWaitTimeInSeconds\n              );\n              cleanUpBeforeReturn();\n              resolve(receivedEvents);\n            }\n          },\n          (err) => {\n            cleanUpBeforeReturn();\n            if (err.name === \"AbortError\") {\n              rejectOnAbort();\n            } else {\n              reject(err);\n            }\n          },\n          maxMessageCount - receivedEvents.length,\n          false,\n          abortSignal,\n          onAbort\n        );\n\n        const addTimeout = (): void => {\n          const msg = \"[%s] Setting the wait timer for %d seconds for receiver '%s'.\";\n          logger.verbose(\n            msg,\n            this._context.connectionId,\n            maxWaitTimeInSeconds,\n            this._baseConsumer && this._baseConsumer.name\n          );\n\n          // resolve the operation's promise after the requested\n          // max number of seconds have passed.\n          timer = setTimeout(() => {\n            logger.info(\n              \"[%s] Batching Receiver '%s', %d messages received when max wait time in seconds %d is over.\",\n              this._context.connectionId,\n              this._baseConsumer && this._baseConsumer.name,\n              receivedEvents.length,\n              maxWaitTimeInSeconds\n            );\n            cleanUpBeforeReturn();\n            resolve(receivedEvents);\n          }, maxWaitTimeInSeconds * 1000);\n        };\n\n        addTimeout();\n        if (abortSignal && !abortSignal.aborted) {\n          abortSignal.addEventListener(\"abort\", onAbort);\n        }\n      });\n    };\n\n    const retryOptions = this._retryOptions;\n    const config: RetryConfig<ReceivedEventData[]> = {\n      connectionHost: this._context.config.host,\n      connectionId: this._context.connectionId,\n      operation: retrieveEvents,\n      operationType: RetryOperationType.receiveMessage,\n      abortSignal: abortSignal,\n      retryOptions: retryOptions\n    };\n    return retry<ReceivedEventData[]>(config);\n  }\n\n  /**\n   * Closes the underlying AMQP receiver link.\n   * Once closed, the consumer cannot be used for any further operations.\n   * Use the `createConsumer` function on the EventHubClient to instantiate\n   * a new EventHubConsumer.\n   *\n   * @returns\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._context.connection && this._context.connection.isOpen()) {\n        if (this._baseConsumer) {\n          await this._baseConsumer.close();\n          this._baseConsumer = void 0;\n        }\n      }\n    } catch (err) {\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this.isReceivingMessages) {\n      const errorMessage = `The EventHubConsumer for \"${this._context.config.entityPath}\" is already receiving messages.`;\n      const error = new Error(errorMessage);\n      logger.warning(`[${this._context.connectionId}] %O`, error);\n      logErrorStackTrace(error);\n      throw error;\n    }\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (!this._baseConsumer || this.isClosed) {\n      const errorMessage =\n        `The EventHubConsumer for \"${this._context.config.entityPath}\" has been closed and can no longer be used. ` +\n        `Please create a new EventHubConsumer using the \"createConsumer\" function on the EventHubClient.`;\n      const error = new Error(errorMessage);\n      logger.error(`[${this._context.connectionId}] %O`, error);\n      logErrorStackTrace(error);\n      throw error;\n    }\n  }\n}\n"]}