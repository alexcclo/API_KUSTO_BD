// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { toAmqpMessage } from "./eventData";
import { message } from "rhea-promise";
import { throwTypeErrorIfParameterMissing } from "./util/error";
import { instrumentEventData, TRACEPARENT_PROPERTY } from "./diagnostics/instrumentEventData";
import { createMessageSpan } from "./diagnostics/messageSpan";
/**
 * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.
 * @param eventDataBatch The instance of `EventDataBatch` to verify.
 * @internal
 * @ignore
 */
export function isEventDataBatch(eventDataBatch) {
    return (eventDataBatch &&
        typeof eventDataBatch.tryAdd === "function" &&
        typeof eventDataBatch.count === "number" &&
        typeof eventDataBatch.sizeInBytes === "number");
}
/**
 * An internal class representing a batch of events which can be used to send events to Event Hub.
 *
 * @class
 * @internal
 * @ignore
 */
export class EventDataBatchImpl {
    /**
     * EventDataBatch should not be constructed using `new EventDataBatch()`
     * Use the `createBatch()` method on your `EventHubProducer` instead.
     * @constructor
     * @internal
     * @ignore
     */
    constructor(context, maxSizeInBytes, partitionKey, _partitionId) {
        this._partitionId = _partitionId;
        /**
         * @property Encoded amqp messages.
         */
        this._encodedMessages = [];
        /**
         * List of 'message' span contexts.
         */
        this._spanContexts = [];
        this._context = context;
        this._maxSizeInBytes = maxSizeInBytes;
        this._partitionKey = partitionKey;
        this._sizeInBytes = 0;
        this._count = 0;
    }
    /**
     * @property The maximum size of the batch, in bytes.
     * @readonly
     */
    get maxSizeInBytes() {
        return this._maxSizeInBytes;
    }
    /**
     * @property The partitionKey set during `EventDataBatch` creation. This value is hashed to
     * produce a partition assignment when the producer is created without a `partitionId`
     * @readonly
     */
    get partitionKey() {
        return this._partitionKey;
    }
    /**
     * The partitionId set during `EventDataBatch` creation.
     * If this value is set then partitionKey can not be set.
     * @readonly
     */
    get partitionId() {
        return this._partitionId;
    }
    /**
     * @property Size of the `EventDataBatch` instance after the events added to it have been
     * encoded into a single AMQP message.
     * @readonly
     */
    get sizeInBytes() {
        return this._sizeInBytes;
    }
    /**
     * @property Number of events in the `EventDataBatch` instance.
     * @readonly
     */
    get count() {
        return this._count;
    }
    /**
     * @property Represents the single AMQP message which is the result of encoding all the events
     * added into the `EventDataBatch` instance.
     *
     * This is not meant for the user to use directly.
     *
     * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,
     * this single batched AMQP message is what gets sent over the wire to the service.
     * @readonly
     */
    get _message() {
        return this._batchMessage;
    }
    /**
     * Gets the "message" span contexts that were created when adding events to the batch.
     * @internal
     * @ignore
     */
    get _messageSpanContexts() {
        return this._spanContexts;
    }
    /**
     * Tries to add an event data to the batch if permitted by the batch's size limit.
     * **NOTE**: Always remember to check the return value of this method, before calling it again
     * for the next event.
     *
     * @param eventData  An individual event data object.
     * @returns A boolean value indicating if the event data has been added to the batch or not.
     */
    tryAdd(eventData, options = {}) {
        throwTypeErrorIfParameterMissing(this._context.connectionId, "tryAdd", "eventData", eventData);
        // check if the event has already been instrumented
        const previouslyInstrumented = Boolean(eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]);
        if (!previouslyInstrumented) {
            const messageSpan = createMessageSpan(options.parentSpan);
            eventData = instrumentEventData(eventData, messageSpan);
            this._spanContexts.push(messageSpan.context());
            messageSpan.end();
        }
        // Convert EventData to AmqpMessage.
        const amqpMessage = toAmqpMessage(eventData, this._partitionKey);
        amqpMessage.body = this._context.dataTransformer.encode(eventData.body);
        // Encode every amqp message and then convert every encoded message to amqp data section
        this._encodedMessages.push(message.encode(amqpMessage));
        const batchMessage = {
            body: message.data_sections(this._encodedMessages)
        };
        if (amqpMessage.message_annotations) {
            batchMessage.message_annotations = amqpMessage.message_annotations;
        }
        const encodedBatchMessage = message.encode(batchMessage);
        const currentSize = encodedBatchMessage.length;
        // this._batchMessage will be used for final send operation
        if (currentSize > this._maxSizeInBytes) {
            this._encodedMessages.pop();
            if (!previouslyInstrumented &&
                Boolean(eventData.properties && eventData.properties[TRACEPARENT_PROPERTY])) {
                this._spanContexts.pop();
            }
            return false;
        }
        this._batchMessage = encodedBatchMessage;
        this._sizeInBytes = currentSize;
        this._count++;
        return true;
    }
}
//# sourceMappingURL=eventDataBatch.js.map