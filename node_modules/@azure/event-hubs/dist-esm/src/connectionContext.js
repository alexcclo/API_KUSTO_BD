// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import { logger } from "./log";
import { getRuntimeInfo } from "./util/runtimeInfo";
import { packageJsonInfo } from "./util/constants";
import { Constants, ConnectionContextBase } from "@azure/core-amqp";
import { ManagementClient } from "./managementClient";
import { ConnectionEvents } from "rhea-promise";
/**
 * @internal
 * @ignore
 */
export var ConnectionContext;
(function (ConnectionContext) {
    /**
     * @property userAgent The user agent string for the EventHubs client.
     * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk
     */
    const userAgent = `azsdk-js-azureeventhubs/${packageJsonInfo.version} (${getRuntimeInfo()})`;
    function getUserAgent(options) {
        const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;
        if (finalUserAgent.length > Constants.maxUserAgentLength) {
            throw new Error(`The user-agent string cannot be more than ${Constants.maxUserAgentLength} characters in length.` +
                `The given user-agent string is: ${finalUserAgent} with length: ${finalUserAgent.length}`);
        }
        return finalUserAgent;
    }
    ConnectionContext.getUserAgent = getUserAgent;
    function create(config, tokenCredential, options) {
        if (!options)
            options = {};
        config.webSocket = options.webSocketOptions && options.webSocketOptions.webSocket;
        config.webSocketEndpointPath = "$servicebus/websocket";
        config.webSocketConstructorOptions =
            options.webSocketOptions && options.webSocketOptions.webSocketConstructorOptions;
        const parameters = {
            config: config,
            tokenCredential: tokenCredential,
            // re-enabling this will be a post-GA discussion.
            // dataTransformer: options.dataTransformer,
            isEntityPathRequired: true,
            connectionProperties: {
                product: "MSJSClient",
                userAgent: getUserAgent(options),
                version: packageJsonInfo.version
            }
        };
        // Let us create the base context and then add EventHub specific ConnectionContext properties.
        const connectionContext = ConnectionContextBase.create(parameters);
        connectionContext.wasConnectionCloseCalled = false;
        connectionContext.senders = {};
        connectionContext.receivers = {};
        const mOptions = {
            address: options.managementSessionAddress,
            audience: options.managementSessionAudience
        };
        connectionContext.managementSession = new ManagementClient(connectionContext, mOptions);
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = (context) => {
            connectionContext.wasConnectionCloseCalled = false;
            logger.verbose("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = (context) => __awaiter(this, void 0, void 0, function* () {
            logger.verbose("[%s] 'disconnected' event occurred on the amqp connection.", connectionContext.connection.id);
            if (context.connection && context.connection.error) {
                logger.verbose("[%s] Accompanying error on the context.connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                logger.verbose("[%s] Accompanying error on the context: %O", connectionContext.connection.id, context.error);
            }
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numSenders: Object.keys(connectionContext.senders).length,
                numReceivers: Object.keys(connectionContext.receivers).length
            };
            logger.verbose("[%s] Closing all open senders and receivers in the state: %O", connectionContext.connection.id, state);
            // Clear internal map maintained by rhea to avoid reconnecting of old links once the
            // connection is back up.
            connectionContext.connection.removeAllSessions();
            // Close the cbs session to ensure all the event handlers are released.
            yield connectionContext.cbsSession.close();
            // Close the management session to ensure all the event handlers are released.
            yield connectionContext.managementSession.close();
            // Close all senders and receivers to ensure clean up of timers & other resources.
            if (state.numSenders || state.numReceivers) {
                for (const senderName of Object.keys(connectionContext.senders)) {
                    const sender = connectionContext.senders[senderName];
                    if (!sender.isConnecting) {
                        yield sender.close().catch((err) => {
                            logger.verbose("[%s] Error when closing sender [%s] after disconnected event: %O", connectionContext.connection.id, senderName, err);
                        });
                    }
                }
                for (const receiverName of Object.keys(connectionContext.receivers)) {
                    const receiver = connectionContext.receivers[receiverName];
                    if (!receiver.isConnecting) {
                        yield receiver.close().catch((err) => {
                            logger.verbose("[%s] Error when closing sender [%s] after disconnected event: %O", connectionContext.connection.id, receiverName, err);
                        });
                    }
                }
            }
        });
        const protocolError = (context) => __awaiter(this, void 0, void 0, function* () {
            logger.verbose("[%s] 'protocol_error' event occurred on the amqp connection.", connectionContext.connection.id);
            if (context.connection && context.connection.error) {
                logger.verbose("[%s] Accompanying error on the context.connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                logger.verbose("[%s] Accompanying error on the context: %O", connectionContext.connection.id, context.error);
            }
        });
        const error = (context) => __awaiter(this, void 0, void 0, function* () {
            logger.verbose("[%s] 'error' event occurred on the amqp connection.", connectionContext.connection.id);
            if (context.connection && context.connection.error) {
                logger.verbose("[%s] Accompanying error on the context.connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                logger.verbose("[%s] Accompanying error on the context: %O", connectionContext.connection.id, context.error);
            }
        });
        // Add listeners on the connection object.
        connectionContext.connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);
        connectionContext.connection.on(ConnectionEvents.disconnected, disconnected);
        connectionContext.connection.on(ConnectionEvents.protocolError, protocolError);
        connectionContext.connection.on(ConnectionEvents.error, error);
        logger.verbose("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
})(ConnectionContext || (ConnectionContext = {}));
//# sourceMappingURL=connectionContext.js.map