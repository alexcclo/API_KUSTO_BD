// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { translate, Constants, ErrorNameConditionMapper } from "@azure/core-amqp";
/**
 * @internal
 * @ignore
 * Gets the expression to be set as the filter clause when creating the receiver
 * @return {string} filterExpression
 */
export function getEventPositionFilter(eventPosition) {
    let result;
    // order of preference
    if (eventPosition.offset != undefined) {
        result = eventPosition.isInclusive
            ? `${Constants.offsetAnnotation} >= '${eventPosition.offset}'`
            : `${Constants.offsetAnnotation} > '${eventPosition.offset}'`;
    }
    else if (eventPosition.sequenceNumber != undefined) {
        result = eventPosition.isInclusive
            ? `${Constants.sequenceNumberAnnotation} >= '${eventPosition.sequenceNumber}'`
            : `${Constants.sequenceNumberAnnotation} > '${eventPosition.sequenceNumber}'`;
    }
    else if (eventPosition.enqueuedOn != undefined) {
        const time = eventPosition.enqueuedOn instanceof Date
            ? eventPosition.enqueuedOn.getTime()
            : eventPosition.enqueuedOn;
        result = `${Constants.enqueuedTimeAnnotation} > '${time}'`;
    }
    if (!result) {
        throw translate({
            condition: ErrorNameConditionMapper.ArgumentError,
            description: "No starting position was set in the EventPosition."
        });
    }
    return result;
}
/**
 * @internal
 * @ignore
 */
export function isLatestPosition(eventPosition) {
    if (eventPosition.offset === "@latest") {
        return true;
    }
    return false;
}
/**
 * Gets the `EventPosition` corresponding to the location of the the first event present in the partition.
 * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the
 * first event in the partition which has not expired due to the retention policy.
 */
export const earliestEventPosition = {
    offset: -1
};
/**
 * Gets the `EventPosition` corresponding to the end of the partition.
 * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the
 * event that is enqueued right after the method call.
 * @returns EventPosition
 */
export const latestEventPosition = {
    offset: "@latest"
};
/**
 * @ignore
 * @internal
 */
export function validateEventPositions(position) {
    if (position == undefined) {
        return;
    }
    const keys = Object.keys(position);
    if (!keys.length) {
        throw new TypeError("Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.");
    }
    if (isEventPosition(position)) {
        validateEventPosition(position);
        return;
    }
    const positions = position;
    for (let i = 0; i < keys.length; i++) {
        if (Object.prototype.hasOwnProperty.call(positions, keys[i])) {
            validateEventPosition(positions[keys[i]]);
        }
    }
}
/**
 * Determines whether a position is an EventPosition.
 * Does not validate that the position is allowed.
 * @param position
 * @ignore
 * @internal
 */
export function isEventPosition(position) {
    if (!position) {
        return false;
    }
    if (position.offset != undefined) {
        return true;
    }
    if (position.sequenceNumber != undefined) {
        return true;
    }
    if (position.enqueuedOn != undefined) {
        return true;
    }
    return false;
}
function validateEventPosition(position) {
    if (position == undefined) {
        return;
    }
    const offsetPresent = position.offset != undefined;
    const sequenceNumberPresent = position.sequenceNumber != undefined;
    const enqueuedOnPresent = position.enqueuedOn != undefined;
    if ((offsetPresent && sequenceNumberPresent) ||
        (offsetPresent && enqueuedOnPresent) ||
        (enqueuedOnPresent && sequenceNumberPresent)) {
        throw new TypeError("Invalid value for EventPosition found. Set only one of offset, sequenceNumber or enqueuedOn properties.");
    }
    if (!offsetPresent && !enqueuedOnPresent && !sequenceNumberPresent) {
        throw new TypeError("Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.");
    }
}
//# sourceMappingURL=eventPosition.js.map