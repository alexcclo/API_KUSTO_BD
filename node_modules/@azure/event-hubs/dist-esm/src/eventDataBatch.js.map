{"version":3,"file":"eventDataBatch.js","sourceRoot":"","sources":["../../src/eventDataBatch.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventData, toAmqpMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { AmqpMessage } from \"@azure/core-amqp\";\nimport { message } from \"rhea-promise\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { Span, SpanContext } from \"@opentelemetry/types\";\nimport { instrumentEventData, TRACEPARENT_PROPERTY } from \"./diagnostics/instrumentEventData\";\nimport { createMessageSpan } from \"./diagnostics/messageSpan\";\n\n/**\n * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.\n * @param eventDataBatch The instance of `EventDataBatch` to verify.\n * @internal\n * @ignore\n */\nexport function isEventDataBatch(eventDataBatch: any): eventDataBatch is EventDataBatch {\n  return (\n    eventDataBatch &&\n    typeof eventDataBatch.tryAdd === \"function\" &&\n    typeof eventDataBatch.count === \"number\" &&\n    typeof eventDataBatch.sizeInBytes === \"number\"\n  );\n}\n\n/**\n * Options to configure the behavior of the `tryAdd` method on the `EventDataBatch` class.\n */\nexport interface TryAddOptions {\n  /**\n   * The `Span` or `SpanContext` to use as the `parent` of any spans created while adding events.\n   */\n  parentSpan?: Span | SpanContext;\n}\n\n/**\n * An interface representing a batch of events which can be used to send events to Event Hub.\n * \n * To create the batch, use the `createBatch()` method on the `EventHubProducerClient`.\n * To send the batch, use the `sendBatch()` method on the same client.\n * To fill the batch, use the `tryAdd()` method on the batch itself.\n * \n */\nexport interface EventDataBatch {\n  /**\n   * A value that is hashed and used by the Azure Event Hubs service to determine the partition to\n   * which the events are sent. Use the `createBatch()` method on the `EventHubProducerClient` to\n   * set the partitionKey.\n   * @readonly\n   * @internal\n   * @ignore\n   */\n  readonly partitionKey?: string;\n\n  /**\n   * Id of the partition to which the batch of events are sent. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the partitionId.\n   * @readonly\n   * @internal\n   * @ignore\n   */\n  readonly partitionId?: string;\n\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of events added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAdd` function on the batch will return `false`\n   * if the event being added causes the size of the batch to exceed this limit. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the maxSizeInBytes.\n   * @readonly.\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds an event to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  tryAdd(eventData: EventData, options?: TryAddOptions): boolean;\n\n  /**\n   * The AMQP message containing encoded events that were added to the batch.\n   * Used internally by the `sendBatch()` method on the `EventHubProducerClient`.\n   * This is not meant for the user to use directly.\n   * \n   * @readonly\n   * @internal\n   * @ignore\n   */\n  readonly _message: Buffer | undefined;\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * Used internally by the `sendBatch()` method to set up the right spans in traces if tracing is enabled.\n   * @internal\n   * @ignore\n   */\n  readonly _messageSpanContexts: SpanContext[];\n}\n\n/**\n * An internal class representing a batch of events which can be used to send events to Event Hub.\n * \n * @class\n * @internal\n * @ignore\n */\nexport class EventDataBatchImpl implements EventDataBatch {\n  /**\n   * @property Describes the amqp connection context for the Client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * @property A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  private _partitionKey?: string;\n  /**\n   * @property The maximum size allowed for the batch.\n   */\n  private _maxSizeInBytes: number;\n  /**\n   * @property Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * @property Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * @property Number of events in the batch.\n   */\n  private _count: number;\n  /**\n   * @property Encoded batch message.\n   */\n  private _batchMessage: Buffer | undefined;\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: SpanContext[] = [];\n\n  /**\n   * EventDataBatch should not be constructed using `new EventDataBatch()`\n   * Use the `createBatch()` method on your `EventHubProducer` instead.\n   * @constructor\n   * @internal\n   * @ignore\n   */\n  constructor(\n    context: ConnectionContext,\n    maxSizeInBytes: number,\n    partitionKey?: string,\n    private _partitionId?: string\n  ) {\n    this._context = context;\n    this._maxSizeInBytes = maxSizeInBytes;\n    this._partitionKey = partitionKey;\n    this._sizeInBytes = 0;\n    this._count = 0;\n  }\n\n  /**\n   * @property The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * @property The partitionKey set during `EventDataBatch` creation. This value is hashed to\n   * produce a partition assignment when the producer is created without a `partitionId`\n   * @readonly\n   */\n  get partitionKey(): string | undefined {\n    return this._partitionKey;\n  }\n\n  /**\n   * The partitionId set during `EventDataBatch` creation.\n   * If this value is set then partitionKey can not be set.\n   * @readonly\n   */\n  get partitionId(): string | undefined {\n    return this._partitionId;\n  }\n\n  /**\n   * @property Size of the `EventDataBatch` instance after the events added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * @property Number of events in the `EventDataBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * @property Represents the single AMQP message which is the result of encoding all the events\n   * added into the `EventDataBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  get _message(): Buffer | undefined {\n    return this._batchMessage;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * @internal\n   * @ignore\n   */\n  get _messageSpanContexts(): SpanContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Tries to add an event data to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  public tryAdd(eventData: EventData, options: TryAddOptions = {}): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"tryAdd\", \"eventData\", eventData);\n\n    // check if the event has already been instrumented\n    const previouslyInstrumented = Boolean(\n      eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]\n    );\n    if (!previouslyInstrumented) {\n      const messageSpan = createMessageSpan(options.parentSpan);\n      eventData = instrumentEventData(eventData, messageSpan);\n      this._spanContexts.push(messageSpan.context());\n      messageSpan.end();\n    }\n    // Convert EventData to AmqpMessage.\n    const amqpMessage = toAmqpMessage(eventData, this._partitionKey);\n    amqpMessage.body = this._context.dataTransformer.encode(eventData.body);\n\n    // Encode every amqp message and then convert every encoded message to amqp data section\n    this._encodedMessages.push(message.encode(amqpMessage));\n\n    const batchMessage: AmqpMessage = {\n      body: message.data_sections(this._encodedMessages)\n    };\n\n    if (amqpMessage.message_annotations) {\n      batchMessage.message_annotations = amqpMessage.message_annotations;\n    }\n\n    const encodedBatchMessage = message.encode(batchMessage);\n    const currentSize = encodedBatchMessage.length;\n\n    // this._batchMessage will be used for final send operation\n    if (currentSize > this._maxSizeInBytes) {\n      this._encodedMessages.pop();\n      if (\n        !previouslyInstrumented &&\n        Boolean(eventData.properties && eventData.properties[TRACEPARENT_PROPERTY])\n      ) {\n        this._spanContexts.pop();\n      }\n      return false;\n    }\n    this._batchMessage = encodedBatchMessage;\n    this._sizeInBytes = currentSize;\n    this._count++;\n    return true;\n  }\n}\n"]}