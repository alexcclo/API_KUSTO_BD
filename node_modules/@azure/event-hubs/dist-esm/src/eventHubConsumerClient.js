// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { EventHubClient } from "./impl/eventHubClient";
import { InMemoryCheckpointStore } from "./inMemoryCheckpointStore";
import { EventProcessor } from "./eventProcessor";
import { GreedyPartitionLoadBalancer } from "./partitionLoadBalancer";
import { Constants } from "@azure/core-amqp";
import { logger } from "./log";
import { isTokenCredential } from "@azure/core-amqp";
import { PartitionGate } from "./impl/partitionGate";
import uuid from "uuid/v4";
import { validateEventPositions } from "./eventPosition";
const defaultConsumerClientOptions = {
    // to support our current "process single event only" workflow we'll also purposefully
    // only request a single event at a time.
    maxBatchSize: 1,
    maxWaitTimeInSeconds: 60
};
/**
 * The `EventHubConsumerClient` class is used to consume events from an Event Hub.
 *
 * There are multiple ways to create an `EventHubConsumerClient`
 * - Use the connection string from the SAS policy created for your Event Hub instance.
 * - Use the connection string from the SAS policy created for your Event Hub namespace,
 * and the name of the Event Hub instance
 * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.
 *
 * Optionally, you can also pass:
 * - An options bag to configure the retry policy or proxy settings.
 * - A checkpoint store that is used by the client to read checkpoints to determine the position from where it should
 * resume receiving events when your application gets restarted. The checkpoint store is also used by the client
 * to load balance multiple instances of your application.
 */
export class EventHubConsumerClient {
    constructor(_consumerGroup, connectionStringOrFullyQualifiedNamespace2, checkpointStoreOrEventHubNameOrOptions3, checkpointStoreOrCredentialOrOptions4, checkpointStoreOrOptions5, options6) {
        this._consumerGroup = _consumerGroup;
        this._partitionGate = new PartitionGate();
        this._id = uuid();
        if (isTokenCredential(checkpointStoreOrCredentialOrOptions4)) {
            // #3 or 3.1
            logger.info("Creating EventHubConsumerClient with TokenCredential.");
            let eventHubClientOptions;
            if (isCheckpointStore(checkpointStoreOrOptions5)) {
                // 3.1
                this._checkpointStore = checkpointStoreOrOptions5;
                this._userChoseCheckpointStore = true;
                eventHubClientOptions = options6;
            }
            else {
                this._checkpointStore = new InMemoryCheckpointStore();
                this._userChoseCheckpointStore = false;
                eventHubClientOptions = checkpointStoreOrOptions5;
            }
            this._eventHubClient = new EventHubClient(connectionStringOrFullyQualifiedNamespace2, checkpointStoreOrEventHubNameOrOptions3, checkpointStoreOrCredentialOrOptions4, eventHubClientOptions);
        }
        else if (typeof checkpointStoreOrEventHubNameOrOptions3 === "string") {
            // #2 or 2.1
            logger.info("Creating EventHubConsumerClient with connection string and event hub name.");
            let eventHubClientOptions;
            if (isCheckpointStore(checkpointStoreOrCredentialOrOptions4)) {
                // 2.1
                this._checkpointStore = checkpointStoreOrCredentialOrOptions4;
                this._userChoseCheckpointStore = true;
                eventHubClientOptions = checkpointStoreOrOptions5;
            }
            else {
                // 2
                this._checkpointStore = new InMemoryCheckpointStore();
                this._userChoseCheckpointStore = false;
                eventHubClientOptions = checkpointStoreOrCredentialOrOptions4;
            }
            this._eventHubClient = new EventHubClient(connectionStringOrFullyQualifiedNamespace2, checkpointStoreOrEventHubNameOrOptions3, eventHubClientOptions);
        }
        else {
            // #1 or 1.1
            logger.info("Creating EventHubConsumerClient with connection string.");
            let eventHubClientOptions;
            if (isCheckpointStore(checkpointStoreOrEventHubNameOrOptions3)) {
                // 1.1
                this._checkpointStore = checkpointStoreOrEventHubNameOrOptions3;
                this._userChoseCheckpointStore = true;
                eventHubClientOptions = checkpointStoreOrCredentialOrOptions4;
            }
            else {
                // 1
                this._checkpointStore = new InMemoryCheckpointStore();
                this._userChoseCheckpointStore = false;
                eventHubClientOptions = checkpointStoreOrEventHubNameOrOptions3;
            }
            this._eventHubClient = new EventHubClient(connectionStringOrFullyQualifiedNamespace2, eventHubClientOptions);
        }
    }
    /**
     * @property
     * @readonly
     * The name of the Event Hub instance for which this client is created.
     */
    get eventHubName() {
        return this._eventHubClient.eventHubName;
    }
    /**
     * @property
     * @readonly
     * The fully qualified namespace of the Event Hub instance for which this client is created.
     * This is likely to be similar to <yournamespace>.servicebus.windows.net.
     */
    get fullyQualifiedNamespace() {
        return this._eventHubClient.fullyQualifiedNamespace;
    }
    /**
     * Closes the AMQP connection to the Event Hub instance,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns Promise<void>
     * @throws Error if the underlying connection encounters an error while closing.
     */
    close() {
        return this._eventHubClient.close();
    }
    /**
     * Provides the id for each partition associated with the Event Hub.
     * @param options The set of options to apply to the operation call.
     * @returns A promise that resolves with an Array of strings representing the id for
     * each partition associated with the Event Hub.
     * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getPartitionIds(options = {}) {
        return this._eventHubClient.getPartitionIds(options);
    }
    /**
     * Provides information about the state of the specified partition.
     * @param partitionId The id of the partition for which information is required.
     * @param options The set of options to apply to the operation call.
     * @returns A promise that resolves with information about the state of the partition .
     * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getPartitionProperties(partitionId, options = {}) {
        return this._eventHubClient.getPartitionProperties(partitionId, options);
    }
    /**
     * Provides the Event Hub runtime information.
     * @param options The set of options to apply to the operation call.
     * @returns A promise that resolves with information about the Event Hub instance.
     * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.
     * @throws AbortError if the operation is cancelled via the abortSignal.
     */
    getEventHubProperties(options = {}) {
        return this._eventHubClient.getProperties(options);
    }
    subscribe(handlersOrPartitionId1, optionsOrHandlers2, possibleOptions3) {
        let eventProcessor;
        let targetedPartitionId;
        if (isSubscriptionEventHandlers(handlersOrPartitionId1)) {
            // #1: subscribe overload - read from all partitions
            const options = optionsOrHandlers2;
            if (options && options.startPosition) {
                validateEventPositions(options.startPosition);
            }
            ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForAllPartitions(handlersOrPartitionId1, options));
        }
        else if (typeof handlersOrPartitionId1 === "string" &&
            isSubscriptionEventHandlers(optionsOrHandlers2)) {
            // #2: subscribe overload (read from specific partition IDs), don't coordinate
            const options = possibleOptions3;
            if (options && options.startPosition) {
                validateEventPositions(options.startPosition);
            }
            ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForSinglePartition(handlersOrPartitionId1, optionsOrHandlers2, possibleOptions3));
        }
        else {
            throw new TypeError("Unhandled subscribe() overload");
        }
        eventProcessor.start();
        return {
            get isRunning() {
                return eventProcessor.isRunning();
            },
            close: () => {
                this._partitionGate.remove(targetedPartitionId);
                return eventProcessor.stop();
            }
        };
    }
    createEventProcessorForAllPartitions(subscriptionEventHandlers, options) {
        this._partitionGate.add("all");
        if (this._userChoseCheckpointStore) {
            logger.verbose("EventHubConsumerClient subscribing to all partitions, using a checkpoint store.");
        }
        else {
            logger.verbose("EventHubConsumerClient subscribing to all partitions, no checkpoint store.");
        }
        const eventProcessor = this._createEventProcessor(this._consumerGroup, this._eventHubClient, subscriptionEventHandlers, this._checkpointStore, Object.assign(Object.assign(Object.assign({}, defaultConsumerClientOptions), options), { ownerLevel: getOwnerLevel(options, this._userChoseCheckpointStore), processingTarget: this._userChoseCheckpointStore
                ? undefined
                : new GreedyPartitionLoadBalancer(), 
            // make it so all the event processors process work with the same overarching owner ID
            // this allows the EventHubConsumer to unify all the work for any processors that it spawns
            ownerId: this._id }));
        return { targetedPartitionId: "all", eventProcessor };
    }
    createEventProcessorForSinglePartition(partitionId, eventHandlers, options) {
        this._partitionGate.add(partitionId);
        const subscribeOptions = options;
        if (this._userChoseCheckpointStore) {
            logger.verbose(`EventHubConsumerClient subscribing to specific partition (${partitionId}), using a checkpoint store.`);
        }
        else {
            logger.verbose(`EventHubConsumerClient subscribing to specific partition (${partitionId}), no checkpoint store.`);
        }
        const eventProcessor = this._createEventProcessor(this._consumerGroup, this._eventHubClient, eventHandlers, this._checkpointStore, Object.assign(Object.assign(Object.assign({}, defaultConsumerClientOptions), options), { processingTarget: partitionId, ownerLevel: getOwnerLevel(subscribeOptions, this._userChoseCheckpointStore) }));
        return { targetedPartitionId: partitionId, eventProcessor };
    }
    _createEventProcessor(consumerGroup, eventHubClient, subscriptionEventHandlers, checkpointStore, options) {
        return new EventProcessor(consumerGroup, eventHubClient, subscriptionEventHandlers, checkpointStore, options);
    }
}
/**
 * @property
 * The name of the default consumer group in the Event Hubs service.
 */
EventHubConsumerClient.defaultConsumerGroupName = Constants.defaultConsumerGroup;
/**
 * @internal
 * @ignore
 */
export function isCheckpointStore(possible) {
    if (!possible) {
        return false;
    }
    const checkpointStore = possible;
    return (typeof checkpointStore.claimOwnership === "function" &&
        typeof checkpointStore.listCheckpoints === "function" &&
        typeof checkpointStore.listOwnership === "function" &&
        typeof checkpointStore.updateCheckpoint === "function");
}
/**
 * @internal
 * @ignore
 */
function isSubscriptionEventHandlers(possible) {
    return typeof possible.processEvents === "function";
}
function getOwnerLevel(options, userChoseCheckpointStore) {
    if (options && options.ownerLevel) {
        return options.ownerLevel;
    }
    if (userChoseCheckpointStore) {
        return 0;
    }
    else {
        return undefined;
    }
}
//# sourceMappingURL=eventHubConsumerClient.js.map