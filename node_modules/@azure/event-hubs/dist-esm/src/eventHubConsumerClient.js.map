{"version":3,"file":"eventHubConsumerClient.js","sourceRoot":"","sources":["../../src/eventHubConsumerClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventHubClient } from \"./impl/eventHubClient\";\nimport {\n  EventHubClientOptions,\n  GetPartitionPropertiesOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions\n} from \"./models/public\";\nimport { InMemoryCheckpointStore } from \"./inMemoryCheckpointStore\";\nimport { EventProcessor, CheckpointStore, FullEventProcessorOptions } from \"./eventProcessor\";\nimport { GreedyPartitionLoadBalancer } from \"./partitionLoadBalancer\";\nimport { TokenCredential, Constants } from \"@azure/core-amqp\";\nimport { logger } from \"./log\";\n\nimport {\n  SubscribeOptions,\n  Subscription,\n  SubscriptionEventHandlers\n} from \"./eventHubConsumerClientModels\";\nimport { isTokenCredential } from \"@azure/core-amqp\";\nimport { PartitionProperties, EventHubProperties } from \"./managementClient\";\nimport { PartitionGate } from \"./impl/partitionGate\";\nimport uuid from \"uuid/v4\";\nimport { validateEventPositions } from \"./eventPosition\";\n\nconst defaultConsumerClientOptions: Required<Pick<\n  FullEventProcessorOptions,\n  \"maxWaitTimeInSeconds\" | \"maxBatchSize\"\n>> = {\n  // to support our current \"process single event only\" workflow we'll also purposefully\n  // only request a single event at a time.\n  maxBatchSize: 1,\n  maxWaitTimeInSeconds: 60\n};\n\n/**\n * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n *\n * There are multiple ways to create an `EventHubConsumerClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.\n *\n * Optionally, you can also pass:\n * - An options bag to configure the retry policy or proxy settings.\n * - A checkpoint store that is used by the client to read checkpoints to determine the position from where it should\n * resume receiving events when your application gets restarted. The checkpoint store is also used by the client\n * to load balance multiple instances of your application.\n */\nexport class EventHubConsumerClient {\n  private _eventHubClient: EventHubClient;\n  private _partitionGate = new PartitionGate();\n  private _id = uuid();\n\n  /**\n   * @property\n   * The name of the default consumer group in the Event Hubs service.\n   */\n  static defaultConsumerGroupName: string = Constants.defaultConsumerGroup;\n\n  private _checkpointStore: CheckpointStore;\n  private _userChoseCheckpointStore: boolean;\n\n  /**\n   * @property\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._eventHubClient.eventHubName;\n  }\n\n  /**\n   * @property\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._eventHubClient.fullyQualifiedNamespace;\n  }\n\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(consumerGroup: string, connectionString: string, options?: EventHubClientOptions); // #1\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param checkpointStore A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubClientOptions\n  ); // #1.1\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    options?: EventHubClientOptions\n  ); // #2\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param checkpointStore A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubClientOptions\n  ); // #2.1\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service. See &commat;azure/identity for creating the credentials.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential,\n    options?: EventHubClientOptions\n  ); // #3\n  /**\n   * @constructor\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service. See &commat;azure/identity for creating the credentials.\n   * @param checkpointStore A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential,\n    checkpointStore: CheckpointStore,\n    options?: EventHubClientOptions\n  ); // #3.1\n  constructor(\n    private _consumerGroup: string,\n    connectionStringOrFullyQualifiedNamespace2: string,\n    checkpointStoreOrEventHubNameOrOptions3?: CheckpointStore | EventHubClientOptions | string,\n    checkpointStoreOrCredentialOrOptions4?:\n      | CheckpointStore\n      | EventHubClientOptions\n      | TokenCredential,\n    checkpointStoreOrOptions5?: CheckpointStore | EventHubClientOptions,\n    options6?: EventHubClientOptions\n  ) {\n    if (isTokenCredential(checkpointStoreOrCredentialOrOptions4)) {\n      // #3 or 3.1\n      logger.info(\"Creating EventHubConsumerClient with TokenCredential.\");\n\n      let eventHubClientOptions: EventHubClientOptions | undefined;\n\n      if (isCheckpointStore(checkpointStoreOrOptions5)) {\n        // 3.1\n        this._checkpointStore = checkpointStoreOrOptions5;\n        this._userChoseCheckpointStore = true;\n        eventHubClientOptions = options6;\n      } else {\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        eventHubClientOptions = checkpointStoreOrOptions5;\n      }\n\n      this._eventHubClient = new EventHubClient(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3 as string,\n        checkpointStoreOrCredentialOrOptions4,\n        eventHubClientOptions\n      );\n    } else if (typeof checkpointStoreOrEventHubNameOrOptions3 === \"string\") {\n      // #2 or 2.1\n      logger.info(\"Creating EventHubConsumerClient with connection string and event hub name.\");\n\n      let eventHubClientOptions: EventHubClientOptions | undefined;\n\n      if (isCheckpointStore(checkpointStoreOrCredentialOrOptions4)) {\n        // 2.1\n        this._checkpointStore = checkpointStoreOrCredentialOrOptions4;\n        this._userChoseCheckpointStore = true;\n        eventHubClientOptions = checkpointStoreOrOptions5 as EventHubClientOptions | undefined;\n      } else {\n        // 2\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        eventHubClientOptions = checkpointStoreOrCredentialOrOptions4;\n      }\n\n      this._eventHubClient = new EventHubClient(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3,\n        eventHubClientOptions as EventHubClientOptions\n      );\n    } else {\n      // #1 or 1.1\n      logger.info(\"Creating EventHubConsumerClient with connection string.\");\n\n      let eventHubClientOptions: EventHubClientOptions | undefined;\n\n      if (isCheckpointStore(checkpointStoreOrEventHubNameOrOptions3)) {\n        // 1.1\n        this._checkpointStore = checkpointStoreOrEventHubNameOrOptions3;\n        this._userChoseCheckpointStore = true;\n        eventHubClientOptions = checkpointStoreOrCredentialOrOptions4 as\n          | EventHubClientOptions\n          | undefined;\n      } else {\n        // 1\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        eventHubClientOptions = checkpointStoreOrEventHubNameOrOptions3 as\n          | EventHubClientOptions\n          | undefined;\n      }\n\n      this._eventHubClient = new EventHubClient(\n        connectionStringOrFullyQualifiedNamespace2,\n        eventHubClientOptions\n      );\n    }\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  close(): Promise<void> {\n    return this._eventHubClient.close();\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<string[]> {\n    return this._eventHubClient.getPartitionIds(options);\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId The id of the partition for which information is required.\n   * @param options The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    return this._eventHubClient.getPartitionProperties(partitionId, options);\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._eventHubClient.getProperties(options);\n  }\n\n  /**\n   * Subscribe to events from all partitions.\n   *\n   * If checkpoint store is provided to the `EventHubConsumerClient` and there are multiple\n   * instances of your application, then each instance will subscribe to a subset of the\n   * partitions such that the load is balanced amongst them.\n   *\n   * Call close() on the returned object to stop receiving events.\n   *\n   * @param handlers Handlers for the lifecycle of the subscription - subscription initialization\n   *                 per partition, receiving events, handling errors and the closing\n   *                 of a subscription per partition.\n   * @param options Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }\n   */\n  subscribe(handlers: SubscriptionEventHandlers, options?: SubscribeOptions): Subscription; // #1\n  /**\n   * Subscribe to events from a single partition.\n   * Call close() on the returned object to stop receiving events.\n   *\n   * @param partitionId The id of the partition to subscribe to.\n   * @param handlers Handlers for the lifecycle of the subscription - subscription initialization\n   *                 of the partition, receiving events, handling errors and the closing\n   *                 of a subscription to the partition.\n   * @param options Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }\n   */\n\n  subscribe(\n    partitionId: string,\n    handlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): Subscription; // #2\n  subscribe(\n    handlersOrPartitionId1?: SubscriptionEventHandlers | string,\n    optionsOrHandlers2?: SubscribeOptions | SubscriptionEventHandlers,\n    possibleOptions3?: SubscribeOptions\n  ): Subscription {\n    let eventProcessor: EventProcessor;\n    let targetedPartitionId: string;\n\n    if (isSubscriptionEventHandlers(handlersOrPartitionId1)) {\n      // #1: subscribe overload - read from all partitions\n      const options = optionsOrHandlers2 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForAllPartitions(\n        handlersOrPartitionId1,\n        options\n      ));\n    } else if (\n      typeof handlersOrPartitionId1 === \"string\" &&\n      isSubscriptionEventHandlers(optionsOrHandlers2)\n    ) {\n      // #2: subscribe overload (read from specific partition IDs), don't coordinate\n      const options = possibleOptions3 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForSinglePartition(\n        handlersOrPartitionId1,\n        optionsOrHandlers2,\n        possibleOptions3\n      ));\n    } else {\n      throw new TypeError(\"Unhandled subscribe() overload\");\n    }\n\n    eventProcessor.start();\n\n    return {\n      get isRunning() {\n        return eventProcessor.isRunning();\n      },\n      close: () => {\n        this._partitionGate.remove(targetedPartitionId);\n        return eventProcessor.stop();\n      }\n    };\n  }\n\n  private createEventProcessorForAllPartitions(\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ) {\n    this._partitionGate.add(\"all\");\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        \"EventHubConsumerClient subscribing to all partitions, using a checkpoint store.\"\n      );\n    } else {\n      logger.verbose(\"EventHubConsumerClient subscribing to all partitions, no checkpoint store.\");\n    }\n\n    const eventProcessor = this._createEventProcessor(\n      this._consumerGroup,\n      this._eventHubClient,\n      subscriptionEventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...(options as SubscribeOptions),\n        ownerLevel: getOwnerLevel(options, this._userChoseCheckpointStore),\n        processingTarget: this._userChoseCheckpointStore\n          ? undefined\n          : new GreedyPartitionLoadBalancer(),\n        // make it so all the event processors process work with the same overarching owner ID\n        // this allows the EventHubConsumer to unify all the work for any processors that it spawns\n        ownerId: this._id\n      }\n    );\n\n    return { targetedPartitionId: \"all\", eventProcessor };\n  }\n\n  private createEventProcessorForSinglePartition(\n    partitionId: string,\n    eventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ) {\n    this._partitionGate.add(partitionId);\n\n    const subscribeOptions = options as SubscribeOptions | undefined;\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), using a checkpoint store.`\n      );\n    } else {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), no checkpoint store.`\n      );\n    }\n\n    const eventProcessor = this._createEventProcessor(\n      this._consumerGroup,\n      this._eventHubClient,\n      eventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...options,\n        processingTarget: partitionId,\n        ownerLevel: getOwnerLevel(subscribeOptions, this._userChoseCheckpointStore)\n      }\n    );\n\n    return { targetedPartitionId: partitionId, eventProcessor };\n  }\n\n  private _createEventProcessor(\n    consumerGroup: string,\n    eventHubClient: EventHubClient,\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    checkpointStore: CheckpointStore,\n    options: FullEventProcessorOptions\n  ) {\n    return new EventProcessor(\n      consumerGroup,\n      eventHubClient,\n      subscriptionEventHandlers,\n      checkpointStore,\n      options\n    );\n  }\n}\n\n/**\n * @internal\n * @ignore\n */\nexport function isCheckpointStore(possible: CheckpointStore | any): possible is CheckpointStore {\n  if (!possible) {\n    return false;\n  }\n\n  const checkpointStore = possible as CheckpointStore;\n\n  return (\n    typeof checkpointStore.claimOwnership === \"function\" &&\n    typeof checkpointStore.listCheckpoints === \"function\" &&\n    typeof checkpointStore.listOwnership === \"function\" &&\n    typeof checkpointStore.updateCheckpoint === \"function\"\n  );\n}\n\n/**\n * @internal\n * @ignore\n */\nfunction isSubscriptionEventHandlers(\n  possible: any | SubscriptionEventHandlers\n): possible is SubscriptionEventHandlers {\n  return typeof (possible as SubscriptionEventHandlers).processEvents === \"function\";\n}\n\nfunction getOwnerLevel(\n  options: SubscribeOptions | undefined,\n  userChoseCheckpointStore: boolean\n): number | undefined {\n  if (options && options.ownerLevel) {\n    return options.ownerLevel;\n  }\n\n  if (userChoseCheckpointStore) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n"]}