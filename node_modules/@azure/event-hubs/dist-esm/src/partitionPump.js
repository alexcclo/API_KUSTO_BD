// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import { logger, logErrorStackTrace } from "./log";
import { CloseReason } from "./models/public";
import { AbortController } from "@azure/abort-controller";
import { getParentSpan } from "./util/operationOptions";
import { getTracer } from "@azure/core-tracing";
import { SpanKind, CanonicalCode } from "@opentelemetry/types";
import { extractSpanContextFromEventData } from "./diagnostics/instrumentEventData";
/**
 * @ignore
 * @internal
 */
export class PartitionPump {
    constructor(eventHubClient, partitionProcessor, _startPosition, options) {
        this._startPosition = _startPosition;
        this._isReceiving = false;
        this._isStopped = false;
        this._eventHubClient = eventHubClient;
        this._partitionProcessor = partitionProcessor;
        this._processorOptions = options;
        this._abortController = new AbortController();
    }
    get isReceiving() {
        return this._isReceiving;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this._isReceiving = true;
            try {
                yield this._partitionProcessor.initialize();
            }
            catch (err) {
                // swallow the error from the user-defined code
                this._partitionProcessor.processError(err);
            }
            // this is intentionally not await'd - the _receiveEvents loop will continue to
            // execute and can be stopped by calling .stop()
            this._receiveEvents(this._partitionProcessor.partitionId);
            logger.info(`Successfully started the receiver for partition "${this._partitionProcessor.partitionId}".`);
        });
    }
    _receiveEvents(partitionId) {
        return __awaiter(this, void 0, void 0, function* () {
            this._receiver = this._eventHubClient.createConsumer(this._partitionProcessor.consumerGroup, partitionId, this._startPosition, {
                ownerLevel: this._processorOptions.ownerLevel,
                trackLastEnqueuedEventProperties: this._processorOptions.trackLastEnqueuedEventProperties
            });
            while (this._isReceiving) {
                try {
                    const receivedEvents = yield this._receiver.receiveBatch(this._processorOptions.maxBatchSize, this._processorOptions.maxWaitTimeInSeconds, this._abortController.signal);
                    if (this._processorOptions.trackLastEnqueuedEventProperties &&
                        this._receiver.lastEnqueuedEventProperties) {
                        this._partitionProcessor.lastEnqueuedEventProperties = this._receiver.lastEnqueuedEventProperties;
                    }
                    // avoid calling user's processEvents handler if the pump was stopped while receiving events
                    if (!this._isReceiving) {
                        return;
                    }
                    const span = createProcessingSpan(receivedEvents, this._eventHubClient, this._processorOptions);
                    yield trace(() => this._partitionProcessor.processEvents(receivedEvents), span);
                }
                catch (err) {
                    // check if this pump is still receiving
                    // it may not be if the EventProcessor was stopped during processEvents
                    if (!this._isReceiving) {
                        // no longer receiving, so close was called from somewhere else
                        return;
                    }
                    logger.warning(`An error was thrown while receiving or processing events on partition "${this._partitionProcessor.partitionId}"`);
                    logErrorStackTrace(err);
                    // forward error to user's processError and swallow errors they may throw
                    try {
                        yield this._partitionProcessor.processError(err);
                    }
                    catch (err) {
                        // Using verbose over warning because this error is swallowed.
                        logger.verbose("An error was thrown by user's processError method: ", err);
                    }
                    // close the partition processor if a non-retryable error was encountered
                    if (typeof err !== "object" || !err.retryable) {
                        try {
                            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel
                            // started consuming the partition), update the closeReason
                            if (err.code === "ReceiverDisconnectedError") {
                                return yield this.stop(CloseReason.OwnershipLost);
                            }
                            // this will close the pump and will break us out of the while loop
                            return yield this.stop(CloseReason.Shutdown);
                        }
                        catch (err) {
                            // Using verbose over warning because this error is swallowed.
                            logger.verbose(`An error occurred while closing the receiver with reason ${CloseReason.Shutdown}: `, err);
                        }
                    }
                }
            }
        });
    }
    stop(reason) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isStopped) {
                return;
            }
            this._isStopped = true;
            this._isReceiving = false;
            try {
                if (this._receiver) {
                    yield this._receiver.close();
                }
                this._abortController.abort();
                yield this._partitionProcessor.close(reason);
            }
            catch (err) {
                logger.warning("An error occurred while closing the receiver.", err);
                logErrorStackTrace(err);
                this._partitionProcessor.processError(err);
                throw err;
            }
        });
    }
}
/**
 * @internal
 * @ignore
 */
export function createProcessingSpan(receivedEvents, eventHubProperties, tracingOptions) {
    const links = [];
    for (const receivedEvent of receivedEvents) {
        const spanContext = extractSpanContextFromEventData(receivedEvent);
        if (spanContext == null) {
            continue;
        }
        links.push({
            spanContext
        });
    }
    const span = getTracer().startSpan("Azure.EventHubs.process", {
        kind: SpanKind.CONSUMER,
        links,
        parent: getParentSpan(tracingOptions)
    });
    span.setAttributes({
        "az.namespace": "Microsoft.EventHub",
        "message_bus.destination": eventHubProperties.eventHubName,
        "peer.address": eventHubProperties.endpoint
    });
    return span;
}
/**
 * @ignore
 * @internal
 */
export function trace(fn, span) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fn();
            span.setStatus({ code: CanonicalCode.OK });
        }
        catch (err) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: err.message
            });
            throw err;
        }
        finally {
            span.end();
        }
    });
}
//# sourceMappingURL=partitionPump.js.map