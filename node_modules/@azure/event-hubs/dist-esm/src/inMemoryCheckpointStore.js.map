{"version":3,"file":"inMemoryCheckpointStore.js","sourceRoot":"","sources":["../../src/inMemoryCheckpointStore.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { PartitionOwnership, CheckpointStore } from \"./eventProcessor\";\nimport { Checkpoint } from \"./partitionProcessor\";\nimport { generate_uuid } from \"rhea-promise\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\n\n/**\n * The `EventProcessor` relies on a `CheckpointStore` to store checkpoints and handle partition\n * ownerships. `InMemoryCheckpointStore` is simple partition manager that stores checkpoints and\n * partition ownerships in memory of your program.\n *\n * You can use the `InMemoryCheckpointStore` to get started with using the `EventProcessor`.\n * But in production, you should choose an implementation of the `CheckpointStore` interface that will\n * store the checkpoints and partition ownerships to a durable store instead.\n *\n * @class\n * @internal\n * @ignore\n */\nexport class InMemoryCheckpointStore implements CheckpointStore {\n  private _partitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n  private _committedCheckpoints: Map<string, Map<string, Checkpoint>> = new Map();\n\n  /**\n   * Get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName The event hub name.\n   * @param consumerGroup The consumer group name.\n   * @return Partition ownership details of all the partitions that have/had an owner..\n   */\n  async listOwnership(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<PartitionOwnership[]> {\n    const ownerships = [];\n\n    for (const value of this._partitionOwnershipMap.values()) {\n      ownerships.push({ ...value });\n    }\n\n    return ownerships;\n  }\n\n  /**\n   * Claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership The list of partition ownership this instance is claiming to own.\n   * @return A list partitions this instance successfully claimed ownership.\n   */\n  async claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]> {\n    const claimedOwnerships = [];\n\n    for (const ownership of partitionOwnership) {\n      if (\n        !this._partitionOwnershipMap.has(ownership.partitionId) ||\n        this._partitionOwnershipMap.get(ownership.partitionId)!.etag === ownership.etag\n      ) {\n        var date = new Date();\n\n        const newOwnership = {\n          ...ownership,\n          etag: generate_uuid(),\n          lastModifiedTimeInMs: date.getTime()\n        };\n\n        this._partitionOwnershipMap.set(newOwnership.partitionId, newOwnership);\n        claimedOwnerships.push(newOwnership);\n      }\n    }\n    return claimedOwnerships;\n  }\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint The checkpoint.\n   */\n  async updateCheckpoint(checkpoint: Checkpoint): Promise<void> {\n    throwTypeErrorIfParameterMissing(\n      \"\",\n      \"updateCheckpoint\",\n      \"sequenceNumber\",\n      checkpoint.sequenceNumber\n    );\n    throwTypeErrorIfParameterMissing(\"\", \"updateCheckpoint\", \"offset\", checkpoint.offset);\n\n    checkpoint = { ...checkpoint };\n\n    const partitionOwnership = this._partitionOwnershipMap.get(checkpoint.partitionId);\n    if (partitionOwnership) {\n      partitionOwnership.etag = generate_uuid();\n\n      const key = `${checkpoint.fullyQualifiedNamespace}:${checkpoint.eventHubName}:${checkpoint.consumerGroup}`;\n      let partitionMap = this._committedCheckpoints.get(key);\n\n      if (partitionMap == null) {\n        partitionMap = new Map();\n        this._committedCheckpoints.set(key, partitionMap);\n      }\n\n      partitionMap.set(checkpoint.partitionId, checkpoint);\n    }\n  }\n\n  async listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<Checkpoint[]> {\n    const key = `${fullyQualifiedNamespace}:${eventHubName}:${consumerGroup}`;\n\n    const partitionMap = this._committedCheckpoints.get(key);\n\n    if (partitionMap == null) {\n      return [];\n    }\n\n    const checkpoints = [];\n\n    for (const value of partitionMap.values()) {\n      checkpoints.push({ ...value });\n    }\n\n    return checkpoints;\n  }\n}\n"]}